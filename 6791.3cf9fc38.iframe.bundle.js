/*! For license information please see 6791.3cf9fc38.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunk_rca_design_system_library=self.webpackChunk_rca_design_system_library||[]).push([[6791],{"./node_modules/@angular/router/fesm2022/router.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{GZ:()=>NoPreloading,cx:()=>ROUTER_CONFIGURATION,Z6:()=>ROUTES,F0:()=>Router,Bz:()=>RouterModule,lC:()=>RouterOutlet,Kx:()=>ROUTER_PROVIDERS,X0:()=>afterNextNavigation,HJ:()=>withPreloading});var core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),isObservable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/isObservable.js"),from=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/from.js"),of=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/of.js"),BehaviorSubject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),combineLatest=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js"),EmptyError=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/EmptyError.js"),concat=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/concat.js"),defer=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/defer.js"),pipe=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/pipe.js"),throwError=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/throwError.js"),empty=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/empty.js"),ConnectableObservable=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),map=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js"),switchMap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/switchMap.js"),take=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/take.js"),startWith=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/startWith.js"),filter=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/filter.js"),mergeMap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js"),first=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/first.js"),concatMap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/concatMap.js"),tap=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/tap.js"),catchError=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/catchError.js"),lift=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/lift.js"),OperatorSubscriber=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");function scan(accumulator,seed){return(0,lift.e)(function scanInternals(accumulator,seed,hasSeed,emitOnNext,emitBeforeComplete){return function(source,subscriber){var hasState=hasSeed,state=seed,index=0;source.subscribe((0,OperatorSubscriber.x)(subscriber,(function(value){var i=index++;state=hasState?accumulator(state,value,i):(hasState=!0,value),emitOnNext&&subscriber.next(state)}),emitBeforeComplete&&function(){hasState&&subscriber.next(state),subscriber.complete()}))}}(accumulator,seed,arguments.length>=2,!0))}var defaultIfEmpty=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js"),tslib_es6=__webpack_require__("./node_modules/rxjs/node_modules/tslib/tslib.es6.mjs");function takeLast(count){return count<=0?function(){return empty.E}:(0,lift.e)((function(source,subscriber){var buffer=[];source.subscribe((0,OperatorSubscriber.x)(subscriber,(function(value){buffer.push(value),count<buffer.length&&buffer.shift()}),(function(){var e_1,_a;try{for(var buffer_1=(0,tslib_es6.XA)(buffer),buffer_1_1=buffer_1.next();!buffer_1_1.done;buffer_1_1=buffer_1.next()){var value=buffer_1_1.value;subscriber.next(value)}}catch(e_1_1){e_1={error:e_1_1}}finally{try{buffer_1_1&&!buffer_1_1.done&&(_a=buffer_1.return)&&_a.call(buffer_1)}finally{if(e_1)throw e_1.error}}subscriber.complete()}),void 0,(function(){buffer=null})))}))}var throwIfEmpty=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js"),identity=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/util/identity.js");var mapTo=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/mapTo.js"),finalize=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/finalize.js"),refCount=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/refCount.js"),mergeAll=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js"),platform_browser=__webpack_require__("./node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs");const PRIMARY_OUTLET="primary",RouteTitleKey=Symbol("RouteTitle");class ParamsAsMap{constructor(params){this.params=params||{}}has(name){return Object.prototype.hasOwnProperty.call(this.params,name)}get(name){if(this.has(name)){const v=this.params[name];return Array.isArray(v)?v[0]:v}return null}getAll(name){if(this.has(name)){const v=this.params[name];return Array.isArray(v)?v:[v]}return[]}get keys(){return Object.keys(this.params)}}function convertToParamMap(params){return new ParamsAsMap(params)}function defaultUrlMatcher(segments,segmentGroup,route){const parts=route.path.split("/");if(parts.length>segments.length)return null;if("full"===route.pathMatch&&(segmentGroup.hasChildren()||parts.length<segments.length))return null;const posParams={};for(let index=0;index<parts.length;index++){const part=parts[index],segment=segments[index];if(part.startsWith(":"))posParams[part.substring(1)]=segment;else if(part!==segment.path)return null}return{consumed:segments.slice(0,parts.length),posParams}}function shallowEqual(a,b){const k1=a?Object.keys(a):void 0,k2=b?Object.keys(b):void 0;if(!k1||!k2||k1.length!=k2.length)return!1;let key;for(let i=0;i<k1.length;i++)if(key=k1[i],!equalArraysOrString(a[key],b[key]))return!1;return!0}function equalArraysOrString(a,b){if(Array.isArray(a)&&Array.isArray(b)){if(a.length!==b.length)return!1;const aSorted=[...a].sort(),bSorted=[...b].sort();return aSorted.every(((val,index)=>bSorted[index]===val))}return a===b}function router_last(a){return a.length>0?a[a.length-1]:null}function wrapIntoObservable(value){return(0,isObservable.b)(value)?value:(0,core["ɵisPromise"])(value)?(0,from.D)(Promise.resolve(value)):(0,of.of)(value)}const pathCompareMap={exact:function equalSegmentGroups(container,containee,matrixParams){if(!equalPath(container.segments,containee.segments))return!1;if(!matrixParamsMatch(container.segments,containee.segments,matrixParams))return!1;if(container.numberOfChildren!==containee.numberOfChildren)return!1;for(const c in containee.children){if(!container.children[c])return!1;if(!equalSegmentGroups(container.children[c],containee.children[c],matrixParams))return!1}return!0},subset:containsSegmentGroup},paramCompareMap={exact:function equalParams(container,containee){return shallowEqual(container,containee)},subset:function containsParams(container,containee){return Object.keys(containee).length<=Object.keys(container).length&&Object.keys(containee).every((key=>equalArraysOrString(container[key],containee[key])))},ignored:()=>!0};function containsTree(container,containee,options){return pathCompareMap[options.paths](container.root,containee.root,options.matrixParams)&&paramCompareMap[options.queryParams](container.queryParams,containee.queryParams)&&!("exact"===options.fragment&&container.fragment!==containee.fragment)}function containsSegmentGroup(container,containee,matrixParams){return containsSegmentGroupHelper(container,containee,containee.segments,matrixParams)}function containsSegmentGroupHelper(container,containee,containeePaths,matrixParams){if(container.segments.length>containeePaths.length){const current=container.segments.slice(0,containeePaths.length);return!!equalPath(current,containeePaths)&&(!containee.hasChildren()&&!!matrixParamsMatch(current,containeePaths,matrixParams))}if(container.segments.length===containeePaths.length){if(!equalPath(container.segments,containeePaths))return!1;if(!matrixParamsMatch(container.segments,containeePaths,matrixParams))return!1;for(const c in containee.children){if(!container.children[c])return!1;if(!containsSegmentGroup(container.children[c],containee.children[c],matrixParams))return!1}return!0}{const current=containeePaths.slice(0,container.segments.length),next=containeePaths.slice(container.segments.length);return!!equalPath(container.segments,current)&&(!!matrixParamsMatch(container.segments,current,matrixParams)&&(!!container.children[PRIMARY_OUTLET]&&containsSegmentGroupHelper(container.children[PRIMARY_OUTLET],containee,next,matrixParams)))}}function matrixParamsMatch(containerPaths,containeePaths,options){return containeePaths.every(((containeeSegment,i)=>paramCompareMap[options](containerPaths[i].parameters,containeeSegment.parameters)))}class UrlTree{constructor(root=new UrlSegmentGroup([],{}),queryParams={},fragment=null){if(this.root=root,this.queryParams=queryParams,this.fragment=fragment,("undefined"==typeof ngDevMode||ngDevMode)&&root.segments.length>0)throw new core["ɵRuntimeError"](4015,"The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.")}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=convertToParamMap(this.queryParams)),this._queryParamMap}toString(){return DEFAULT_SERIALIZER.serialize(this)}}class UrlSegmentGroup{constructor(segments,children){this.segments=segments,this.children=children,this.parent=null,Object.values(children).forEach((v=>v.parent=this))}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return serializePaths(this)}}class UrlSegment{constructor(path,parameters){this.path=path,this.parameters=parameters}get parameterMap(){return this._parameterMap||(this._parameterMap=convertToParamMap(this.parameters)),this._parameterMap}toString(){return serializePath(this)}}function equalPath(as,bs){return as.length===bs.length&&as.every(((a,i)=>a.path===bs[i].path))}class UrlSerializer{static#_=this.ɵfac=function UrlSerializer_Factory(t){return new(t||UrlSerializer)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:UrlSerializer,factory:function(){return new DefaultUrlSerializer},providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](UrlSerializer,[{type:core.Injectable,args:[{providedIn:"root",useFactory:()=>new DefaultUrlSerializer}]}],null,null);class DefaultUrlSerializer{parse(url){const p=new UrlParser(url);return new UrlTree(p.parseRootSegment(),p.parseQueryParams(),p.parseFragment())}serialize(tree){return`${`/${serializeSegment(tree.root,!0)}`}${function serializeQueryParams(params){const strParams=Object.keys(params).map((name=>{const value=params[name];return Array.isArray(value)?value.map((v=>`${encodeUriQuery(name)}=${encodeUriQuery(v)}`)).join("&"):`${encodeUriQuery(name)}=${encodeUriQuery(value)}`})).filter((s=>!!s));return strParams.length?`?${strParams.join("&")}`:""}(tree.queryParams)}${"string"==typeof tree.fragment?`#${function encodeUriFragment(s){return encodeURI(s)}(tree.fragment)}`:""}`}}const DEFAULT_SERIALIZER=new DefaultUrlSerializer;function serializePaths(segment){return segment.segments.map((p=>serializePath(p))).join("/")}function serializeSegment(segment,root){if(!segment.hasChildren())return serializePaths(segment);if(root){const primary=segment.children[PRIMARY_OUTLET]?serializeSegment(segment.children[PRIMARY_OUTLET],!1):"",children=[];return Object.entries(segment.children).forEach((([k,v])=>{k!==PRIMARY_OUTLET&&children.push(`${k}:${serializeSegment(v,!1)}`)})),children.length>0?`${primary}(${children.join("//")})`:primary}{const children=function mapChildrenIntoArray(segment,fn){let res=[];return Object.entries(segment.children).forEach((([childOutlet,child])=>{childOutlet===PRIMARY_OUTLET&&(res=res.concat(fn(child,childOutlet)))})),Object.entries(segment.children).forEach((([childOutlet,child])=>{childOutlet!==PRIMARY_OUTLET&&(res=res.concat(fn(child,childOutlet)))})),res}(segment,((v,k)=>k===PRIMARY_OUTLET?[serializeSegment(segment.children[PRIMARY_OUTLET],!1)]:[`${k}:${serializeSegment(v,!1)}`]));return 1===Object.keys(segment.children).length&&null!=segment.children[PRIMARY_OUTLET]?`${serializePaths(segment)}/${children[0]}`:`${serializePaths(segment)}/(${children.join("//")})`}}function encodeUriString(s){return encodeURIComponent(s).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function encodeUriQuery(s){return encodeUriString(s).replace(/%3B/gi,";")}function encodeUriSegment(s){return encodeUriString(s).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function decode(s){return decodeURIComponent(s)}function decodeQuery(s){return decode(s.replace(/\+/g,"%20"))}function serializePath(path){return`${encodeUriSegment(path.path)}${function serializeMatrixParams(params){return Object.keys(params).map((key=>`;${encodeUriSegment(key)}=${encodeUriSegment(params[key])}`)).join("")}(path.parameters)}`}const SEGMENT_RE=/^[^\/()?;#]+/;function matchSegments(str){const match=str.match(SEGMENT_RE);return match?match[0]:""}const MATRIX_PARAM_SEGMENT_RE=/^[^\/()?;=#]+/;const QUERY_PARAM_RE=/^[^=?&#]+/;const QUERY_PARAM_VALUE_RE=/^[^&#]+/;class UrlParser{constructor(url){this.url=url,this.remaining=url}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new UrlSegmentGroup([],{}):new UrlSegmentGroup([],this.parseChildren())}parseQueryParams(){const params={};if(this.consumeOptional("?"))do{this.parseQueryParam(params)}while(this.consumeOptional("&"));return params}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const segments=[];for(this.peekStartsWith("(")||segments.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),segments.push(this.parseSegment());let children={};this.peekStartsWith("/(")&&(this.capture("/"),children=this.parseParens(!0));let res={};return this.peekStartsWith("(")&&(res=this.parseParens(!1)),(segments.length>0||Object.keys(children).length>0)&&(res[PRIMARY_OUTLET]=new UrlSegmentGroup(segments,children)),res}parseSegment(){const path=matchSegments(this.remaining);if(""===path&&this.peekStartsWith(";"))throw new core["ɵRuntimeError"](4009,("undefined"==typeof ngDevMode||ngDevMode)&&`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(path),new UrlSegment(decode(path),this.parseMatrixParams())}parseMatrixParams(){const params={};for(;this.consumeOptional(";");)this.parseParam(params);return params}parseParam(params){const key=function matchMatrixKeySegments(str){const match=str.match(MATRIX_PARAM_SEGMENT_RE);return match?match[0]:""}(this.remaining);if(!key)return;this.capture(key);let value="";if(this.consumeOptional("=")){const valueMatch=matchSegments(this.remaining);valueMatch&&(value=valueMatch,this.capture(value))}params[decode(key)]=decode(value)}parseQueryParam(params){const key=function matchQueryParams(str){const match=str.match(QUERY_PARAM_RE);return match?match[0]:""}(this.remaining);if(!key)return;this.capture(key);let value="";if(this.consumeOptional("=")){const valueMatch=function matchUrlQueryParamValue(str){const match=str.match(QUERY_PARAM_VALUE_RE);return match?match[0]:""}(this.remaining);valueMatch&&(value=valueMatch,this.capture(value))}const decodedKey=decodeQuery(key),decodedVal=decodeQuery(value);if(params.hasOwnProperty(decodedKey)){let currentVal=params[decodedKey];Array.isArray(currentVal)||(currentVal=[currentVal],params[decodedKey]=currentVal),currentVal.push(decodedVal)}else params[decodedKey]=decodedVal}parseParens(allowPrimary){const segments={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const path=matchSegments(this.remaining),next=this.remaining[path.length];if("/"!==next&&")"!==next&&";"!==next)throw new core["ɵRuntimeError"](4010,("undefined"==typeof ngDevMode||ngDevMode)&&`Cannot parse url '${this.url}'`);let outletName;path.indexOf(":")>-1?(outletName=path.slice(0,path.indexOf(":")),this.capture(outletName),this.capture(":")):allowPrimary&&(outletName=PRIMARY_OUTLET);const children=this.parseChildren();segments[outletName]=1===Object.keys(children).length?children[PRIMARY_OUTLET]:new UrlSegmentGroup([],children),this.consumeOptional("//")}return segments}peekStartsWith(str){return this.remaining.startsWith(str)}consumeOptional(str){return!!this.peekStartsWith(str)&&(this.remaining=this.remaining.substring(str.length),!0)}capture(str){if(!this.consumeOptional(str))throw new core["ɵRuntimeError"](4011,("undefined"==typeof ngDevMode||ngDevMode)&&`Expected "${str}".`)}}function createRoot(rootCandidate){return rootCandidate.segments.length>0?new UrlSegmentGroup([],{[PRIMARY_OUTLET]:rootCandidate}):rootCandidate}function squashSegmentGroup(segmentGroup){const newChildren={};for(const childOutlet of Object.keys(segmentGroup.children)){const childCandidate=squashSegmentGroup(segmentGroup.children[childOutlet]);if(childOutlet===PRIMARY_OUTLET&&0===childCandidate.segments.length&&childCandidate.hasChildren())for(const[grandChildOutlet,grandChild]of Object.entries(childCandidate.children))newChildren[grandChildOutlet]=grandChild;else(childCandidate.segments.length>0||childCandidate.hasChildren())&&(newChildren[childOutlet]=childCandidate)}return function mergeTrivialChildren(s){if(1===s.numberOfChildren&&s.children[PRIMARY_OUTLET]){const c=s.children[PRIMARY_OUTLET];return new UrlSegmentGroup(s.segments.concat(c.segments),c.children)}return s}(new UrlSegmentGroup(segmentGroup.segments,newChildren))}function isUrlTree(v){return v instanceof UrlTree}function createSegmentGroupFromRoute(route){let targetGroup;const rootCandidate=function createSegmentGroupFromRouteRecursive(currentRoute){const childOutlets={};for(const childSnapshot of currentRoute.children){const root=createSegmentGroupFromRouteRecursive(childSnapshot);childOutlets[childSnapshot.outlet]=root}const segmentGroup=new UrlSegmentGroup(currentRoute.url,childOutlets);return currentRoute===route&&(targetGroup=segmentGroup),segmentGroup}(route.root),rootSegmentGroup=createRoot(rootCandidate);return targetGroup??rootSegmentGroup}function createUrlTreeFromSegmentGroup(relativeTo,commands,queryParams,fragment){let root=relativeTo;for(;root.parent;)root=root.parent;if(0===commands.length)return tree(root,root,root,queryParams,fragment);const nav=function computeNavigation(commands){if("string"==typeof commands[0]&&1===commands.length&&"/"===commands[0])return new Navigation(!0,0,commands);let numberOfDoubleDots=0,isAbsolute=!1;const res=commands.reduce(((res,cmd,cmdIdx)=>{if("object"==typeof cmd&&null!=cmd){if(cmd.outlets){const outlets={};return Object.entries(cmd.outlets).forEach((([name,commands])=>{outlets[name]="string"==typeof commands?commands.split("/"):commands})),[...res,{outlets}]}if(cmd.segmentPath)return[...res,cmd.segmentPath]}return"string"!=typeof cmd?[...res,cmd]:0===cmdIdx?(cmd.split("/").forEach(((urlPart,partIndex)=>{0==partIndex&&"."===urlPart||(0==partIndex&&""===urlPart?isAbsolute=!0:".."===urlPart?numberOfDoubleDots++:""!=urlPart&&res.push(urlPart))})),res):[...res,cmd]}),[]);return new Navigation(isAbsolute,numberOfDoubleDots,res)}(commands);if(nav.toRoot())return tree(root,root,new UrlSegmentGroup([],{}),queryParams,fragment);const position=function findStartingPositionForTargetGroup(nav,root,target){if(nav.isAbsolute)return new Position(root,!0,0);if(!target)return new Position(root,!1,NaN);if(null===target.parent)return new Position(target,!0,0);const modifier=isMatrixParams(nav.commands[0])?0:1,index=target.segments.length-1+modifier;return function createPositionApplyingDoubleDots(group,index,numberOfDoubleDots){let g=group,ci=index,dd=numberOfDoubleDots;for(;dd>ci;){if(dd-=ci,g=g.parent,!g)throw new core["ɵRuntimeError"](4005,("undefined"==typeof ngDevMode||ngDevMode)&&"Invalid number of '../'");ci=g.segments.length}return new Position(g,!1,ci-dd)}(target,index,nav.numberOfDoubleDots)}(nav,root,relativeTo),newSegmentGroup=position.processChildren?updateSegmentGroupChildren(position.segmentGroup,position.index,nav.commands):updateSegmentGroup(position.segmentGroup,position.index,nav.commands);return tree(root,position.segmentGroup,newSegmentGroup,queryParams,fragment)}function isMatrixParams(command){return"object"==typeof command&&null!=command&&!command.outlets&&!command.segmentPath}function isCommandWithOutlets(command){return"object"==typeof command&&null!=command&&command.outlets}function tree(oldRoot,oldSegmentGroup,newSegmentGroup,queryParams,fragment){let rootCandidate,qp={};queryParams&&Object.entries(queryParams).forEach((([name,value])=>{qp[name]=Array.isArray(value)?value.map((v=>`${v}`)):`${value}`})),rootCandidate=oldRoot===oldSegmentGroup?newSegmentGroup:replaceSegment(oldRoot,oldSegmentGroup,newSegmentGroup);const newRoot=createRoot(squashSegmentGroup(rootCandidate));return new UrlTree(newRoot,qp,fragment)}function replaceSegment(current,oldSegment,newSegment){const children={};return Object.entries(current.children).forEach((([outletName,c])=>{children[outletName]=c===oldSegment?newSegment:replaceSegment(c,oldSegment,newSegment)})),new UrlSegmentGroup(current.segments,children)}class Navigation{constructor(isAbsolute,numberOfDoubleDots,commands){if(this.isAbsolute=isAbsolute,this.numberOfDoubleDots=numberOfDoubleDots,this.commands=commands,isAbsolute&&commands.length>0&&isMatrixParams(commands[0]))throw new core["ɵRuntimeError"](4003,("undefined"==typeof ngDevMode||ngDevMode)&&"Root segment cannot have matrix parameters");const cmdWithOutlet=commands.find(isCommandWithOutlets);if(cmdWithOutlet&&cmdWithOutlet!==router_last(commands))throw new core["ɵRuntimeError"](4004,("undefined"==typeof ngDevMode||ngDevMode)&&"{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Position{constructor(segmentGroup,processChildren,index){this.segmentGroup=segmentGroup,this.processChildren=processChildren,this.index=index}}function updateSegmentGroup(segmentGroup,startIndex,commands){if(segmentGroup||(segmentGroup=new UrlSegmentGroup([],{})),0===segmentGroup.segments.length&&segmentGroup.hasChildren())return updateSegmentGroupChildren(segmentGroup,startIndex,commands);const m=function prefixedWith(segmentGroup,startIndex,commands){let currentCommandIndex=0,currentPathIndex=startIndex;const noMatch={match:!1,pathIndex:0,commandIndex:0};for(;currentPathIndex<segmentGroup.segments.length;){if(currentCommandIndex>=commands.length)return noMatch;const path=segmentGroup.segments[currentPathIndex],command=commands[currentCommandIndex];if(isCommandWithOutlets(command))break;const curr=`${command}`,next=currentCommandIndex<commands.length-1?commands[currentCommandIndex+1]:null;if(currentPathIndex>0&&void 0===curr)break;if(curr&&next&&"object"==typeof next&&void 0===next.outlets){if(!compare(curr,next,path))return noMatch;currentCommandIndex+=2}else{if(!compare(curr,{},path))return noMatch;currentCommandIndex++}currentPathIndex++}return{match:!0,pathIndex:currentPathIndex,commandIndex:currentCommandIndex}}(segmentGroup,startIndex,commands),slicedCommands=commands.slice(m.commandIndex);if(m.match&&m.pathIndex<segmentGroup.segments.length){const g=new UrlSegmentGroup(segmentGroup.segments.slice(0,m.pathIndex),{});return g.children[PRIMARY_OUTLET]=new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex),segmentGroup.children),updateSegmentGroupChildren(g,0,slicedCommands)}return m.match&&0===slicedCommands.length?new UrlSegmentGroup(segmentGroup.segments,{}):m.match&&!segmentGroup.hasChildren()?createNewSegmentGroup(segmentGroup,startIndex,commands):m.match?updateSegmentGroupChildren(segmentGroup,0,slicedCommands):createNewSegmentGroup(segmentGroup,startIndex,commands)}function updateSegmentGroupChildren(segmentGroup,startIndex,commands){if(0===commands.length)return new UrlSegmentGroup(segmentGroup.segments,{});{const outlets=function getOutlets(commands){return isCommandWithOutlets(commands[0])?commands[0].outlets:{[PRIMARY_OUTLET]:commands}}(commands),children={};if(!outlets[PRIMARY_OUTLET]&&segmentGroup.children[PRIMARY_OUTLET]&&1===segmentGroup.numberOfChildren&&0===segmentGroup.children[PRIMARY_OUTLET].segments.length){const childrenOfEmptyChild=updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET],startIndex,commands);return new UrlSegmentGroup(segmentGroup.segments,childrenOfEmptyChild.children)}return Object.entries(outlets).forEach((([outlet,commands])=>{"string"==typeof commands&&(commands=[commands]),null!==commands&&(children[outlet]=updateSegmentGroup(segmentGroup.children[outlet],startIndex,commands))})),Object.entries(segmentGroup.children).forEach((([childOutlet,child])=>{void 0===outlets[childOutlet]&&(children[childOutlet]=child)})),new UrlSegmentGroup(segmentGroup.segments,children)}}function createNewSegmentGroup(segmentGroup,startIndex,commands){const paths=segmentGroup.segments.slice(0,startIndex);let i=0;for(;i<commands.length;){const command=commands[i];if(isCommandWithOutlets(command)){const children=createNewSegmentChildren(command.outlets);return new UrlSegmentGroup(paths,children)}if(0===i&&isMatrixParams(commands[0])){const p=segmentGroup.segments[startIndex];paths.push(new UrlSegment(p.path,stringify(commands[0]))),i++;continue}const curr=isCommandWithOutlets(command)?command.outlets[PRIMARY_OUTLET]:`${command}`,next=i<commands.length-1?commands[i+1]:null;curr&&next&&isMatrixParams(next)?(paths.push(new UrlSegment(curr,stringify(next))),i+=2):(paths.push(new UrlSegment(curr,{})),i++)}return new UrlSegmentGroup(paths,{})}function createNewSegmentChildren(outlets){const children={};return Object.entries(outlets).forEach((([outlet,commands])=>{"string"==typeof commands&&(commands=[commands]),null!==commands&&(children[outlet]=createNewSegmentGroup(new UrlSegmentGroup([],{}),0,commands))})),children}function stringify(params){const res={};return Object.entries(params).forEach((([k,v])=>res[k]=`${v}`)),res}function compare(path,params,segment){return path==segment.path&&shallowEqual(params,segment.parameters)}class RouterEvent{constructor(id,url){this.id=id,this.url=url}}class NavigationStart extends RouterEvent{constructor(id,url,navigationTrigger="imperative",restoredState=null){super(id,url),this.type=0,this.navigationTrigger=navigationTrigger,this.restoredState=restoredState}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class NavigationEnd extends RouterEvent{constructor(id,url,urlAfterRedirects){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.type=1}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class NavigationCancel extends RouterEvent{constructor(id,url,reason,code){super(id,url),this.reason=reason,this.code=code,this.type=2}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class NavigationSkipped extends RouterEvent{constructor(id,url,reason,code){super(id,url),this.reason=reason,this.code=code,this.type=16}}class NavigationError extends RouterEvent{constructor(id,url,error,target){super(id,url),this.error=error,this.target=target,this.type=3}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class RoutesRecognized extends RouterEvent{constructor(id,url,urlAfterRedirects,state){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.state=state,this.type=4}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class GuardsCheckStart extends RouterEvent{constructor(id,url,urlAfterRedirects,state){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.state=state,this.type=7}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class GuardsCheckEnd extends RouterEvent{constructor(id,url,urlAfterRedirects,state,shouldActivate){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.state=state,this.shouldActivate=shouldActivate,this.type=8}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class ResolveStart extends RouterEvent{constructor(id,url,urlAfterRedirects,state){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.state=state,this.type=5}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ResolveEnd extends RouterEvent{constructor(id,url,urlAfterRedirects,state){super(id,url),this.urlAfterRedirects=urlAfterRedirects,this.state=state,this.type=6}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class RouteConfigLoadStart{constructor(route){this.route=route,this.type=9}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class RouteConfigLoadEnd{constructor(route){this.route=route,this.type=10}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class ChildActivationStart{constructor(snapshot){this.snapshot=snapshot,this.type=11}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ChildActivationEnd{constructor(snapshot){this.snapshot=snapshot,this.type=12}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ActivationStart{constructor(snapshot){this.snapshot=snapshot,this.type=13}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ActivationEnd{constructor(snapshot){this.snapshot=snapshot,this.type=14}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Scroll{constructor(routerEvent,position,anchor){this.routerEvent=routerEvent,this.position=position,this.anchor=anchor,this.type=15}toString(){const pos=this.position?`${this.position[0]}, ${this.position[1]}`:null;return`Scroll(anchor: '${this.anchor}', position: '${pos}')`}}class OutletContext{constructor(){this.outlet=null,this.route=null,this.injector=null,this.children=new ChildrenOutletContexts,this.attachRef=null}}class ChildrenOutletContexts{constructor(){this.contexts=new Map}onChildOutletCreated(childName,outlet){const context=this.getOrCreateContext(childName);context.outlet=outlet,this.contexts.set(childName,context)}onChildOutletDestroyed(childName){const context=this.getContext(childName);context&&(context.outlet=null,context.attachRef=null)}onOutletDeactivated(){const contexts=this.contexts;return this.contexts=new Map,contexts}onOutletReAttached(contexts){this.contexts=contexts}getOrCreateContext(childName){let context=this.getContext(childName);return context||(context=new OutletContext,this.contexts.set(childName,context)),context}getContext(childName){return this.contexts.get(childName)||null}static#_=this.ɵfac=function ChildrenOutletContexts_Factory(t){return new(t||ChildrenOutletContexts)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:ChildrenOutletContexts,factory:ChildrenOutletContexts.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](ChildrenOutletContexts,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class Tree{constructor(root){this._root=root}get root(){return this._root.value}parent(t){const p=this.pathFromRoot(t);return p.length>1?p[p.length-2]:null}children(t){const n=findNode(t,this._root);return n?n.children.map((t=>t.value)):[]}firstChild(t){const n=findNode(t,this._root);return n&&n.children.length>0?n.children[0].value:null}siblings(t){const p=findPath(t,this._root);if(p.length<2)return[];return p[p.length-2].children.map((c=>c.value)).filter((cc=>cc!==t))}pathFromRoot(t){return findPath(t,this._root).map((s=>s.value))}}function findNode(value,node){if(value===node.value)return node;for(const child of node.children){const node=findNode(value,child);if(node)return node}return null}function findPath(value,node){if(value===node.value)return[node];for(const child of node.children){const path=findPath(value,child);if(path.length)return path.unshift(node),path}return[]}class TreeNode{constructor(value,children){this.value=value,this.children=children}toString(){return`TreeNode(${this.value})`}}function nodeChildrenAsMap(node){const map={};return node&&node.children.forEach((child=>map[child.value.outlet]=child)),map}class RouterState extends Tree{constructor(root,snapshot){super(root),this.snapshot=snapshot,setRouterState(this,root)}toString(){return this.snapshot.toString()}}function createEmptyState(urlTree,rootComponent){const snapshot=function createEmptyStateSnapshot(urlTree,rootComponent){const emptyParams={},emptyData={},emptyQueryParams={},fragment="",activated=new ActivatedRouteSnapshot([],emptyParams,emptyQueryParams,fragment,emptyData,PRIMARY_OUTLET,rootComponent,null,{});return new RouterStateSnapshot("",new TreeNode(activated,[]))}(0,rootComponent),emptyUrl=new BehaviorSubject.X([new UrlSegment("",{})]),emptyParams=new BehaviorSubject.X({}),emptyData=new BehaviorSubject.X({}),emptyQueryParams=new BehaviorSubject.X({}),fragment=new BehaviorSubject.X(""),activated=new ActivatedRoute(emptyUrl,emptyParams,emptyQueryParams,fragment,emptyData,PRIMARY_OUTLET,rootComponent,snapshot.root);return activated.snapshot=snapshot.root,new RouterState(new TreeNode(activated,[]),snapshot)}class ActivatedRoute{constructor(urlSubject,paramsSubject,queryParamsSubject,fragmentSubject,dataSubject,outlet,component,futureSnapshot){this.urlSubject=urlSubject,this.paramsSubject=paramsSubject,this.queryParamsSubject=queryParamsSubject,this.fragmentSubject=fragmentSubject,this.dataSubject=dataSubject,this.outlet=outlet,this.component=component,this._futureSnapshot=futureSnapshot,this.title=this.dataSubject?.pipe((0,map.U)((d=>d[RouteTitleKey])))??(0,of.of)(void 0),this.url=urlSubject,this.params=paramsSubject,this.queryParams=queryParamsSubject,this.fragment=fragmentSubject,this.data=dataSubject}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe((0,map.U)((p=>convertToParamMap(p))))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe((0,map.U)((p=>convertToParamMap(p))))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function inheritedParamsDataResolve(route,paramsInheritanceStrategy="emptyOnly"){const pathFromRoot=route.pathFromRoot;let inheritingStartingFrom=0;if("always"!==paramsInheritanceStrategy)for(inheritingStartingFrom=pathFromRoot.length-1;inheritingStartingFrom>=1;){const current=pathFromRoot[inheritingStartingFrom],parent=pathFromRoot[inheritingStartingFrom-1];if(current.routeConfig&&""===current.routeConfig.path)inheritingStartingFrom--;else{if(parent.component)break;inheritingStartingFrom--}}return function flattenInherited(pathFromRoot){return pathFromRoot.reduce(((res,curr)=>({params:{...res.params,...curr.params},data:{...res.data,...curr.data},resolve:{...curr.data,...res.resolve,...curr.routeConfig?.data,...curr._resolvedData}})),{params:{},data:{},resolve:{}})}(pathFromRoot.slice(inheritingStartingFrom))}class ActivatedRouteSnapshot{get title(){return this.data?.[RouteTitleKey]}constructor(url,params,queryParams,fragment,data,outlet,component,routeConfig,resolve){this.url=url,this.params=params,this.queryParams=queryParams,this.fragment=fragment,this.data=data,this.outlet=outlet,this.component=component,this.routeConfig=routeConfig,this._resolve=resolve}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=convertToParamMap(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=convertToParamMap(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map((segment=>segment.toString())).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class RouterStateSnapshot extends Tree{constructor(url,root){super(root),this.url=url,setRouterState(this,root)}toString(){return serializeNode(this._root)}}function setRouterState(state,node){node.value._routerState=state,node.children.forEach((c=>setRouterState(state,c)))}function serializeNode(node){const c=node.children.length>0?` { ${node.children.map(serializeNode).join(", ")} } `:"";return`${node.value}${c}`}function advanceActivatedRoute(route){if(route.snapshot){const currentSnapshot=route.snapshot,nextSnapshot=route._futureSnapshot;route.snapshot=nextSnapshot,shallowEqual(currentSnapshot.queryParams,nextSnapshot.queryParams)||route.queryParamsSubject.next(nextSnapshot.queryParams),currentSnapshot.fragment!==nextSnapshot.fragment&&route.fragmentSubject.next(nextSnapshot.fragment),shallowEqual(currentSnapshot.params,nextSnapshot.params)||route.paramsSubject.next(nextSnapshot.params),function shallowEqualArrays(a,b){if(a.length!==b.length)return!1;for(let i=0;i<a.length;++i)if(!shallowEqual(a[i],b[i]))return!1;return!0}(currentSnapshot.url,nextSnapshot.url)||route.urlSubject.next(nextSnapshot.url),shallowEqual(currentSnapshot.data,nextSnapshot.data)||route.dataSubject.next(nextSnapshot.data)}else route.snapshot=route._futureSnapshot,route.dataSubject.next(route._futureSnapshot.data)}function equalParamsAndUrlSegments(a,b){const equalUrlParams=shallowEqual(a.params,b.params)&&function equalSegments(as,bs){return equalPath(as,bs)&&as.every(((a,i)=>shallowEqual(a.parameters,bs[i].parameters)))}(a.url,b.url),parentsMismatch=!a.parent!=!b.parent;return equalUrlParams&&!parentsMismatch&&(!a.parent||equalParamsAndUrlSegments(a.parent,b.parent))}class RouterOutlet{constructor(){this.activated=null,this._activatedRoute=null,this.name=PRIMARY_OUTLET,this.activateEvents=new core.EventEmitter,this.deactivateEvents=new core.EventEmitter,this.attachEvents=new core.EventEmitter,this.detachEvents=new core.EventEmitter,this.parentContexts=(0,core.inject)(ChildrenOutletContexts),this.location=(0,core.inject)(core.ViewContainerRef),this.changeDetector=(0,core.inject)(core.ChangeDetectorRef),this.environmentInjector=(0,core.inject)(core.EnvironmentInjector),this.inputBinder=(0,core.inject)(INPUT_BINDER,{optional:!0}),this.supportsBindingToComponentInputs=!0}get activatedComponentRef(){return this.activated}ngOnChanges(changes){if(changes.name){const{firstChange,previousValue}=changes.name;if(firstChange)return;this.isTrackedInParentContexts(previousValue)&&(this.deactivate(),this.parentContexts.onChildOutletDestroyed(previousValue)),this.initializeOutletWithName()}}ngOnDestroy(){this.isTrackedInParentContexts(this.name)&&this.parentContexts.onChildOutletDestroyed(this.name),this.inputBinder?.unsubscribeFromRouteData(this)}isTrackedInParentContexts(outletName){return this.parentContexts.getContext(outletName)?.outlet===this}ngOnInit(){this.initializeOutletWithName()}initializeOutletWithName(){if(this.parentContexts.onChildOutletCreated(this.name,this),this.activated)return;const context=this.parentContexts.getContext(this.name);context?.route&&(context.attachRef?this.attach(context.attachRef,context.route):this.activateWith(context.route,context.injector))}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new core["ɵRuntimeError"](4012,("undefined"==typeof ngDevMode||ngDevMode)&&"Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new core["ɵRuntimeError"](4012,("undefined"==typeof ngDevMode||ngDevMode)&&"Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new core["ɵRuntimeError"](4012,("undefined"==typeof ngDevMode||ngDevMode)&&"Outlet is not activated");this.location.detach();const cmp=this.activated;return this.activated=null,this._activatedRoute=null,this.detachEvents.emit(cmp.instance),cmp}attach(ref,activatedRoute){this.activated=ref,this._activatedRoute=activatedRoute,this.location.insert(ref.hostView),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.attachEvents.emit(ref.instance)}deactivate(){if(this.activated){const c=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(c)}}activateWith(activatedRoute,environmentInjector){if(this.isActivated)throw new core["ɵRuntimeError"](4013,("undefined"==typeof ngDevMode||ngDevMode)&&"Cannot activate an already activated outlet");this._activatedRoute=activatedRoute;const location=this.location,component=activatedRoute.snapshot.component,childContexts=this.parentContexts.getOrCreateContext(this.name).children,injector=new OutletInjector(activatedRoute,childContexts,location.injector);this.activated=location.createComponent(component,{index:location.length,injector,environmentInjector:environmentInjector??this.environmentInjector}),this.changeDetector.markForCheck(),this.inputBinder?.bindActivatedRouteToOutletComponent(this),this.activateEvents.emit(this.activated.instance)}static#_=this.ɵfac=function RouterOutlet_Factory(t){return new(t||RouterOutlet)};static#_2=this.ɵdir=core["ɵɵdefineDirective"]({type:RouterOutlet,selectors:[["router-outlet"]],inputs:{name:"name"},outputs:{activateEvents:"activate",deactivateEvents:"deactivate",attachEvents:"attach",detachEvents:"detach"},exportAs:["outlet"],standalone:!0,features:[core["ɵɵNgOnChangesFeature"]]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterOutlet,[{type:core.Directive,args:[{selector:"router-outlet",exportAs:"outlet",standalone:!0}]}],null,{name:[{type:core.Input}],activateEvents:[{type:core.Output,args:["activate"]}],deactivateEvents:[{type:core.Output,args:["deactivate"]}],attachEvents:[{type:core.Output,args:["attach"]}],detachEvents:[{type:core.Output,args:["detach"]}]});class OutletInjector{constructor(route,childContexts,parent){this.route=route,this.childContexts=childContexts,this.parent=parent}get(token,notFoundValue){return token===ActivatedRoute?this.route:token===ChildrenOutletContexts?this.childContexts:this.parent.get(token,notFoundValue)}}const INPUT_BINDER=new core.InjectionToken("");class RoutedComponentInputBinder{constructor(){this.outletDataSubscriptions=new Map}bindActivatedRouteToOutletComponent(outlet){this.unsubscribeFromRouteData(outlet),this.subscribeToRouteData(outlet)}unsubscribeFromRouteData(outlet){this.outletDataSubscriptions.get(outlet)?.unsubscribe(),this.outletDataSubscriptions.delete(outlet)}subscribeToRouteData(outlet){const{activatedRoute}=outlet,dataSubscription=(0,combineLatest.a)([activatedRoute.queryParams,activatedRoute.params,activatedRoute.data]).pipe((0,switchMap.w)((([queryParams,params,data],index)=>(data={...queryParams,...params,...data},0===index?(0,of.of)(data):Promise.resolve(data))))).subscribe((data=>{if(!outlet.isActivated||!outlet.activatedComponentRef||outlet.activatedRoute!==activatedRoute||null===activatedRoute.component)return void this.unsubscribeFromRouteData(outlet);const mirror=(0,core.reflectComponentType)(activatedRoute.component);if(mirror)for(const{templateName}of mirror.inputs)outlet.activatedComponentRef.setInput(templateName,data[templateName]);else this.unsubscribeFromRouteData(outlet)}));this.outletDataSubscriptions.set(outlet,dataSubscription)}static#_=this.ɵfac=function RoutedComponentInputBinder_Factory(t){return new(t||RoutedComponentInputBinder)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RoutedComponentInputBinder,factory:RoutedComponentInputBinder.ɵfac})}function createNode(routeReuseStrategy,curr,prevState){if(prevState&&routeReuseStrategy.shouldReuseRoute(curr.value,prevState.value.snapshot)){const value=prevState.value;value._futureSnapshot=curr.value;const children=function createOrReuseChildren(routeReuseStrategy,curr,prevState){return curr.children.map((child=>{for(const p of prevState.children)if(routeReuseStrategy.shouldReuseRoute(child.value,p.value.snapshot))return createNode(routeReuseStrategy,child,p);return createNode(routeReuseStrategy,child)}))}(routeReuseStrategy,curr,prevState);return new TreeNode(value,children)}{if(routeReuseStrategy.shouldAttach(curr.value)){const detachedRouteHandle=routeReuseStrategy.retrieve(curr.value);if(null!==detachedRouteHandle){const tree=detachedRouteHandle.route;return tree.value._futureSnapshot=curr.value,tree.children=curr.children.map((c=>createNode(routeReuseStrategy,c))),tree}}const value=function createActivatedRoute(c){return new ActivatedRoute(new BehaviorSubject.X(c.url),new BehaviorSubject.X(c.params),new BehaviorSubject.X(c.queryParams),new BehaviorSubject.X(c.fragment),new BehaviorSubject.X(c.data),c.outlet,c.component,c)}(curr.value),children=curr.children.map((c=>createNode(routeReuseStrategy,c)));return new TreeNode(value,children)}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RoutedComponentInputBinder,[{type:core.Injectable}],null,null);const NAVIGATION_CANCELING_ERROR="ngNavigationCancelingError";function redirectingNavigationError(urlSerializer,redirect){const{redirectTo,navigationBehaviorOptions}=isUrlTree(redirect)?{redirectTo:redirect,navigationBehaviorOptions:void 0}:redirect,error=navigationCancelingError(ngDevMode&&`Redirecting to "${urlSerializer.serialize(redirectTo)}"`,0,redirect);return error.url=redirectTo,error.navigationBehaviorOptions=navigationBehaviorOptions,error}function navigationCancelingError(message,code,redirectUrl){const error=new Error("NavigationCancelingError: "+(message||""));return error[NAVIGATION_CANCELING_ERROR]=!0,error.cancellationCode=code,redirectUrl&&(error.url=redirectUrl),error}function isRedirectingNavigationCancelingError$1(error){return isNavigationCancelingError$1(error)&&isUrlTree(error.url)}function isNavigationCancelingError$1(error){return error&&error[NAVIGATION_CANCELING_ERROR]}class ɵEmptyOutletComponent{static#_=this.ɵfac=function ɵEmptyOutletComponent_Factory(t){return new(t||ɵEmptyOutletComponent)};static#_2=this.ɵcmp=core["ɵɵdefineComponent"]({type:ɵEmptyOutletComponent,selectors:[["ng-component"]],standalone:!0,features:[core["ɵɵStandaloneFeature"]],decls:1,vars:0,template:function ɵEmptyOutletComponent_Template(rf,ctx){1&rf&&core["ɵɵelement"](0,"router-outlet")},dependencies:[RouterOutlet],encapsulation:2})}function validateConfig(config,parentPath="",requireStandaloneComponents=!1){for(let i=0;i<config.length;i++){const route=config[i];validateNode(route,getFullPath(parentPath,route),requireStandaloneComponents)}}function assertStandalone(fullPath,component){if(component&&(0,core["ɵisNgModule"])(component))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);if(component&&!(0,core.isStandalone)(component))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}'. The component must be standalone.`)}function validateNode(route,fullPath,requireStandaloneComponents){if("undefined"==typeof ngDevMode||ngDevMode){if(!route)throw new core["ɵRuntimeError"](4014,`\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);if(Array.isArray(route))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': Array cannot be specified`);if(!route.redirectTo&&!route.component&&!route.loadComponent&&!route.children&&!route.loadChildren&&route.outlet&&route.outlet!==PRIMARY_OUTLET)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);if(route.redirectTo&&route.children)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);if(route.redirectTo&&route.loadChildren)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);if(route.children&&route.loadChildren)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);if(route.redirectTo&&(route.component||route.loadComponent))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);if(route.component&&route.loadComponent)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);if(route.redirectTo&&route.canActivate)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);if(route.path&&route.matcher)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);if(!(void 0!==route.redirectTo||route.component||route.loadComponent||route.children||route.loadChildren))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);if(void 0===route.path&&void 0===route.matcher)throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);if("string"==typeof route.path&&"/"===route.path.charAt(0))throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '${fullPath}': path cannot start with a slash`);if(""===route.path&&void 0!==route.redirectTo&&void 0===route.pathMatch){const exp="The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";throw new core["ɵRuntimeError"](4014,`Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`)}requireStandaloneComponents&&assertStandalone(fullPath,route.component)}route.children&&validateConfig(route.children,fullPath,requireStandaloneComponents)}function getFullPath(parentPath,currentRoute){return currentRoute?parentPath||currentRoute.path?parentPath&&!currentRoute.path?`${parentPath}/`:!parentPath&&currentRoute.path?currentRoute.path:`${parentPath}/${currentRoute.path}`:"":parentPath}function standardizeConfig(r){const children=r.children&&r.children.map(standardizeConfig),c=children?{...r,children}:{...r};return c.component||c.loadComponent||!children&&!c.loadChildren||!c.outlet||c.outlet===PRIMARY_OUTLET||(c.component=ɵEmptyOutletComponent),c}function getOutlet(route){return route.outlet||PRIMARY_OUTLET}function getClosestRouteInjector(snapshot){if(!snapshot)return null;if(snapshot.routeConfig?._injector)return snapshot.routeConfig._injector;for(let s=snapshot.parent;s;s=s.parent){const route=s.routeConfig;if(route?._loadedInjector)return route._loadedInjector;if(route?._injector)return route._injector}return null}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](ɵEmptyOutletComponent,[{type:core.Component,args:[{template:"<router-outlet></router-outlet>",imports:[RouterOutlet],standalone:!0}]}],null,null);let warnedAboutUnsupportedInputBinding=!1;class ActivateRoutes{constructor(routeReuseStrategy,futureState,currState,forwardEvent,inputBindingEnabled){this.routeReuseStrategy=routeReuseStrategy,this.futureState=futureState,this.currState=currState,this.forwardEvent=forwardEvent,this.inputBindingEnabled=inputBindingEnabled}activate(parentContexts){const futureRoot=this.futureState._root,currRoot=this.currState?this.currState._root:null;this.deactivateChildRoutes(futureRoot,currRoot,parentContexts),advanceActivatedRoute(this.futureState.root),this.activateChildRoutes(futureRoot,currRoot,parentContexts)}deactivateChildRoutes(futureNode,currNode,contexts){const children=nodeChildrenAsMap(currNode);futureNode.children.forEach((futureChild=>{const childOutletName=futureChild.value.outlet;this.deactivateRoutes(futureChild,children[childOutletName],contexts),delete children[childOutletName]})),Object.values(children).forEach((v=>{this.deactivateRouteAndItsChildren(v,contexts)}))}deactivateRoutes(futureNode,currNode,parentContext){const future=futureNode.value,curr=currNode?currNode.value:null;if(future===curr)if(future.component){const context=parentContext.getContext(future.outlet);context&&this.deactivateChildRoutes(futureNode,currNode,context.children)}else this.deactivateChildRoutes(futureNode,currNode,parentContext);else curr&&this.deactivateRouteAndItsChildren(currNode,parentContext)}deactivateRouteAndItsChildren(route,parentContexts){route.value.component&&this.routeReuseStrategy.shouldDetach(route.value.snapshot)?this.detachAndStoreRouteSubtree(route,parentContexts):this.deactivateRouteAndOutlet(route,parentContexts)}detachAndStoreRouteSubtree(route,parentContexts){const context=parentContexts.getContext(route.value.outlet),contexts=context&&route.value.component?context.children:parentContexts,children=nodeChildrenAsMap(route);for(const childOutlet of Object.keys(children))this.deactivateRouteAndItsChildren(children[childOutlet],contexts);if(context&&context.outlet){const componentRef=context.outlet.detach(),contexts=context.children.onOutletDeactivated();this.routeReuseStrategy.store(route.value.snapshot,{componentRef,route,contexts})}}deactivateRouteAndOutlet(route,parentContexts){const context=parentContexts.getContext(route.value.outlet),contexts=context&&route.value.component?context.children:parentContexts,children=nodeChildrenAsMap(route);for(const childOutlet of Object.keys(children))this.deactivateRouteAndItsChildren(children[childOutlet],contexts);context&&(context.outlet&&(context.outlet.deactivate(),context.children.onOutletDeactivated()),context.attachRef=null,context.route=null)}activateChildRoutes(futureNode,currNode,contexts){const children=nodeChildrenAsMap(currNode);futureNode.children.forEach((c=>{this.activateRoutes(c,children[c.value.outlet],contexts),this.forwardEvent(new ActivationEnd(c.value.snapshot))})),futureNode.children.length&&this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot))}activateRoutes(futureNode,currNode,parentContexts){const future=futureNode.value,curr=currNode?currNode.value:null;if(advanceActivatedRoute(future),future===curr)if(future.component){const context=parentContexts.getOrCreateContext(future.outlet);this.activateChildRoutes(futureNode,currNode,context.children)}else this.activateChildRoutes(futureNode,currNode,parentContexts);else if(future.component){const context=parentContexts.getOrCreateContext(future.outlet);if(this.routeReuseStrategy.shouldAttach(future.snapshot)){const stored=this.routeReuseStrategy.retrieve(future.snapshot);this.routeReuseStrategy.store(future.snapshot,null),context.children.onOutletReAttached(stored.contexts),context.attachRef=stored.componentRef,context.route=stored.route.value,context.outlet&&context.outlet.attach(stored.componentRef,stored.route.value),advanceActivatedRoute(stored.route.value),this.activateChildRoutes(futureNode,null,context.children)}else{const injector=getClosestRouteInjector(future.snapshot);context.attachRef=null,context.route=future,context.injector=injector,context.outlet&&context.outlet.activateWith(future,context.injector),this.activateChildRoutes(futureNode,null,context.children)}}else this.activateChildRoutes(futureNode,null,parentContexts);if("undefined"==typeof ngDevMode||ngDevMode){const outlet=parentContexts.getOrCreateContext(future.outlet).outlet;outlet&&this.inputBindingEnabled&&!outlet.supportsBindingToComponentInputs&&!warnedAboutUnsupportedInputBinding&&(console.warn("'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs."),warnedAboutUnsupportedInputBinding=!0)}}}class CanActivate{constructor(path){this.path=path,this.route=this.path[this.path.length-1]}}class CanDeactivate{constructor(component,route){this.component=component,this.route=route}}function getAllRouteGuards(future,curr,parentContexts){const futureRoot=future._root;return getChildRouteGuards(futureRoot,curr?curr._root:null,parentContexts,[futureRoot.value])}function getTokenOrFunctionIdentity(tokenOrFunction,injector){const NOT_FOUND=Symbol(),result=injector.get(tokenOrFunction,NOT_FOUND);return result===NOT_FOUND?"function"!=typeof tokenOrFunction||(0,core["ɵisInjectable"])(tokenOrFunction)?injector.get(tokenOrFunction):tokenOrFunction:result}function getChildRouteGuards(futureNode,currNode,contexts,futurePath,checks={canDeactivateChecks:[],canActivateChecks:[]}){const prevChildren=nodeChildrenAsMap(currNode);return futureNode.children.forEach((c=>{!function getRouteGuards(futureNode,currNode,parentContexts,futurePath,checks={canDeactivateChecks:[],canActivateChecks:[]}){const future=futureNode.value,curr=currNode?currNode.value:null,context=parentContexts?parentContexts.getContext(futureNode.value.outlet):null;if(curr&&future.routeConfig===curr.routeConfig){const shouldRun=function shouldRunGuardsAndResolvers(curr,future,mode){if("function"==typeof mode)return mode(curr,future);switch(mode){case"pathParamsChange":return!equalPath(curr.url,future.url);case"pathParamsOrQueryParamsChange":return!equalPath(curr.url,future.url)||!shallowEqual(curr.queryParams,future.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!equalParamsAndUrlSegments(curr,future)||!shallowEqual(curr.queryParams,future.queryParams);default:return!equalParamsAndUrlSegments(curr,future)}}(curr,future,future.routeConfig.runGuardsAndResolvers);shouldRun?checks.canActivateChecks.push(new CanActivate(futurePath)):(future.data=curr.data,future._resolvedData=curr._resolvedData),future.component?getChildRouteGuards(futureNode,currNode,context?context.children:null,futurePath,checks):getChildRouteGuards(futureNode,currNode,parentContexts,futurePath,checks),shouldRun&&context&&context.outlet&&context.outlet.isActivated&&checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component,curr))}else curr&&deactivateRouteAndItsChildren(currNode,context,checks),checks.canActivateChecks.push(new CanActivate(futurePath)),future.component?getChildRouteGuards(futureNode,null,context?context.children:null,futurePath,checks):getChildRouteGuards(futureNode,null,parentContexts,futurePath,checks);return checks}(c,prevChildren[c.value.outlet],contexts,futurePath.concat([c.value]),checks),delete prevChildren[c.value.outlet]})),Object.entries(prevChildren).forEach((([k,v])=>deactivateRouteAndItsChildren(v,contexts.getContext(k),checks))),checks}function deactivateRouteAndItsChildren(route,context,checks){const children=nodeChildrenAsMap(route),r=route.value;Object.entries(children).forEach((([childName,node])=>{r.component?deactivateRouteAndItsChildren(node,context?context.children.getContext(childName):null,checks):deactivateRouteAndItsChildren(node,context,checks)})),r.component&&context&&context.outlet&&context.outlet.isActivated?checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component,r)):checks.canDeactivateChecks.push(new CanDeactivate(null,r))}function isFunction(v){return"function"==typeof v}function isEmptyError(e){return e instanceof EmptyError.K||"EmptyError"===e?.name}const INITIAL_VALUE=Symbol("INITIAL_VALUE");function prioritizedGuardValue(){return(0,switchMap.w)((obs=>(0,combineLatest.a)(obs.map((o=>o.pipe((0,take.q)(1),(0,startWith.O)(INITIAL_VALUE))))).pipe((0,map.U)((results=>{for(const result of results)if(!0!==result){if(result===INITIAL_VALUE)return INITIAL_VALUE;if(!1===result||result instanceof UrlTree)return result}return!0})),(0,filter.h)((item=>item!==INITIAL_VALUE)),(0,take.q)(1))))}function checkGuards(injector,forwardEvent){return(0,mergeMap.z)((t=>{const{targetSnapshot,currentSnapshot,guards:{canActivateChecks,canDeactivateChecks}}=t;return 0===canDeactivateChecks.length&&0===canActivateChecks.length?(0,of.of)({...t,guardsResult:!0}):function runCanDeactivateChecks(checks,futureRSS,currRSS,injector){return(0,from.D)(checks).pipe((0,mergeMap.z)((check=>function runCanDeactivate(component,currARS,currRSS,futureRSS,injector){const canDeactivate=currARS&&currARS.routeConfig?currARS.routeConfig.canDeactivate:null;if(!canDeactivate||0===canDeactivate.length)return(0,of.of)(!0);const canDeactivateObservables=canDeactivate.map((c=>{const closestInjector=getClosestRouteInjector(currARS)??injector,guard=getTokenOrFunctionIdentity(c,closestInjector);return wrapIntoObservable(function isCanDeactivate(guard){return guard&&isFunction(guard.canDeactivate)}(guard)?guard.canDeactivate(component,currARS,currRSS,futureRSS):closestInjector.runInContext((()=>guard(component,currARS,currRSS,futureRSS)))).pipe((0,first.P)())}));return(0,of.of)(canDeactivateObservables).pipe(prioritizedGuardValue())}(check.component,check.route,currRSS,futureRSS,injector))),(0,first.P)((result=>!0!==result),!0))}(canDeactivateChecks,targetSnapshot,currentSnapshot,injector).pipe((0,mergeMap.z)((canDeactivate=>canDeactivate&&function isBoolean(v){return"boolean"==typeof v}(canDeactivate)?function runCanActivateChecks(futureSnapshot,checks,injector,forwardEvent){return(0,from.D)(checks).pipe((0,concatMap.b)((check=>(0,concat.z)(function fireChildActivationStart(snapshot,forwardEvent){null!==snapshot&&forwardEvent&&forwardEvent(new ChildActivationStart(snapshot));return(0,of.of)(!0)}(check.route.parent,forwardEvent),function fireActivationStart(snapshot,forwardEvent){null!==snapshot&&forwardEvent&&forwardEvent(new ActivationStart(snapshot));return(0,of.of)(!0)}(check.route,forwardEvent),function runCanActivateChild(futureRSS,path,injector){const futureARS=path[path.length-1],canActivateChildGuardsMapped=path.slice(0,path.length-1).reverse().map((p=>function getCanActivateChild(p){const canActivateChild=p.routeConfig?p.routeConfig.canActivateChild:null;return canActivateChild&&0!==canActivateChild.length?{node:p,guards:canActivateChild}:null}(p))).filter((_=>null!==_)).map((d=>(0,defer.P)((()=>{const guardsMapped=d.guards.map((canActivateChild=>{const closestInjector=getClosestRouteInjector(d.node)??injector,guard=getTokenOrFunctionIdentity(canActivateChild,closestInjector);return wrapIntoObservable(function isCanActivateChild(guard){return guard&&isFunction(guard.canActivateChild)}(guard)?guard.canActivateChild(futureARS,futureRSS):closestInjector.runInContext((()=>guard(futureARS,futureRSS)))).pipe((0,first.P)())}));return(0,of.of)(guardsMapped).pipe(prioritizedGuardValue())}))));return(0,of.of)(canActivateChildGuardsMapped).pipe(prioritizedGuardValue())}(futureSnapshot,check.path,injector),function runCanActivate(futureRSS,futureARS,injector){const canActivate=futureARS.routeConfig?futureARS.routeConfig.canActivate:null;if(!canActivate||0===canActivate.length)return(0,of.of)(!0);const canActivateObservables=canActivate.map((canActivate=>(0,defer.P)((()=>{const closestInjector=getClosestRouteInjector(futureARS)??injector,guard=getTokenOrFunctionIdentity(canActivate,closestInjector);return wrapIntoObservable(function isCanActivate(guard){return guard&&isFunction(guard.canActivate)}(guard)?guard.canActivate(futureARS,futureRSS):closestInjector.runInContext((()=>guard(futureARS,futureRSS)))).pipe((0,first.P)())}))));return(0,of.of)(canActivateObservables).pipe(prioritizedGuardValue())}(futureSnapshot,check.route,injector)))),(0,first.P)((result=>!0!==result),!0))}(targetSnapshot,canActivateChecks,injector,forwardEvent):(0,of.of)(canDeactivate))),(0,map.U)((guardsResult=>({...t,guardsResult}))))}))}function runCanLoadGuards(injector,route,segments,urlSerializer){const canLoad=route.canLoad;if(void 0===canLoad||0===canLoad.length)return(0,of.of)(!0);const canLoadObservables=canLoad.map((injectionToken=>{const guard=getTokenOrFunctionIdentity(injectionToken,injector);return wrapIntoObservable(function isCanLoad(guard){return guard&&isFunction(guard.canLoad)}(guard)?guard.canLoad(route,segments):injector.runInContext((()=>guard(route,segments))))}));return(0,of.of)(canLoadObservables).pipe(prioritizedGuardValue(),redirectIfUrlTree(urlSerializer))}function redirectIfUrlTree(urlSerializer){return(0,pipe.z)((0,tap.b)((result=>{if(isUrlTree(result))throw redirectingNavigationError(urlSerializer,result)})),(0,map.U)((result=>!0===result)))}function runCanMatchGuards(injector,route,segments,urlSerializer){const canMatch=route.canMatch;if(!canMatch||0===canMatch.length)return(0,of.of)(!0);const canMatchObservables=canMatch.map((injectionToken=>{const guard=getTokenOrFunctionIdentity(injectionToken,injector);return wrapIntoObservable(function isCanMatch(guard){return guard&&isFunction(guard.canMatch)}(guard)?guard.canMatch(route,segments):injector.runInContext((()=>guard(route,segments))))}));return(0,of.of)(canMatchObservables).pipe(prioritizedGuardValue(),redirectIfUrlTree(urlSerializer))}class NoMatch{constructor(segmentGroup){this.segmentGroup=segmentGroup||null}}class AbsoluteRedirect{constructor(urlTree){this.urlTree=urlTree}}function noMatch$1(segmentGroup){return(0,throwError._)(new NoMatch(segmentGroup))}function absoluteRedirect(newTree){return(0,throwError._)(new AbsoluteRedirect(newTree))}class ApplyRedirects{constructor(urlSerializer,urlTree){this.urlSerializer=urlSerializer,this.urlTree=urlTree}noMatchError(e){return new core["ɵRuntimeError"](4002,("undefined"==typeof ngDevMode||ngDevMode)&&`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}lineralizeSegments(route,urlTree){let res=[],c=urlTree.root;for(;;){if(res=res.concat(c.segments),0===c.numberOfChildren)return(0,of.of)(res);if(c.numberOfChildren>1||!c.children[PRIMARY_OUTLET])return redirectTo=route.redirectTo,(0,throwError._)(new core["ɵRuntimeError"](4e3,("undefined"==typeof ngDevMode||ngDevMode)&&`Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));c=c.children[PRIMARY_OUTLET]}var redirectTo}applyRedirectCommands(segments,redirectTo,posParams){return this.applyRedirectCreateUrlTree(redirectTo,this.urlSerializer.parse(redirectTo),segments,posParams)}applyRedirectCreateUrlTree(redirectTo,urlTree,segments,posParams){const newRoot=this.createSegmentGroup(redirectTo,urlTree.root,segments,posParams);return new UrlTree(newRoot,this.createQueryParams(urlTree.queryParams,this.urlTree.queryParams),urlTree.fragment)}createQueryParams(redirectToParams,actualParams){const res={};return Object.entries(redirectToParams).forEach((([k,v])=>{if("string"==typeof v&&v.startsWith(":")){const sourceName=v.substring(1);res[k]=actualParams[sourceName]}else res[k]=v})),res}createSegmentGroup(redirectTo,group,segments,posParams){const updatedSegments=this.createSegments(redirectTo,group.segments,segments,posParams);let children={};return Object.entries(group.children).forEach((([name,child])=>{children[name]=this.createSegmentGroup(redirectTo,child,segments,posParams)})),new UrlSegmentGroup(updatedSegments,children)}createSegments(redirectTo,redirectToSegments,actualSegments,posParams){return redirectToSegments.map((s=>s.path.startsWith(":")?this.findPosParam(redirectTo,s,posParams):this.findOrReturn(s,actualSegments)))}findPosParam(redirectTo,redirectToUrlSegment,posParams){const pos=posParams[redirectToUrlSegment.path.substring(1)];if(!pos)throw new core["ɵRuntimeError"](4001,("undefined"==typeof ngDevMode||ngDevMode)&&`Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);return pos}findOrReturn(redirectToUrlSegment,actualSegments){let idx=0;for(const s of actualSegments){if(s.path===redirectToUrlSegment.path)return actualSegments.splice(idx),s;idx++}return redirectToUrlSegment}}const noMatch={matched:!1,consumedSegments:[],remainingSegments:[],parameters:{},positionalParamSegments:{}};function matchWithChecks(segmentGroup,route,segments,injector,urlSerializer){const result=match(segmentGroup,route,segments);return result.matched?(injector=function getOrCreateRouteInjectorIfNeeded(route,currentInjector){return route.providers&&!route._injector&&(route._injector=(0,core.createEnvironmentInjector)(route.providers,currentInjector,`Route: ${route.path}`)),route._injector??currentInjector}(route,injector),runCanMatchGuards(injector,route,segments,urlSerializer).pipe((0,map.U)((v=>!0===v?result:{...noMatch})))):(0,of.of)(result)}function match(segmentGroup,route,segments){if(""===route.path)return"full"===route.pathMatch&&(segmentGroup.hasChildren()||segments.length>0)?{...noMatch}:{matched:!0,consumedSegments:[],remainingSegments:segments,parameters:{},positionalParamSegments:{}};const res=(route.matcher||defaultUrlMatcher)(segments,segmentGroup,route);if(!res)return{...noMatch};const posParams={};Object.entries(res.posParams??{}).forEach((([k,v])=>{posParams[k]=v.path}));const parameters=res.consumed.length>0?{...posParams,...res.consumed[res.consumed.length-1].parameters}:posParams;return{matched:!0,consumedSegments:res.consumed,remainingSegments:segments.slice(res.consumed.length),parameters,positionalParamSegments:res.posParams??{}}}function split(segmentGroup,consumedSegments,slicedSegments,config){if(slicedSegments.length>0&&function containsEmptyPathMatchesWithNamedOutlets(segmentGroup,slicedSegments,routes){return routes.some((r=>emptyPathMatch(segmentGroup,slicedSegments,r)&&getOutlet(r)!==PRIMARY_OUTLET))}(segmentGroup,slicedSegments,config)){return{segmentGroup:new UrlSegmentGroup(consumedSegments,function createChildrenForEmptyPaths(routes,primarySegment){const res={};res[PRIMARY_OUTLET]=primarySegment;for(const r of routes)if(""===r.path&&getOutlet(r)!==PRIMARY_OUTLET){const s=new UrlSegmentGroup([],{});res[getOutlet(r)]=s}return res}(config,new UrlSegmentGroup(slicedSegments,segmentGroup.children))),slicedSegments:[]}}if(0===slicedSegments.length&&function containsEmptyPathMatches(segmentGroup,slicedSegments,routes){return routes.some((r=>emptyPathMatch(segmentGroup,slicedSegments,r)))}(segmentGroup,slicedSegments,config)){const s=new UrlSegmentGroup(segmentGroup.segments,function addEmptyPathsToChildrenIfNeeded(segmentGroup,consumedSegments,slicedSegments,routes,children){const res={};for(const r of routes)if(emptyPathMatch(segmentGroup,slicedSegments,r)&&!children[getOutlet(r)]){const s=new UrlSegmentGroup([],{});res[getOutlet(r)]=s}return{...children,...res}}(segmentGroup,0,slicedSegments,config,segmentGroup.children));return{segmentGroup:s,slicedSegments}}return{segmentGroup:new UrlSegmentGroup(segmentGroup.segments,segmentGroup.children),slicedSegments}}function emptyPathMatch(segmentGroup,slicedSegments,r){return(!(segmentGroup.hasChildren()||slicedSegments.length>0)||"full"!==r.pathMatch)&&""===r.path}class Recognizer{constructor(injector,configLoader,rootComponentType,config,urlTree,paramsInheritanceStrategy,urlSerializer){this.injector=injector,this.configLoader=configLoader,this.rootComponentType=rootComponentType,this.config=config,this.urlTree=urlTree,this.paramsInheritanceStrategy=paramsInheritanceStrategy,this.urlSerializer=urlSerializer,this.allowRedirects=!0,this.applyRedirects=new ApplyRedirects(this.urlSerializer,this.urlTree)}noMatchError(e){return new core["ɵRuntimeError"](4002,("undefined"==typeof ngDevMode||ngDevMode)&&`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}recognize(){const rootSegmentGroup=split(this.urlTree.root,[],[],this.config).segmentGroup;return this.processSegmentGroup(this.injector,this.config,rootSegmentGroup,PRIMARY_OUTLET).pipe((0,catchError.K)((e=>{if(e instanceof AbsoluteRedirect)return this.allowRedirects=!1,this.urlTree=e.urlTree,this.match(e.urlTree);if(e instanceof NoMatch)throw this.noMatchError(e);throw e})),(0,map.U)((children=>{const root=new ActivatedRouteSnapshot([],Object.freeze({}),Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,{},PRIMARY_OUTLET,this.rootComponentType,null,{}),rootNode=new TreeNode(root,children),routeState=new RouterStateSnapshot("",rootNode),tree=function createUrlTreeFromSnapshot(relativeTo,commands,queryParams=null,fragment=null){return createUrlTreeFromSegmentGroup(createSegmentGroupFromRoute(relativeTo),commands,queryParams,fragment)}(root,[],this.urlTree.queryParams,this.urlTree.fragment);return tree.queryParams=this.urlTree.queryParams,routeState.url=this.urlSerializer.serialize(tree),this.inheritParamsAndData(routeState._root),{state:routeState,tree}})))}match(tree){return this.processSegmentGroup(this.injector,this.config,tree.root,PRIMARY_OUTLET).pipe((0,catchError.K)((e=>{if(e instanceof NoMatch)throw this.noMatchError(e);throw e})))}inheritParamsAndData(routeNode){const route=routeNode.value,i=inheritedParamsDataResolve(route,this.paramsInheritanceStrategy);route.params=Object.freeze(i.params),route.data=Object.freeze(i.data),routeNode.children.forEach((n=>this.inheritParamsAndData(n)))}processSegmentGroup(injector,config,segmentGroup,outlet){return 0===segmentGroup.segments.length&&segmentGroup.hasChildren()?this.processChildren(injector,config,segmentGroup):this.processSegment(injector,config,segmentGroup,segmentGroup.segments,outlet,!0)}processChildren(injector,config,segmentGroup){const childOutlets=[];for(const child of Object.keys(segmentGroup.children))"primary"===child?childOutlets.unshift(child):childOutlets.push(child);return(0,from.D)(childOutlets).pipe((0,concatMap.b)((childOutlet=>{const child=segmentGroup.children[childOutlet],sortedConfig=function sortByMatchingOutlets(routes,outletName){const sortedConfig=routes.filter((r=>getOutlet(r)===outletName));return sortedConfig.push(...routes.filter((r=>getOutlet(r)!==outletName))),sortedConfig}(config,childOutlet);return this.processSegmentGroup(injector,sortedConfig,child,childOutlet)})),scan(((children,outletChildren)=>(children.push(...outletChildren),children))),(0,defaultIfEmpty.d)(null),function last(predicate,defaultValue){var hasDefaultValue=arguments.length>=2;return function(source){return source.pipe(predicate?(0,filter.h)((function(v,i){return predicate(v,i,source)})):identity.y,takeLast(1),hasDefaultValue?(0,defaultIfEmpty.d)(defaultValue):(0,throwIfEmpty.T)((function(){return new EmptyError.K})))}}(),(0,mergeMap.z)((children=>{if(null===children)return noMatch$1(segmentGroup);const mergedChildren=mergeEmptyPathMatches(children);return("undefined"==typeof ngDevMode||ngDevMode)&&function checkOutletNameUniqueness(nodes){const names={};nodes.forEach((n=>{const routeWithSameOutletName=names[n.value.outlet];if(routeWithSameOutletName){const p=routeWithSameOutletName.url.map((s=>s.toString())).join("/"),c=n.value.url.map((s=>s.toString())).join("/");throw new core["ɵRuntimeError"](4006,("undefined"==typeof ngDevMode||ngDevMode)&&`Two segments cannot have the same outlet name: '${p}' and '${c}'.`)}names[n.value.outlet]=n.value}))}(mergedChildren),function sortActivatedRouteSnapshots(nodes){nodes.sort(((a,b)=>a.value.outlet===PRIMARY_OUTLET?-1:b.value.outlet===PRIMARY_OUTLET?1:a.value.outlet.localeCompare(b.value.outlet)))}(mergedChildren),(0,of.of)(mergedChildren)})))}processSegment(injector,routes,segmentGroup,segments,outlet,allowRedirects){return(0,from.D)(routes).pipe((0,concatMap.b)((r=>this.processSegmentAgainstRoute(r._injector??injector,routes,r,segmentGroup,segments,outlet,allowRedirects).pipe((0,catchError.K)((e=>{if(e instanceof NoMatch)return(0,of.of)(null);throw e}))))),(0,first.P)((x=>!!x)),(0,catchError.K)((e=>{if(isEmptyError(e))return function noLeftoversInUrl(segmentGroup,segments,outlet){return 0===segments.length&&!segmentGroup.children[outlet]}(segmentGroup,segments,outlet)?(0,of.of)([]):noMatch$1(segmentGroup);throw e})))}processSegmentAgainstRoute(injector,routes,route,rawSegment,segments,outlet,allowRedirects){return function isImmediateMatch(route,rawSegment,segments,outlet){return!!(getOutlet(route)===outlet||outlet!==PRIMARY_OUTLET&&emptyPathMatch(rawSegment,segments,route))&&("**"===route.path||match(rawSegment,route,segments).matched)}(route,rawSegment,segments,outlet)?void 0===route.redirectTo?this.matchSegmentAgainstRoute(injector,rawSegment,route,segments,outlet,allowRedirects):allowRedirects&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(injector,rawSegment,routes,route,segments,outlet):noMatch$1(rawSegment):noMatch$1(rawSegment)}expandSegmentAgainstRouteUsingRedirect(injector,segmentGroup,routes,route,segments,outlet){return"**"===route.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(injector,routes,route,outlet):this.expandRegularSegmentAgainstRouteUsingRedirect(injector,segmentGroup,routes,route,segments,outlet)}expandWildCardWithParamsAgainstRouteUsingRedirect(injector,routes,route,outlet){const newTree=this.applyRedirects.applyRedirectCommands([],route.redirectTo,{});return route.redirectTo.startsWith("/")?absoluteRedirect(newTree):this.applyRedirects.lineralizeSegments(route,newTree).pipe((0,mergeMap.z)((newSegments=>{const group=new UrlSegmentGroup(newSegments,{});return this.processSegment(injector,routes,group,newSegments,outlet,!1)})))}expandRegularSegmentAgainstRouteUsingRedirect(injector,segmentGroup,routes,route,segments,outlet){const{matched,consumedSegments,remainingSegments,positionalParamSegments}=match(segmentGroup,route,segments);if(!matched)return noMatch$1(segmentGroup);const newTree=this.applyRedirects.applyRedirectCommands(consumedSegments,route.redirectTo,positionalParamSegments);return route.redirectTo.startsWith("/")?absoluteRedirect(newTree):this.applyRedirects.lineralizeSegments(route,newTree).pipe((0,mergeMap.z)((newSegments=>this.processSegment(injector,routes,segmentGroup,newSegments.concat(remainingSegments),outlet,!1))))}matchSegmentAgainstRoute(injector,rawSegment,route,segments,outlet,allowRedirects){let matchResult;if("**"===route.path){const params=segments.length>0?router_last(segments).parameters:{},snapshot=new ActivatedRouteSnapshot(segments,params,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,getData(route),getOutlet(route),route.component??route._loadedComponent??null,route,getResolve(route));matchResult=(0,of.of)({snapshot,consumedSegments:[],remainingSegments:[]}),rawSegment.children={}}else matchResult=matchWithChecks(rawSegment,route,segments,injector,this.urlSerializer).pipe((0,map.U)((({matched,consumedSegments,remainingSegments,parameters})=>{if(!matched)return null;return{snapshot:new ActivatedRouteSnapshot(consumedSegments,parameters,Object.freeze({...this.urlTree.queryParams}),this.urlTree.fragment,getData(route),getOutlet(route),route.component??route._loadedComponent??null,route,getResolve(route)),consumedSegments,remainingSegments}})));return matchResult.pipe((0,switchMap.w)((result=>null===result?noMatch$1(rawSegment):(injector=route._injector??injector,this.getChildConfig(injector,route,segments).pipe((0,switchMap.w)((({routes:childConfig})=>{const childInjector=route._loadedInjector??injector,{snapshot,consumedSegments,remainingSegments}=result,{segmentGroup,slicedSegments}=split(rawSegment,consumedSegments,remainingSegments,childConfig);if(0===slicedSegments.length&&segmentGroup.hasChildren())return this.processChildren(childInjector,childConfig,segmentGroup).pipe((0,map.U)((children=>null===children?null:[new TreeNode(snapshot,children)])));if(0===childConfig.length&&0===slicedSegments.length)return(0,of.of)([new TreeNode(snapshot,[])]);const matchedOnOutlet=getOutlet(route)===outlet;return this.processSegment(childInjector,childConfig,segmentGroup,slicedSegments,matchedOnOutlet?PRIMARY_OUTLET:outlet,!0).pipe((0,map.U)((children=>[new TreeNode(snapshot,children)])))})))))))}getChildConfig(injector,route,segments){return route.children?(0,of.of)({routes:route.children,injector}):route.loadChildren?void 0!==route._loadedRoutes?(0,of.of)({routes:route._loadedRoutes,injector:route._loadedInjector}):runCanLoadGuards(injector,route,segments,this.urlSerializer).pipe((0,mergeMap.z)((shouldLoadResult=>shouldLoadResult?this.configLoader.loadChildren(injector,route).pipe((0,tap.b)((cfg=>{route._loadedRoutes=cfg.routes,route._loadedInjector=cfg.injector}))):function canLoadFails(route){return(0,throwError._)(navigationCancelingError(("undefined"==typeof ngDevMode||ngDevMode)&&`Cannot load children because the guard of the route "path: '${route.path}'" returned false`,3))}(route)))):(0,of.of)({routes:[],injector})}}function hasEmptyPathConfig(node){const config=node.value.routeConfig;return config&&""===config.path}function mergeEmptyPathMatches(nodes){const result=[],mergedNodes=new Set;for(const node of nodes){if(!hasEmptyPathConfig(node)){result.push(node);continue}const duplicateEmptyPathNode=result.find((resultNode=>node.value.routeConfig===resultNode.value.routeConfig));void 0!==duplicateEmptyPathNode?(duplicateEmptyPathNode.children.push(...node.children),mergedNodes.add(duplicateEmptyPathNode)):result.push(node)}for(const mergedNode of mergedNodes){const mergedChildren=mergeEmptyPathMatches(mergedNode.children);result.push(new TreeNode(mergedNode.value,mergedChildren))}return result.filter((n=>!mergedNodes.has(n)))}function getData(route){return route.data||{}}function getResolve(route){return route.resolve||{}}function recognize(injector,configLoader,rootComponentType,config,serializer,paramsInheritanceStrategy){return(0,mergeMap.z)((t=>function recognize$1(injector,configLoader,rootComponentType,config,urlTree,urlSerializer,paramsInheritanceStrategy="emptyOnly"){return new Recognizer(injector,configLoader,rootComponentType,config,urlTree,paramsInheritanceStrategy,urlSerializer).recognize()}(injector,configLoader,rootComponentType,config,t.extractedUrl,serializer,paramsInheritanceStrategy).pipe((0,map.U)((({state:targetSnapshot,tree:urlAfterRedirects})=>({...t,targetSnapshot,urlAfterRedirects}))))))}function resolveData(paramsInheritanceStrategy,injector){return(0,mergeMap.z)((t=>{const{targetSnapshot,guards:{canActivateChecks}}=t;if(!canActivateChecks.length)return(0,of.of)(t);let canActivateChecksResolved=0;return(0,from.D)(canActivateChecks).pipe((0,concatMap.b)((check=>function runResolve(futureARS,futureRSS,paramsInheritanceStrategy,injector){const config=futureARS.routeConfig,resolve=futureARS._resolve;void 0===config?.title||hasStaticTitle(config)||(resolve[RouteTitleKey]=config.title);return function resolveNode(resolve,futureARS,futureRSS,injector){const keys=function getDataKeys(obj){return[...Object.keys(obj),...Object.getOwnPropertySymbols(obj)]}(resolve);if(0===keys.length)return(0,of.of)({});const data={};return(0,from.D)(keys).pipe((0,mergeMap.z)((key=>function getResolver(injectionToken,futureARS,futureRSS,injector){const closestInjector=getClosestRouteInjector(futureARS)??injector,resolver=getTokenOrFunctionIdentity(injectionToken,closestInjector),resolverValue=resolver.resolve?resolver.resolve(futureARS,futureRSS):closestInjector.runInContext((()=>resolver(futureARS,futureRSS)));return wrapIntoObservable(resolverValue)}(resolve[key],futureARS,futureRSS,injector).pipe((0,first.P)(),(0,tap.b)((value=>{data[key]=value}))))),takeLast(1),(0,mapTo.h)(data),(0,catchError.K)((e=>isEmptyError(e)?empty.E:(0,throwError._)(e))))}(resolve,futureARS,futureRSS,injector).pipe((0,map.U)((resolvedData=>(futureARS._resolvedData=resolvedData,futureARS.data=inheritedParamsDataResolve(futureARS,paramsInheritanceStrategy).resolve,config&&hasStaticTitle(config)&&(futureARS.data[RouteTitleKey]=config.title),null))))}(check.route,targetSnapshot,paramsInheritanceStrategy,injector))),(0,tap.b)((()=>canActivateChecksResolved++)),takeLast(1),(0,mergeMap.z)((_=>canActivateChecksResolved===canActivateChecks.length?(0,of.of)(t):empty.E)))}))}function hasStaticTitle(config){return"string"==typeof config.title||null===config.title}function switchTap(next){return(0,switchMap.w)((v=>{const nextResult=next(v);return nextResult?(0,from.D)(nextResult).pipe((0,map.U)((()=>v))):(0,of.of)(v)}))}const ROUTES=new core.InjectionToken("ROUTES");class RouterConfigLoader{constructor(){this.componentLoaders=new WeakMap,this.childrenLoaders=new WeakMap,this.compiler=(0,core.inject)(core.Compiler)}loadComponent(route){if(this.componentLoaders.get(route))return this.componentLoaders.get(route);if(route._loadedComponent)return(0,of.of)(route._loadedComponent);this.onLoadStartListener&&this.onLoadStartListener(route);const loadRunner=wrapIntoObservable(route.loadComponent()).pipe((0,map.U)(maybeUnwrapDefaultExport),(0,tap.b)((component=>{this.onLoadEndListener&&this.onLoadEndListener(route),("undefined"==typeof ngDevMode||ngDevMode)&&assertStandalone(route.path??"",component),route._loadedComponent=component})),(0,finalize.x)((()=>{this.componentLoaders.delete(route)}))),loader=new ConnectableObservable.c(loadRunner,(()=>new Subject.x)).pipe((0,refCount.x)());return this.componentLoaders.set(route,loader),loader}loadChildren(parentInjector,route){if(this.childrenLoaders.get(route))return this.childrenLoaders.get(route);if(route._loadedRoutes)return(0,of.of)({routes:route._loadedRoutes,injector:route._loadedInjector});this.onLoadStartListener&&this.onLoadStartListener(route);const loadRunner=this.loadModuleFactoryOrRoutes(route.loadChildren).pipe((0,map.U)((factoryOrRoutes=>{let injector,rawRoutes;this.onLoadEndListener&&this.onLoadEndListener(route);let requireStandaloneComponents=!1;Array.isArray(factoryOrRoutes)?(rawRoutes=factoryOrRoutes,requireStandaloneComponents=!0):(injector=factoryOrRoutes.create(parentInjector).injector,rawRoutes=injector.get(ROUTES,[],core.InjectFlags.Self|core.InjectFlags.Optional).flat());const routes=rawRoutes.map(standardizeConfig);return("undefined"==typeof ngDevMode||ngDevMode)&&validateConfig(routes,route.path,requireStandaloneComponents),{routes,injector}})),(0,finalize.x)((()=>{this.childrenLoaders.delete(route)}))),loader=new ConnectableObservable.c(loadRunner,(()=>new Subject.x)).pipe((0,refCount.x)());return this.childrenLoaders.set(route,loader),loader}loadModuleFactoryOrRoutes(loadChildren){return wrapIntoObservable(loadChildren()).pipe((0,map.U)(maybeUnwrapDefaultExport),(0,mergeMap.z)((t=>t instanceof core.NgModuleFactory||Array.isArray(t)?(0,of.of)(t):(0,from.D)(this.compiler.compileModuleAsync(t)))))}static#_=this.ɵfac=function RouterConfigLoader_Factory(t){return new(t||RouterConfigLoader)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RouterConfigLoader,factory:RouterConfigLoader.ɵfac,providedIn:"root"})}function maybeUnwrapDefaultExport(input){return function isWrappedDefaultExport(value){return value&&"object"==typeof value&&"default"in value}(input)?input.default:input}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterConfigLoader,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class NavigationTransitions{get hasRequestedNavigation(){return 0!==this.navigationId}constructor(){this.currentNavigation=null,this.lastSuccessfulNavigation=null,this.events=new Subject.x,this.configLoader=(0,core.inject)(RouterConfigLoader),this.environmentInjector=(0,core.inject)(core.EnvironmentInjector),this.urlSerializer=(0,core.inject)(UrlSerializer),this.rootContexts=(0,core.inject)(ChildrenOutletContexts),this.inputBindingEnabled=null!==(0,core.inject)(INPUT_BINDER,{optional:!0}),this.navigationId=0,this.afterPreactivation=()=>(0,of.of)(void 0),this.rootComponentType=null;this.configLoader.onLoadEndListener=r=>this.events.next(new RouteConfigLoadEnd(r)),this.configLoader.onLoadStartListener=r=>this.events.next(new RouteConfigLoadStart(r))}complete(){this.transitions?.complete()}handleNavigationRequest(request){const id=++this.navigationId;this.transitions?.next({...this.transitions.value,...request,id})}setupNavigations(router){return this.transitions=new BehaviorSubject.X({id:0,currentUrlTree:router.currentUrlTree,currentRawUrl:router.currentUrlTree,extractedUrl:router.urlHandlingStrategy.extract(router.currentUrlTree),urlAfterRedirects:router.urlHandlingStrategy.extract(router.currentUrlTree),rawUrl:router.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:router.routerState.snapshot,targetSnapshot:null,currentRouterState:router.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.transitions.pipe((0,filter.h)((t=>0!==t.id)),(0,map.U)((t=>({...t,extractedUrl:router.urlHandlingStrategy.extract(t.rawUrl)}))),(0,switchMap.w)((overallTransitionState=>{let completed=!1,errored=!1;return(0,of.of)(overallTransitionState).pipe((0,tap.b)((t=>{this.currentNavigation={id:t.id,initialUrl:t.rawUrl,extractedUrl:t.extractedUrl,trigger:t.source,extras:t.extras,previousNavigation:this.lastSuccessfulNavigation?{...this.lastSuccessfulNavigation,previousNavigation:null}:null}})),(0,switchMap.w)((t=>{const browserUrlTree=router.browserUrlTree.toString(),urlTransition=!router.navigated||t.extractedUrl.toString()!==browserUrlTree||browserUrlTree!==router.currentUrlTree.toString(),onSameUrlNavigation=t.extras.onSameUrlNavigation??router.onSameUrlNavigation;if(!urlTransition&&"reload"!==onSameUrlNavigation){const reason="undefined"==typeof ngDevMode||ngDevMode?`Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.`:"";return this.events.next(new NavigationSkipped(t.id,router.serializeUrl(overallTransitionState.rawUrl),reason,0)),router.rawUrlTree=t.rawUrl,t.resolve(null),empty.E}if(router.urlHandlingStrategy.shouldProcessUrl(t.rawUrl))return isBrowserTriggeredNavigation(t.source)&&(router.browserUrlTree=t.extractedUrl),(0,of.of)(t).pipe((0,switchMap.w)((t=>{const transition=this.transitions?.getValue();return this.events.next(new NavigationStart(t.id,this.urlSerializer.serialize(t.extractedUrl),t.source,t.restoredState)),transition!==this.transitions?.getValue()?empty.E:Promise.resolve(t)})),recognize(this.environmentInjector,this.configLoader,this.rootComponentType,router.config,this.urlSerializer,router.paramsInheritanceStrategy),(0,tap.b)((t=>{if(overallTransitionState.targetSnapshot=t.targetSnapshot,overallTransitionState.urlAfterRedirects=t.urlAfterRedirects,this.currentNavigation={...this.currentNavigation,finalUrl:t.urlAfterRedirects},"eager"===router.urlUpdateStrategy){if(!t.extras.skipLocationChange){const rawUrl=router.urlHandlingStrategy.merge(t.urlAfterRedirects,t.rawUrl);router.setBrowserUrl(rawUrl,t)}router.browserUrlTree=t.urlAfterRedirects}const routesRecognized=new RoutesRecognized(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(t.urlAfterRedirects),t.targetSnapshot);this.events.next(routesRecognized)})));if(urlTransition&&router.urlHandlingStrategy.shouldProcessUrl(router.rawUrlTree)){const{id,extractedUrl,source,restoredState,extras}=t,navStart=new NavigationStart(id,this.urlSerializer.serialize(extractedUrl),source,restoredState);this.events.next(navStart);const targetSnapshot=createEmptyState(0,this.rootComponentType).snapshot;return overallTransitionState={...t,targetSnapshot,urlAfterRedirects:extractedUrl,extras:{...extras,skipLocationChange:!1,replaceUrl:!1}},(0,of.of)(overallTransitionState)}{const reason="undefined"==typeof ngDevMode||ngDevMode?`Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${router.rawUrlTree} nor target URL ${t.rawUrl} should be processed.`:"";return this.events.next(new NavigationSkipped(t.id,router.serializeUrl(overallTransitionState.extractedUrl),reason,1)),router.rawUrlTree=t.rawUrl,t.resolve(null),empty.E}})),(0,tap.b)((t=>{const guardsStart=new GuardsCheckStart(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(t.urlAfterRedirects),t.targetSnapshot);this.events.next(guardsStart)})),(0,map.U)((t=>overallTransitionState={...t,guards:getAllRouteGuards(t.targetSnapshot,t.currentSnapshot,this.rootContexts)})),checkGuards(this.environmentInjector,(evt=>this.events.next(evt))),(0,tap.b)((t=>{if(overallTransitionState.guardsResult=t.guardsResult,isUrlTree(t.guardsResult))throw redirectingNavigationError(this.urlSerializer,t.guardsResult);const guardsEnd=new GuardsCheckEnd(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(t.urlAfterRedirects),t.targetSnapshot,!!t.guardsResult);this.events.next(guardsEnd)})),(0,filter.h)((t=>!!t.guardsResult||(router.restoreHistory(t),this.cancelNavigationTransition(t,"",3),!1))),switchTap((t=>{if(t.guards.canActivateChecks.length)return(0,of.of)(t).pipe((0,tap.b)((t=>{const resolveStart=new ResolveStart(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(t.urlAfterRedirects),t.targetSnapshot);this.events.next(resolveStart)})),(0,switchMap.w)((t=>{let dataResolved=!1;return(0,of.of)(t).pipe(resolveData(router.paramsInheritanceStrategy,this.environmentInjector),(0,tap.b)({next:()=>dataResolved=!0,complete:()=>{dataResolved||(router.restoreHistory(t),this.cancelNavigationTransition(t,"undefined"==typeof ngDevMode||ngDevMode?"At least one route resolver didn't emit any value.":"",2))}}))})),(0,tap.b)((t=>{const resolveEnd=new ResolveEnd(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(t.urlAfterRedirects),t.targetSnapshot);this.events.next(resolveEnd)})))})),switchTap((t=>{const loadComponents=route=>{const loaders=[];route.routeConfig?.loadComponent&&!route.routeConfig._loadedComponent&&loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe((0,tap.b)((loadedComponent=>{route.component=loadedComponent})),(0,map.U)((()=>{}))));for(const child of route.children)loaders.push(...loadComponents(child));return loaders};return(0,combineLatest.a)(loadComponents(t.targetSnapshot.root)).pipe((0,defaultIfEmpty.d)(),(0,take.q)(1))})),switchTap((()=>this.afterPreactivation())),(0,map.U)((t=>{const targetRouterState=function createRouterState(routeReuseStrategy,curr,prevState){const root=createNode(routeReuseStrategy,curr._root,prevState?prevState._root:void 0);return new RouterState(root,curr)}(router.routeReuseStrategy,t.targetSnapshot,t.currentRouterState);return overallTransitionState={...t,targetRouterState}})),(0,tap.b)((t=>{router.currentUrlTree=t.urlAfterRedirects,router.rawUrlTree=router.urlHandlingStrategy.merge(t.urlAfterRedirects,t.rawUrl),router.routerState=t.targetRouterState,"deferred"===router.urlUpdateStrategy&&(t.extras.skipLocationChange||router.setBrowserUrl(router.rawUrlTree,t),router.browserUrlTree=t.urlAfterRedirects)})),(rootContexts=this.rootContexts,routeReuseStrategy=router.routeReuseStrategy,forwardEvent=evt=>this.events.next(evt),inputBindingEnabled=this.inputBindingEnabled,(0,map.U)((t=>(new ActivateRoutes(routeReuseStrategy,t.targetRouterState,t.currentRouterState,forwardEvent,inputBindingEnabled).activate(rootContexts),t)))),(0,take.q)(1),(0,tap.b)({next:t=>{completed=!0,this.lastSuccessfulNavigation=this.currentNavigation,router.navigated=!0,this.events.next(new NavigationEnd(t.id,this.urlSerializer.serialize(t.extractedUrl),this.urlSerializer.serialize(router.currentUrlTree))),router.titleStrategy?.updateTitle(t.targetRouterState.snapshot),t.resolve(!0)},complete:()=>{completed=!0}}),(0,finalize.x)((()=>{if(!completed&&!errored){const cancelationReason="undefined"==typeof ngDevMode||ngDevMode?`Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}`:"";this.cancelNavigationTransition(overallTransitionState,cancelationReason,1)}this.currentNavigation?.id===overallTransitionState.id&&(this.currentNavigation=null)})),(0,catchError.K)((e=>{if(errored=!0,isNavigationCancelingError$1(e)){isRedirectingNavigationCancelingError$1(e)||(router.navigated=!0,router.restoreHistory(overallTransitionState,!0));const navCancel=new NavigationCancel(overallTransitionState.id,this.urlSerializer.serialize(overallTransitionState.extractedUrl),e.message,e.cancellationCode);if(this.events.next(navCancel),isRedirectingNavigationCancelingError$1(e)){const mergedTree=router.urlHandlingStrategy.merge(e.url,router.rawUrlTree),extras={skipLocationChange:overallTransitionState.extras.skipLocationChange,replaceUrl:"eager"===router.urlUpdateStrategy||isBrowserTriggeredNavigation(overallTransitionState.source)};router.scheduleNavigation(mergedTree,"imperative",null,extras,{resolve:overallTransitionState.resolve,reject:overallTransitionState.reject,promise:overallTransitionState.promise})}else overallTransitionState.resolve(!1)}else{router.restoreHistory(overallTransitionState,!0);const navError=new NavigationError(overallTransitionState.id,this.urlSerializer.serialize(overallTransitionState.extractedUrl),e,overallTransitionState.targetSnapshot??void 0);this.events.next(navError);try{overallTransitionState.resolve(router.errorHandler(e))}catch(ee){overallTransitionState.reject(ee)}}return empty.E})));var rootContexts,routeReuseStrategy,forwardEvent,inputBindingEnabled})))}cancelNavigationTransition(t,reason,code){const navCancel=new NavigationCancel(t.id,this.urlSerializer.serialize(t.extractedUrl),reason,code);this.events.next(navCancel),t.resolve(!1)}static#_=this.ɵfac=function NavigationTransitions_Factory(t){return new(t||NavigationTransitions)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:NavigationTransitions,factory:NavigationTransitions.ɵfac,providedIn:"root"})}function isBrowserTriggeredNavigation(source){return"imperative"!==source}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](NavigationTransitions,[{type:core.Injectable,args:[{providedIn:"root"}]}],(function(){return[]}),null);class TitleStrategy{buildTitle(snapshot){let pageTitle,route=snapshot.root;for(;void 0!==route;)pageTitle=this.getResolvedTitleForRoute(route)??pageTitle,route=route.children.find((child=>child.outlet===PRIMARY_OUTLET));return pageTitle}getResolvedTitleForRoute(snapshot){return snapshot.data[RouteTitleKey]}static#_=this.ɵfac=function TitleStrategy_Factory(t){return new(t||TitleStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:TitleStrategy,factory:function(){return(0,core.inject)(DefaultTitleStrategy)},providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](TitleStrategy,[{type:core.Injectable,args:[{providedIn:"root",useFactory:()=>(0,core.inject)(DefaultTitleStrategy)}]}],null,null);class DefaultTitleStrategy extends TitleStrategy{constructor(title){super(),this.title=title}updateTitle(snapshot){const title=this.buildTitle(snapshot);void 0!==title&&this.title.setTitle(title)}static#_=this.ɵfac=function DefaultTitleStrategy_Factory(t){return new(t||DefaultTitleStrategy)(core["ɵɵinject"](platform_browser.Title))};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:DefaultTitleStrategy,factory:DefaultTitleStrategy.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](DefaultTitleStrategy,[{type:core.Injectable,args:[{providedIn:"root"}]}],(function(){return[{type:platform_browser.Title}]}),null);class RouteReuseStrategy{static#_=this.ɵfac=function RouteReuseStrategy_Factory(t){return new(t||RouteReuseStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RouteReuseStrategy,factory:function(){return(0,core.inject)(DefaultRouteReuseStrategy)},providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouteReuseStrategy,[{type:core.Injectable,args:[{providedIn:"root",useFactory:()=>(0,core.inject)(DefaultRouteReuseStrategy)}]}],null,null);class BaseRouteReuseStrategy{shouldDetach(route){return!1}store(route,detachedTree){}shouldAttach(route){return!1}retrieve(route){return null}shouldReuseRoute(future,curr){return future.routeConfig===curr.routeConfig}}class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy{static#_=this.ɵfac=function(){let ɵDefaultRouteReuseStrategy_BaseFactory;return function DefaultRouteReuseStrategy_Factory(t){return(ɵDefaultRouteReuseStrategy_BaseFactory||(ɵDefaultRouteReuseStrategy_BaseFactory=core["ɵɵgetInheritedFactory"](DefaultRouteReuseStrategy)))(t||DefaultRouteReuseStrategy)}}();static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:DefaultRouteReuseStrategy,factory:DefaultRouteReuseStrategy.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](DefaultRouteReuseStrategy,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);const ROUTER_CONFIGURATION=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"router config":"",{providedIn:"root",factory:()=>({})});class UrlHandlingStrategy{static#_=this.ɵfac=function UrlHandlingStrategy_Factory(t){return new(t||UrlHandlingStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:UrlHandlingStrategy,factory:function(){return(0,core.inject)(DefaultUrlHandlingStrategy)},providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](UrlHandlingStrategy,[{type:core.Injectable,args:[{providedIn:"root",useFactory:()=>(0,core.inject)(DefaultUrlHandlingStrategy)}]}],null,null);class DefaultUrlHandlingStrategy{shouldProcessUrl(url){return!0}extract(url){return url}merge(newUrlPart,wholeUrl){return newUrlPart}static#_=this.ɵfac=function DefaultUrlHandlingStrategy_Factory(t){return new(t||DefaultUrlHandlingStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:DefaultUrlHandlingStrategy,factory:DefaultUrlHandlingStrategy.ɵfac,providedIn:"root"})}var NavigationResult;function afterNextNavigation(router,action){router.events.pipe((0,filter.h)((e=>e instanceof NavigationEnd||e instanceof NavigationCancel||e instanceof NavigationError||e instanceof NavigationSkipped)),(0,map.U)((e=>{if(e instanceof NavigationEnd||e instanceof NavigationSkipped)return NavigationResult.COMPLETE;return e instanceof NavigationCancel&&(0===e.code||1===e.code)?NavigationResult.REDIRECTING:NavigationResult.FAILED})),(0,filter.h)((result=>result!==NavigationResult.REDIRECTING)),(0,take.q)(1)).subscribe((()=>{action()}))}function defaultErrorHandler(error){throw error}function defaultMalformedUriErrorHandler(error,urlSerializer,url){return urlSerializer.parse("/")}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](DefaultUrlHandlingStrategy,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null),function(NavigationResult){NavigationResult[NavigationResult.COMPLETE=0]="COMPLETE",NavigationResult[NavigationResult.FAILED=1]="FAILED",NavigationResult[NavigationResult.REDIRECTING=2]="REDIRECTING"}(NavigationResult||(NavigationResult={}));const exactMatchOptions={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},subsetMatchOptions={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};class Router{get navigationId(){return this.navigationTransitions.navigationId}get browserPageId(){if("computed"===this.canceledNavigationResolution)return this.location.getState()?.ɵrouterPageId}get events(){return this.navigationTransitions.events}constructor(){this.disposed=!1,this.currentPageId=0,this.console=(0,core.inject)(core["ɵConsole"]),this.isNgZoneEnabled=!1,this.options=(0,core.inject)(ROUTER_CONFIGURATION,{optional:!0})||{},this.pendingTasks=(0,core.inject)(core["ɵInitialRenderPendingTasks"]),this.errorHandler=this.options.errorHandler||defaultErrorHandler,this.malformedUriErrorHandler=this.options.malformedUriErrorHandler||defaultMalformedUriErrorHandler,this.navigated=!1,this.lastSuccessfulId=-1,this.urlHandlingStrategy=(0,core.inject)(UrlHandlingStrategy),this.routeReuseStrategy=(0,core.inject)(RouteReuseStrategy),this.titleStrategy=(0,core.inject)(TitleStrategy),this.onSameUrlNavigation=this.options.onSameUrlNavigation||"ignore",this.paramsInheritanceStrategy=this.options.paramsInheritanceStrategy||"emptyOnly",this.urlUpdateStrategy=this.options.urlUpdateStrategy||"deferred",this.canceledNavigationResolution=this.options.canceledNavigationResolution||"replace",this.config=(0,core.inject)(ROUTES,{optional:!0})?.flat()??[],this.navigationTransitions=(0,core.inject)(NavigationTransitions),this.urlSerializer=(0,core.inject)(UrlSerializer),this.location=(0,core.inject)(common.Location),this.componentInputBindingEnabled=!!(0,core.inject)(INPUT_BINDER,{optional:!0}),this.isNgZoneEnabled=(0,core.inject)(core.NgZone)instanceof core.NgZone&&core.NgZone.isInAngularZone(),this.resetConfig(this.config),this.currentUrlTree=new UrlTree,this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.routerState=createEmptyState(this.currentUrlTree,null),this.navigationTransitions.setupNavigations(this).subscribe((t=>{this.lastSuccessfulId=t.id,this.currentPageId=this.browserPageId??0}),(e=>{this.console.warn(`Unhandled Navigation Error: ${e}`)}))}resetRootComponentType(rootComponentType){this.routerState.root.component=rootComponentType,this.navigationTransitions.rootComponentType=rootComponentType}initialNavigation(){if(this.setUpLocationChangeListener(),!this.navigationTransitions.hasRequestedNavigation){const state=this.location.getState();this.navigateToSyncWithBrowser(this.location.path(!0),"imperative",state)}}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe((event=>{const source="popstate"===event.type?"popstate":"hashchange";"popstate"===source&&setTimeout((()=>{this.navigateToSyncWithBrowser(event.url,source,event.state)}),0)})))}navigateToSyncWithBrowser(url,source,state){const extras={replaceUrl:!0},restoredState=state?.navigationId?state:null;if(state){const stateCopy={...state};delete stateCopy.navigationId,delete stateCopy.ɵrouterPageId,0!==Object.keys(stateCopy).length&&(extras.state=stateCopy)}const urlTree=this.parseUrl(url);this.scheduleNavigation(urlTree,source,restoredState,extras)}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.navigationTransitions.currentNavigation}get lastSuccessfulNavigation(){return this.navigationTransitions.lastSuccessfulNavigation}resetConfig(config){("undefined"==typeof ngDevMode||ngDevMode)&&validateConfig(config),this.config=config.map(standardizeConfig),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.navigationTransitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(commands,navigationExtras={}){const{relativeTo,queryParams,fragment,queryParamsHandling,preserveFragment}=navigationExtras,f=preserveFragment?this.currentUrlTree.fragment:fragment;let relativeToUrlSegmentGroup,q=null;switch(queryParamsHandling){case"merge":q={...this.currentUrlTree.queryParams,...queryParams};break;case"preserve":q=this.currentUrlTree.queryParams;break;default:q=queryParams||null}null!==q&&(q=this.removeEmptyProps(q));try{relativeToUrlSegmentGroup=createSegmentGroupFromRoute(relativeTo?relativeTo.snapshot:this.routerState.snapshot.root)}catch(e){"string"==typeof commands[0]&&commands[0].startsWith("/")||(commands=[]),relativeToUrlSegmentGroup=this.currentUrlTree.root}return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup,commands,q,f??null)}navigateByUrl(url,extras={skipLocationChange:!1}){("undefined"==typeof ngDevMode||ngDevMode)&&this.isNgZoneEnabled&&!core.NgZone.isInAngularZone()&&this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");const urlTree=isUrlTree(url)?url:this.parseUrl(url),mergedTree=this.urlHandlingStrategy.merge(urlTree,this.rawUrlTree);return this.scheduleNavigation(mergedTree,"imperative",null,extras)}navigate(commands,extras={skipLocationChange:!1}){return function validateCommands(commands){for(let i=0;i<commands.length;i++){const cmd=commands[i];if(null==cmd)throw new core["ɵRuntimeError"](4008,("undefined"==typeof ngDevMode||ngDevMode)&&`The requested path contains ${cmd} segment at index ${i}`)}}(commands),this.navigateByUrl(this.createUrlTree(commands,extras),extras)}serializeUrl(url){return this.urlSerializer.serialize(url)}parseUrl(url){let urlTree;try{urlTree=this.urlSerializer.parse(url)}catch(e){urlTree=this.malformedUriErrorHandler(e,this.urlSerializer,url)}return urlTree}isActive(url,matchOptions){let options;if(options=!0===matchOptions?{...exactMatchOptions}:!1===matchOptions?{...subsetMatchOptions}:matchOptions,isUrlTree(url))return containsTree(this.currentUrlTree,url,options);const urlTree=this.parseUrl(url);return containsTree(this.currentUrlTree,urlTree,options)}removeEmptyProps(params){return Object.keys(params).reduce(((result,key)=>{const value=params[key];return null!=value&&(result[key]=value),result}),{})}scheduleNavigation(rawUrl,source,restoredState,extras,priorPromise){if(this.disposed)return Promise.resolve(!1);let resolve,reject,promise;priorPromise?(resolve=priorPromise.resolve,reject=priorPromise.reject,promise=priorPromise.promise):promise=new Promise(((res,rej)=>{resolve=res,reject=rej}));const taskId=this.pendingTasks.add();return afterNextNavigation(this,(()=>{Promise.resolve().then((()=>this.pendingTasks.remove(taskId)))})),this.navigationTransitions.handleNavigationRequest({source,restoredState,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,rawUrl,extras,resolve,reject,promise,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),promise.catch((e=>Promise.reject(e)))}setBrowserUrl(url,transition){const path=this.urlSerializer.serialize(url);if(this.location.isCurrentPathEqualTo(path)||transition.extras.replaceUrl){const currentBrowserPageId=this.browserPageId,state={...transition.extras.state,...this.generateNgRouterState(transition.id,currentBrowserPageId)};this.location.replaceState(path,"",state)}else{const state={...transition.extras.state,...this.generateNgRouterState(transition.id,(this.browserPageId??0)+1)};this.location.go(path,"",state)}}restoreHistory(transition,restoringFromCaughtError=!1){if("computed"===this.canceledNavigationResolution){const currentBrowserPageId=this.browserPageId??this.currentPageId,targetPagePosition=this.currentPageId-currentBrowserPageId;0!==targetPagePosition?this.location.historyGo(targetPagePosition):this.currentUrlTree===this.getCurrentNavigation()?.finalUrl&&0===targetPagePosition&&(this.resetState(transition),this.browserUrlTree=transition.currentUrlTree,this.resetUrlToCurrentUrlTree())}else"replace"===this.canceledNavigationResolution&&(restoringFromCaughtError&&this.resetState(transition),this.resetUrlToCurrentUrlTree())}resetState(t){this.routerState=t.currentRouterState,this.currentUrlTree=t.currentUrlTree,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,t.rawUrl)}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}generateNgRouterState(navigationId,routerPageId){return"computed"===this.canceledNavigationResolution?{navigationId,ɵrouterPageId:routerPageId}:{navigationId}}static#_=this.ɵfac=function Router_Factory(t){return new(t||Router)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:Router,factory:Router.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](Router,[{type:core.Injectable,args:[{providedIn:"root"}]}],(function(){return[]}),null);class RouterLink{constructor(router,route,tabIndexAttribute,renderer,el,locationStrategy){this.router=router,this.route=route,this.tabIndexAttribute=tabIndexAttribute,this.renderer=renderer,this.el=el,this.locationStrategy=locationStrategy,this._preserveFragment=!1,this._skipLocationChange=!1,this._replaceUrl=!1,this.href=null,this.commands=null,this.onChanges=new Subject.x;const tagName=el.nativeElement.tagName?.toLowerCase();this.isAnchorElement="a"===tagName||"area"===tagName,this.isAnchorElement?this.subscription=router.events.subscribe((s=>{s instanceof NavigationEnd&&this.updateHref()})):this.setTabIndexIfNotOnNativeEl("0")}set preserveFragment(preserveFragment){this._preserveFragment=(0,core["ɵcoerceToBoolean"])(preserveFragment)}get preserveFragment(){return this._preserveFragment}set skipLocationChange(skipLocationChange){this._skipLocationChange=(0,core["ɵcoerceToBoolean"])(skipLocationChange)}get skipLocationChange(){return this._skipLocationChange}set replaceUrl(replaceUrl){this._replaceUrl=(0,core["ɵcoerceToBoolean"])(replaceUrl)}get replaceUrl(){return this._replaceUrl}setTabIndexIfNotOnNativeEl(newTabIndex){null!=this.tabIndexAttribute||this.isAnchorElement||this.applyAttributeValue("tabindex",newTabIndex)}ngOnChanges(changes){this.isAnchorElement&&this.updateHref(),this.onChanges.next(this)}set routerLink(commands){null!=commands?(this.commands=Array.isArray(commands)?commands:[commands],this.setTabIndexIfNotOnNativeEl("0")):(this.commands=null,this.setTabIndexIfNotOnNativeEl(null))}onClick(button,ctrlKey,shiftKey,altKey,metaKey){if(null===this.urlTree)return!0;if(this.isAnchorElement){if(0!==button||ctrlKey||shiftKey||altKey||metaKey)return!0;if("string"==typeof this.target&&"_self"!=this.target)return!0}const extras={skipLocationChange:this.skipLocationChange,replaceUrl:this.replaceUrl,state:this.state};return this.router.navigateByUrl(this.urlTree,extras),!this.isAnchorElement}ngOnDestroy(){this.subscription?.unsubscribe()}updateHref(){this.href=null!==this.urlTree&&this.locationStrategy?this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)):null;const sanitizedValue=null===this.href?null:(0,core["ɵɵsanitizeUrlOrResourceUrl"])(this.href,this.el.nativeElement.tagName.toLowerCase(),"href");this.applyAttributeValue("href",sanitizedValue)}applyAttributeValue(attrName,attrValue){const renderer=this.renderer,nativeElement=this.el.nativeElement;null!==attrValue?renderer.setAttribute(nativeElement,attrName,attrValue):renderer.removeAttribute(nativeElement,attrName)}get urlTree(){return null===this.commands?null:this.router.createUrlTree(this.commands,{relativeTo:void 0!==this.relativeTo?this.relativeTo:this.route,queryParams:this.queryParams,fragment:this.fragment,queryParamsHandling:this.queryParamsHandling,preserveFragment:this.preserveFragment})}static#_=this.ɵfac=function RouterLink_Factory(t){return new(t||RouterLink)(core["ɵɵdirectiveInject"](Router),core["ɵɵdirectiveInject"](ActivatedRoute),core["ɵɵinjectAttribute"]("tabindex"),core["ɵɵdirectiveInject"](core.Renderer2),core["ɵɵdirectiveInject"](core.ElementRef),core["ɵɵdirectiveInject"](common.LocationStrategy))};static#_2=this.ɵdir=core["ɵɵdefineDirective"]({type:RouterLink,selectors:[["","routerLink",""]],hostVars:1,hostBindings:function RouterLink_HostBindings(rf,ctx){1&rf&&core["ɵɵlistener"]("click",(function RouterLink_click_HostBindingHandler($event){return ctx.onClick($event.button,$event.ctrlKey,$event.shiftKey,$event.altKey,$event.metaKey)})),2&rf&&core["ɵɵattribute"]("target",ctx.target)},inputs:{target:"target",queryParams:"queryParams",fragment:"fragment",queryParamsHandling:"queryParamsHandling",state:"state",relativeTo:"relativeTo",preserveFragment:"preserveFragment",skipLocationChange:"skipLocationChange",replaceUrl:"replaceUrl",routerLink:"routerLink"},standalone:!0,features:[core["ɵɵNgOnChangesFeature"]]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterLink,[{type:core.Directive,args:[{selector:"[routerLink]",standalone:!0}]}],(function(){return[{type:Router},{type:ActivatedRoute},{type:void 0,decorators:[{type:core.Attribute,args:["tabindex"]}]},{type:core.Renderer2},{type:core.ElementRef},{type:common.LocationStrategy}]}),{target:[{type:core.HostBinding,args:["attr.target"]},{type:core.Input}],queryParams:[{type:core.Input}],fragment:[{type:core.Input}],queryParamsHandling:[{type:core.Input}],state:[{type:core.Input}],relativeTo:[{type:core.Input}],preserveFragment:[{type:core.Input}],skipLocationChange:[{type:core.Input}],replaceUrl:[{type:core.Input}],routerLink:[{type:core.Input}],onClick:[{type:core.HostListener,args:["click",["$event.button","$event.ctrlKey","$event.shiftKey","$event.altKey","$event.metaKey"]]}]});class RouterLinkActive{get isActive(){return this._isActive}constructor(router,element,renderer,cdr,link){this.router=router,this.element=element,this.renderer=renderer,this.cdr=cdr,this.link=link,this.classes=[],this._isActive=!1,this.routerLinkActiveOptions={exact:!1},this.isActiveChange=new core.EventEmitter,this.routerEventsSubscription=router.events.subscribe((s=>{s instanceof NavigationEnd&&this.update()}))}ngAfterContentInit(){(0,of.of)(this.links.changes,(0,of.of)(null)).pipe((0,mergeAll.J)()).subscribe((_=>{this.update(),this.subscribeToEachLinkOnChanges()}))}subscribeToEachLinkOnChanges(){this.linkInputChangesSubscription?.unsubscribe();const allLinkChanges=[...this.links.toArray(),this.link].filter((link=>!!link)).map((link=>link.onChanges));this.linkInputChangesSubscription=(0,from.D)(allLinkChanges).pipe((0,mergeAll.J)()).subscribe((link=>{this._isActive!==this.isLinkActive(this.router)(link)&&this.update()}))}set routerLinkActive(data){const classes=Array.isArray(data)?data:data.split(" ");this.classes=classes.filter((c=>!!c))}ngOnChanges(changes){this.update()}ngOnDestroy(){this.routerEventsSubscription.unsubscribe(),this.linkInputChangesSubscription?.unsubscribe()}update(){this.links&&this.router.navigated&&Promise.resolve().then((()=>{const hasActiveLinks=this.hasActiveLinks();this._isActive!==hasActiveLinks&&(this._isActive=hasActiveLinks,this.cdr.markForCheck(),this.classes.forEach((c=>{hasActiveLinks?this.renderer.addClass(this.element.nativeElement,c):this.renderer.removeClass(this.element.nativeElement,c)})),hasActiveLinks&&void 0!==this.ariaCurrentWhenActive?this.renderer.setAttribute(this.element.nativeElement,"aria-current",this.ariaCurrentWhenActive.toString()):this.renderer.removeAttribute(this.element.nativeElement,"aria-current"),this.isActiveChange.emit(hasActiveLinks))}))}isLinkActive(router){const options=function isActiveMatchOptions(options){return!!options.paths}(this.routerLinkActiveOptions)?this.routerLinkActiveOptions:this.routerLinkActiveOptions.exact||!1;return link=>!!link.urlTree&&router.isActive(link.urlTree,options)}hasActiveLinks(){const isActiveCheckFn=this.isLinkActive(this.router);return this.link&&isActiveCheckFn(this.link)||this.links.some(isActiveCheckFn)}static#_=this.ɵfac=function RouterLinkActive_Factory(t){return new(t||RouterLinkActive)(core["ɵɵdirectiveInject"](Router),core["ɵɵdirectiveInject"](core.ElementRef),core["ɵɵdirectiveInject"](core.Renderer2),core["ɵɵdirectiveInject"](core.ChangeDetectorRef),core["ɵɵdirectiveInject"](RouterLink,8))};static#_2=this.ɵdir=core["ɵɵdefineDirective"]({type:RouterLinkActive,selectors:[["","routerLinkActive",""]],contentQueries:function RouterLinkActive_ContentQueries(rf,ctx,dirIndex){if(1&rf&&core["ɵɵcontentQuery"](dirIndex,RouterLink,5),2&rf){let _t;core["ɵɵqueryRefresh"](_t=core["ɵɵloadQuery"]())&&(ctx.links=_t)}},inputs:{routerLinkActiveOptions:"routerLinkActiveOptions",ariaCurrentWhenActive:"ariaCurrentWhenActive",routerLinkActive:"routerLinkActive"},outputs:{isActiveChange:"isActiveChange"},exportAs:["routerLinkActive"],standalone:!0,features:[core["ɵɵNgOnChangesFeature"]]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterLinkActive,[{type:core.Directive,args:[{selector:"[routerLinkActive]",exportAs:"routerLinkActive",standalone:!0}]}],(function(){return[{type:Router},{type:core.ElementRef},{type:core.Renderer2},{type:core.ChangeDetectorRef},{type:RouterLink,decorators:[{type:core.Optional}]}]}),{links:[{type:core.ContentChildren,args:[RouterLink,{descendants:!0}]}],routerLinkActiveOptions:[{type:core.Input}],ariaCurrentWhenActive:[{type:core.Input}],isActiveChange:[{type:core.Output}],routerLinkActive:[{type:core.Input}]});class PreloadingStrategy{}class PreloadAllModules{preload(route,fn){return fn().pipe((0,catchError.K)((()=>(0,of.of)(null))))}static#_=this.ɵfac=function PreloadAllModules_Factory(t){return new(t||PreloadAllModules)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:PreloadAllModules,factory:PreloadAllModules.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](PreloadAllModules,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class NoPreloading{preload(route,fn){return(0,of.of)(null)}static#_=this.ɵfac=function NoPreloading_Factory(t){return new(t||NoPreloading)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:NoPreloading,factory:NoPreloading.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](NoPreloading,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class RouterPreloader{constructor(router,compiler,injector,preloadingStrategy,loader){this.router=router,this.injector=injector,this.preloadingStrategy=preloadingStrategy,this.loader=loader}setUpPreloading(){this.subscription=this.router.events.pipe((0,filter.h)((e=>e instanceof NavigationEnd)),(0,concatMap.b)((()=>this.preload()))).subscribe((()=>{}))}preload(){return this.processRoutes(this.injector,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(injector,routes){const res=[];for(const route of routes){route.providers&&!route._injector&&(route._injector=(0,core.createEnvironmentInjector)(route.providers,injector,`Route: ${route.path}`));const injectorForCurrentRoute=route._injector??injector,injectorForChildren=route._loadedInjector??injectorForCurrentRoute;(route.loadChildren&&!route._loadedRoutes&&void 0===route.canLoad||route.loadComponent&&!route._loadedComponent)&&res.push(this.preloadConfig(injectorForCurrentRoute,route)),(route.children||route._loadedRoutes)&&res.push(this.processRoutes(injectorForChildren,route.children??route._loadedRoutes))}return(0,from.D)(res).pipe((0,mergeAll.J)())}preloadConfig(injector,route){return this.preloadingStrategy.preload(route,(()=>{let loadedChildren$;loadedChildren$=route.loadChildren&&void 0===route.canLoad?this.loader.loadChildren(injector,route):(0,of.of)(null);const recursiveLoadChildren$=loadedChildren$.pipe((0,mergeMap.z)((config=>null===config?(0,of.of)(void 0):(route._loadedRoutes=config.routes,route._loadedInjector=config.injector,this.processRoutes(config.injector??injector,config.routes)))));if(route.loadComponent&&!route._loadedComponent){const loadComponent$=this.loader.loadComponent(route);return(0,from.D)([recursiveLoadChildren$,loadComponent$]).pipe((0,mergeAll.J)())}return recursiveLoadChildren$}))}static#_=this.ɵfac=function RouterPreloader_Factory(t){return new(t||RouterPreloader)(core["ɵɵinject"](Router),core["ɵɵinject"](core.Compiler),core["ɵɵinject"](core.EnvironmentInjector),core["ɵɵinject"](PreloadingStrategy),core["ɵɵinject"](RouterConfigLoader))};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RouterPreloader,factory:RouterPreloader.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterPreloader,[{type:core.Injectable,args:[{providedIn:"root"}]}],(function(){return[{type:Router},{type:core.Compiler},{type:core.EnvironmentInjector},{type:PreloadingStrategy},{type:RouterConfigLoader}]}),null);const ROUTER_SCROLLER=new core.InjectionToken("");class RouterScroller{constructor(urlSerializer,transitions,viewportScroller,zone,options={}){this.urlSerializer=urlSerializer,this.transitions=transitions,this.viewportScroller=viewportScroller,this.zone=zone,this.options=options,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},options.scrollPositionRestoration=options.scrollPositionRestoration||"disabled",options.anchorScrolling=options.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.transitions.events.subscribe((e=>{e instanceof NavigationStart?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof NavigationEnd?(this.lastId=e.id,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.urlAfterRedirects).fragment)):e instanceof NavigationSkipped&&0===e.code&&(this.lastSource=void 0,this.restoredId=0,this.scheduleScrollEvent(e,this.urlSerializer.parse(e.url).fragment))}))}consumeScrollEvents(){return this.transitions.events.subscribe((e=>{e instanceof Scroll&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))}))}scheduleScrollEvent(routerEvent,anchor){this.zone.runOutsideAngular((()=>{setTimeout((()=>{this.zone.run((()=>{this.transitions.events.next(new Scroll(routerEvent,"popstate"===this.lastSource?this.store[this.restoredId]:null,anchor))}))}),0)}))}ngOnDestroy(){this.routerEventsSubscription?.unsubscribe(),this.scrollEventsSubscription?.unsubscribe()}static#_=this.ɵfac=function RouterScroller_Factory(t){core["ɵɵinvalidFactory"]()};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RouterScroller,factory:RouterScroller.ɵfac})}function rootRoute(router){return router.routerState.root}function routerFeature(kind,providers){return{ɵkind:kind,ɵproviders:providers}}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterScroller,[{type:core.Injectable}],(function(){return[{type:UrlSerializer},{type:NavigationTransitions},{type:common.ViewportScroller},{type:core.NgZone},{type:void 0}]}),null);const ROUTER_IS_PROVIDED=new core.InjectionToken("",{providedIn:"root",factory:()=>!1});core.ENVIRONMENT_INITIALIZER;function getBootstrapListener(){const injector=(0,core.inject)(core.Injector);return bootstrappedComponentRef=>{const ref=injector.get(core.ApplicationRef);if(bootstrappedComponentRef!==ref.components[0])return;const router=injector.get(Router),bootstrapDone=injector.get(BOOTSTRAP_DONE);1===injector.get(INITIAL_NAVIGATION)&&router.initialNavigation(),injector.get(ROUTER_PRELOADER,null,core.InjectFlags.Optional)?.setUpPreloading(),injector.get(ROUTER_SCROLLER,null,core.InjectFlags.Optional)?.init(),router.resetRootComponentType(ref.componentTypes[0]),bootstrapDone.closed||(bootstrapDone.next(),bootstrapDone.complete(),bootstrapDone.unsubscribe())}}const BOOTSTRAP_DONE=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"bootstrap done indicator":"",{factory:()=>new Subject.x}),INITIAL_NAVIGATION=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"initial navigation":"",{providedIn:"root",factory:()=>1});function withDebugTracing(){let providers=[];return providers="undefined"==typeof ngDevMode||ngDevMode?[{provide:core.ENVIRONMENT_INITIALIZER,multi:!0,useFactory:()=>{const router=(0,core.inject)(Router);return()=>router.events.subscribe((e=>{console.group?.(`Router Event: ${e.constructor.name}`),console.log(function stringifyEvent(routerEvent){switch(routerEvent.type){case 14:return`ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path||""}')`;case 13:return`ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path||""}')`;case 12:return`ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path||""}')`;case 11:return`ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path||""}')`;case 8:return`GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;case 7:return`GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;case 2:return`NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;case 16:return`NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;case 1:return`NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;case 3:return`NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;case 0:return`NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;case 6:return`ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;case 5:return`ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;case 10:return`RouteConfigLoadEnd(path: ${routerEvent.route.path})`;case 9:return`RouteConfigLoadStart(path: ${routerEvent.route.path})`;case 4:return`RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;case 15:const pos=routerEvent.position?`${routerEvent.position[0]}, ${routerEvent.position[1]}`:null;return`Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`}}(e)),console.log(e),console.groupEnd?.()}))}}]:[],routerFeature(1,providers)}const ROUTER_PRELOADER=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"router preloader":"");function withPreloading(preloadingStrategy){return routerFeature(0,[{provide:ROUTER_PRELOADER,useExisting:RouterPreloader},{provide:PreloadingStrategy,useExisting:preloadingStrategy}])}const ROUTER_DIRECTIVES=[RouterOutlet,RouterLink,RouterLinkActive,ɵEmptyOutletComponent],ROUTER_FORROOT_GUARD=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"router duplicate forRoot guard":"ROUTER_FORROOT_GUARD"),ROUTER_PROVIDERS=[common.Location,{provide:UrlSerializer,useClass:DefaultUrlSerializer},Router,ChildrenOutletContexts,{provide:ActivatedRoute,useFactory:rootRoute,deps:[Router]},RouterConfigLoader,"undefined"==typeof ngDevMode||ngDevMode?{provide:ROUTER_IS_PROVIDED,useValue:!0}:[]];function routerNgProbeToken(){return new core.NgProbeToken("Router",Router)}class RouterModule{constructor(guard){}static forRoot(routes,config){return{ngModule:RouterModule,providers:[ROUTER_PROVIDERS,("undefined"==typeof ngDevMode||ngDevMode)&&config?.enableTracing?withDebugTracing().ɵproviders:[],{provide:ROUTES,multi:!0,useValue:routes},{provide:ROUTER_FORROOT_GUARD,useFactory:provideForRootGuard,deps:[[Router,new core.Optional,new core.SkipSelf]]},{provide:ROUTER_CONFIGURATION,useValue:config||{}},config?.useHash?{provide:common.LocationStrategy,useClass:common.HashLocationStrategy}:{provide:common.LocationStrategy,useClass:common.PathLocationStrategy},{provide:ROUTER_SCROLLER,useFactory:()=>{const viewportScroller=(0,core.inject)(common.ViewportScroller),zone=(0,core.inject)(core.NgZone),config=(0,core.inject)(ROUTER_CONFIGURATION),transitions=(0,core.inject)(NavigationTransitions),urlSerializer=(0,core.inject)(UrlSerializer);return config.scrollOffset&&viewportScroller.setOffset(config.scrollOffset),new RouterScroller(urlSerializer,transitions,viewportScroller,zone,config)}},config?.preloadingStrategy?withPreloading(config.preloadingStrategy).ɵproviders:[],{provide:core.NgProbeToken,multi:!0,useFactory:routerNgProbeToken},config?.initialNavigation?provideInitialNavigation(config):[],config?.bindToComponentInputs?routerFeature(8,[RoutedComponentInputBinder,{provide:INPUT_BINDER,useExisting:RoutedComponentInputBinder}]).ɵproviders:[],[{provide:ROUTER_INITIALIZER,useFactory:getBootstrapListener},{provide:core.APP_BOOTSTRAP_LISTENER,multi:!0,useExisting:ROUTER_INITIALIZER}]]}}static forChild(routes){return{ngModule:RouterModule,providers:[{provide:ROUTES,multi:!0,useValue:routes}]}}static#_=this.ɵfac=function RouterModule_Factory(t){return new(t||RouterModule)(core["ɵɵinject"](ROUTER_FORROOT_GUARD,8))};static#_2=this.ɵmod=core["ɵɵdefineNgModule"]({type:RouterModule,imports:[RouterOutlet,RouterLink,RouterLinkActive,ɵEmptyOutletComponent],exports:[RouterOutlet,RouterLink,RouterLinkActive,ɵEmptyOutletComponent]});static#_3=this.ɵinj=core["ɵɵdefineInjector"]({})}function provideForRootGuard(router){if(("undefined"==typeof ngDevMode||ngDevMode)&&router)throw new core["ɵRuntimeError"](4007,"The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.");return"guarded"}function provideInitialNavigation(config){return["disabled"===config.initialNavigation?routerFeature(3,[{provide:core.APP_INITIALIZER,multi:!0,useFactory:()=>{const router=(0,core.inject)(Router);return()=>{router.setUpLocationChangeListener()}}},{provide:INITIAL_NAVIGATION,useValue:2}]).ɵproviders:[],"enabledBlocking"===config.initialNavigation?routerFeature(2,[{provide:INITIAL_NAVIGATION,useValue:0},{provide:core.APP_INITIALIZER,multi:!0,deps:[core.Injector],useFactory:injector=>{const locationInitialized=injector.get(common.LOCATION_INITIALIZED,Promise.resolve());return()=>locationInitialized.then((()=>new Promise((resolve=>{const router=injector.get(Router),bootstrapDone=injector.get(BOOTSTRAP_DONE);afterNextNavigation(router,(()=>{resolve(!0)})),injector.get(NavigationTransitions).afterPreactivation=()=>(resolve(!0),bootstrapDone.closed?(0,of.of)(void 0):bootstrapDone),router.initialNavigation()}))))}}]).ɵproviders:[]]}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterModule,[{type:core.NgModule,args:[{imports:ROUTER_DIRECTIVES,exports:ROUTER_DIRECTIVES}]}],(function(){return[{type:void 0,decorators:[{type:core.Optional},{type:core.Inject,args:[ROUTER_FORROOT_GUARD]}]}]}),null);const ROUTER_INITIALIZER=new core.InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"Router Initializer":"");new core.Version("16.0.0")},"./node_modules/@angular/router/fesm2022/testing.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{Z_:()=>RouterTestingModule});var asyncToGenerator=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),core=__webpack_require__("./node_modules/@angular/core/fesm2022/core.mjs"),common=__webpack_require__("./node_modules/@angular/common/fesm2022/common.mjs"),Subject=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subject.js");function normalizeQueryParams(params){return params&&"?"!==params[0]?"?"+params:params}class SpyLocation{constructor(){this.urlChanges=[],this._history=[new LocationState("","",null)],this._historyIndex=0,this._subject=new core.EventEmitter,this._basePath="",this._locationStrategy=null,this._urlChangeListeners=[],this._urlChangeSubscription=null}ngOnDestroy(){this._urlChangeSubscription?.unsubscribe(),this._urlChangeListeners=[]}setInitialPath(url){this._history[this._historyIndex].path=url}setBaseHref(url){this._basePath=url}path(){return this._history[this._historyIndex].path}getState(){return this._history[this._historyIndex].state}isCurrentPathEqualTo(path,query=""){const givenPath=path.endsWith("/")?path.substring(0,path.length-1):path;return(this.path().endsWith("/")?this.path().substring(0,this.path().length-1):this.path())==givenPath+(query.length>0?"?"+query:"")}simulateUrlPop(pathname){this._subject.emit({url:pathname,pop:!0,type:"popstate"})}simulateHashChange(pathname){const path=this.prepareExternalUrl(pathname);this.pushHistory(path,"",null),this.urlChanges.push("hash: "+pathname),this._subject.emit({url:pathname,pop:!0,type:"popstate"}),this._subject.emit({url:pathname,pop:!0,type:"hashchange"})}prepareExternalUrl(url){return url.length>0&&!url.startsWith("/")&&(url="/"+url),this._basePath+url}go(path,query="",state=null){path=this.prepareExternalUrl(path),this.pushHistory(path,query,state);const locationState=this._history[this._historyIndex-1];if(locationState.path==path&&locationState.query==query)return;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push(url),this._notifyUrlChangeListeners(path+normalizeQueryParams(query),state)}replaceState(path,query="",state=null){path=this.prepareExternalUrl(path);const history=this._history[this._historyIndex];if(history.state=state,history.path==path&&history.query==query)return;history.path=path,history.query=query;const url=path+(query.length>0?"?"+query:"");this.urlChanges.push("replace: "+url),this._notifyUrlChangeListeners(path+normalizeQueryParams(query),state)}forward(){this._historyIndex<this._history.length-1&&(this._historyIndex++,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}back(){this._historyIndex>0&&(this._historyIndex--,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}historyGo(relativePosition=0){const nextPageIndex=this._historyIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this._history.length&&(this._historyIndex=nextPageIndex,this._subject.emit({url:this.path(),state:this.getState(),pop:!0,type:"popstate"}))}onUrlChange(fn){return this._urlChangeListeners.push(fn),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe((v=>{this._notifyUrlChangeListeners(v.url,v.state)}))),()=>{const fnIndex=this._urlChangeListeners.indexOf(fn);this._urlChangeListeners.splice(fnIndex,1),0===this._urlChangeListeners.length&&(this._urlChangeSubscription?.unsubscribe(),this._urlChangeSubscription=null)}}_notifyUrlChangeListeners(url="",state){this._urlChangeListeners.forEach((fn=>fn(url,state)))}subscribe(onNext,onThrow,onReturn){return this._subject.subscribe({next:onNext,error:onThrow,complete:onReturn})}normalize(url){return null}pushHistory(path,query,state){this._historyIndex>0&&this._history.splice(this._historyIndex+1),this._history.push(new LocationState(path,query,state)),this._historyIndex=this._history.length-1}static#_=this.ɵfac=function SpyLocation_Factory(t){return new(t||SpyLocation)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:SpyLocation,factory:SpyLocation.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](SpyLocation,[{type:core.Injectable}],null,null);class LocationState{constructor(path,query,state){this.path=path,this.query=query,this.state=state}}class MockLocationStrategy extends common.LocationStrategy{constructor(){super(),this.internalBaseHref="/",this.internalPath="/",this.internalTitle="",this.urlChanges=[],this._subject=new core.EventEmitter,this.stateChanges=[]}simulatePopState(url){this.internalPath=url,this._subject.emit(new _MockPopStateEvent(this.path()))}path(includeHash=!1){return this.internalPath}prepareExternalUrl(internal){return internal.startsWith("/")&&this.internalBaseHref.endsWith("/")?this.internalBaseHref+internal.substring(1):this.internalBaseHref+internal}pushState(ctx,title,path,query){this.stateChanges.push(ctx),this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push(externalUrl)}replaceState(ctx,title,path,query){this.stateChanges[(this.stateChanges.length||1)-1]=ctx,this.internalTitle=title;const url=path+(query.length>0?"?"+query:"");this.internalPath=url;const externalUrl=this.prepareExternalUrl(url);this.urlChanges.push("replace: "+externalUrl)}onPopState(fn){this._subject.subscribe({next:fn})}getBaseHref(){return this.internalBaseHref}back(){if(this.urlChanges.length>0){this.urlChanges.pop(),this.stateChanges.pop();const nextUrl=this.urlChanges.length>0?this.urlChanges[this.urlChanges.length-1]:"";this.simulatePopState(nextUrl)}}forward(){throw"not implemented"}getState(){return this.stateChanges[(this.stateChanges.length||1)-1]}static#_=this.ɵfac=function MockLocationStrategy_Factory(t){return new(t||MockLocationStrategy)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:MockLocationStrategy,factory:MockLocationStrategy.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockLocationStrategy,[{type:core.Injectable}],(function(){return[]}),null);class _MockPopStateEvent{constructor(newUrl){this.newUrl=newUrl,this.pop=!0,this.type="popstate"}}const urlParse=/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;function parseUrl(urlStr,baseHref){let serverBase,parsedUrl;/^((http[s]?|ftp):\/\/)/.test(urlStr)||(serverBase="http://empty.com/");try{parsedUrl=new URL(urlStr,serverBase)}catch(e){const result=urlParse.exec(serverBase||""+urlStr);if(!result)throw new Error(`Invalid URL: ${urlStr} with base: ${baseHref}`);const hostSplit=result[4].split(":");parsedUrl={protocol:result[1],hostname:hostSplit[0],port:hostSplit[1]||"",pathname:result[5],search:result[6],hash:result[8]}}return parsedUrl.pathname&&0===parsedUrl.pathname.indexOf(baseHref)&&(parsedUrl.pathname=parsedUrl.pathname.substring(baseHref.length)),{hostname:!serverBase&&parsedUrl.hostname||"",protocol:!serverBase&&parsedUrl.protocol||"",port:!serverBase&&parsedUrl.port||"",pathname:parsedUrl.pathname||"/",search:parsedUrl.search||"",hash:parsedUrl.hash||""}}const MOCK_PLATFORM_LOCATION_CONFIG=new core.InjectionToken("MOCK_PLATFORM_LOCATION_CONFIG");class MockPlatformLocation{constructor(config){if(this.baseHref="",this.hashUpdate=new Subject.x,this.popStateSubject=new Subject.x,this.urlChangeIndex=0,this.urlChanges=[{hostname:"",protocol:"",port:"",pathname:"/",search:"",hash:"",state:null}],config){this.baseHref=config.appBaseHref||"";const parsedChanges=this.parseChanges(null,config.startUrl||"http://_empty_/",this.baseHref);this.urlChanges[0]={...parsedChanges}}}get hostname(){return this.urlChanges[this.urlChangeIndex].hostname}get protocol(){return this.urlChanges[this.urlChangeIndex].protocol}get port(){return this.urlChanges[this.urlChangeIndex].port}get pathname(){return this.urlChanges[this.urlChangeIndex].pathname}get search(){return this.urlChanges[this.urlChangeIndex].search}get hash(){return this.urlChanges[this.urlChangeIndex].hash}get state(){return this.urlChanges[this.urlChangeIndex].state}getBaseHrefFromDOM(){return this.baseHref}onPopState(fn){const subscription=this.popStateSubject.subscribe(fn);return()=>subscription.unsubscribe()}onHashChange(fn){const subscription=this.hashUpdate.subscribe(fn);return()=>subscription.unsubscribe()}get href(){let url=`${this.protocol}//${this.hostname}${this.port?":"+this.port:""}`;return url+=`${"/"===this.pathname?"":this.pathname}${this.search}${this.hash}`,url}get url(){return`${this.pathname}${this.search}${this.hash}`}parseChanges(state,url,baseHref=""){return state=JSON.parse(JSON.stringify(state)),{...parseUrl(url,baseHref),state}}replaceState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChanges[this.urlChangeIndex]={...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}}pushState(state,title,newUrl){const{pathname,search,state:parsedState,hash}=this.parseChanges(state,newUrl);this.urlChangeIndex>0&&this.urlChanges.splice(this.urlChangeIndex+1),this.urlChanges.push({...this.urlChanges[this.urlChangeIndex],pathname,search,hash,state:parsedState}),this.urlChangeIndex=this.urlChanges.length-1}forward(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex<this.urlChanges.length&&this.urlChangeIndex++,this.emitEvents(oldHash,oldUrl)}back(){const oldUrl=this.url,oldHash=this.hash;this.urlChangeIndex>0&&this.urlChangeIndex--,this.emitEvents(oldHash,oldUrl)}historyGo(relativePosition=0){const oldUrl=this.url,oldHash=this.hash,nextPageIndex=this.urlChangeIndex+relativePosition;nextPageIndex>=0&&nextPageIndex<this.urlChanges.length&&(this.urlChangeIndex=nextPageIndex),this.emitEvents(oldHash,oldUrl)}getState(){return this.state}emitEvents(oldHash,oldUrl){this.popStateSubject.next({type:"popstate",state:this.getState(),oldUrl,newUrl:this.url}),oldHash!==this.hash&&this.hashUpdate.next({type:"hashchange",state:null,oldUrl,newUrl:this.url})}static#_=this.ɵfac=function MockPlatformLocation_Factory(t){return new(t||MockPlatformLocation)(core["ɵɵinject"](MOCK_PLATFORM_LOCATION_CONFIG,8))};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:MockPlatformLocation,factory:MockPlatformLocation.ɵfac})}function provideLocationMocks(){return[{provide:common.Location,useClass:SpyLocation},{provide:common.LocationStrategy,useClass:MockLocationStrategy}]}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](MockPlatformLocation,[{type:core.Injectable}],(function(){return[{type:void 0,decorators:[{type:core.Inject,args:[MOCK_PLATFORM_LOCATION_CONFIG]},{type:core.Optional}]}]}),null);var fesm2022_router=__webpack_require__("./node_modules/@angular/router/fesm2022/router.mjs"),compiler=__webpack_require__("./node_modules/@angular/compiler/fesm2022/compiler.mjs");__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Subscription.js");class ComponentFixture{constructor(componentRef,ngZone,_autoDetect){this.componentRef=componentRef,this.ngZone=ngZone,this._autoDetect=_autoDetect,this._isStable=!0,this._isDestroyed=!1,this._resolve=null,this._promise=null,this._onUnstableSubscription=null,this._onStableSubscription=null,this._onMicrotaskEmptySubscription=null,this._onErrorSubscription=null,this.changeDetectorRef=componentRef.changeDetectorRef,this.elementRef=componentRef.location,this.debugElement=(0,core.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=componentRef.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=componentRef,this.ngZone=ngZone,ngZone&&ngZone.runOutsideAngular((()=>{this._onUnstableSubscription=ngZone.onUnstable.subscribe({next:()=>{this._isStable=!1}}),this._onMicrotaskEmptySubscription=ngZone.onMicrotaskEmpty.subscribe({next:()=>{this._autoDetect&&this.detectChanges(!0)}}),this._onStableSubscription=ngZone.onStable.subscribe({next:()=>{this._isStable=!0,null!==this._promise&&function scheduleMicroTask(fn){Zone.current.scheduleMicroTask("scheduleMicrotask",fn)}((()=>{ngZone.hasPendingMacrotasks||null!==this._promise&&(this._resolve(!0),this._resolve=null,this._promise=null)}))}}),this._onErrorSubscription=ngZone.onError.subscribe({next:error=>{throw error}})}))}_tick(checkNoChanges){this.changeDetectorRef.detectChanges(),checkNoChanges&&this.checkNoChanges()}detectChanges(checkNoChanges=!0){null!=this.ngZone?this.ngZone.run((()=>{this._tick(checkNoChanges)})):this._tick(checkNoChanges)}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}autoDetectChanges(autoDetect=!0){if(null==this.ngZone)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set");this._autoDetect=autoDetect,this.detectChanges()}isStable(){return this._isStable&&!this.ngZone.hasPendingMacrotasks}whenStable(){return this.isStable()?Promise.resolve(!1):(null!==this._promise||(this._promise=new Promise((res=>{this._resolve=res}))),this._promise)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(core.RendererFactory2,null)),this._renderer}whenRenderingDone(){const renderer=this._getRenderer();return renderer&&renderer.whenRenderingDone?renderer.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),null!=this._onUnstableSubscription&&(this._onUnstableSubscription.unsubscribe(),this._onUnstableSubscription=null),null!=this._onStableSubscription&&(this._onStableSubscription.unsubscribe(),this._onStableSubscription=null),null!=this._onMicrotaskEmptySubscription&&(this._onMicrotaskEmptySubscription.unsubscribe(),this._onMicrotaskEmptySubscription=null),null!=this._onErrorSubscription&&(this._onErrorSubscription.unsubscribe(),this._onErrorSubscription=null),this._isDestroyed=!0)}}const _Zone="undefined"!=typeof Zone?Zone:null,fakeAsyncTestModule=_Zone&&_Zone[_Zone.__symbol__("fakeAsyncTest")],fakeAsyncTestModuleNotLoadedErrorMessage="zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing";class TestComponentRenderer{insertRootElement(rootElementId){}removeAllRootElements(){}}const ComponentFixtureAutoDetect=new core.InjectionToken("ComponentFixtureAutoDetect"),ComponentFixtureNoNgZone=new core.InjectionToken("ComponentFixtureNoNgZone");function resolveComponentResources(resourceResolver){const componentResolved=[],urlMap=new Map;function cachedResourceResolve(url){let promise=urlMap.get(url);if(!promise){const resp=resourceResolver(url);urlMap.set(url,promise=resp.then(unwrapResponse))}return promise}return componentResourceResolutionQueue.forEach(((component,type)=>{const promises=[];component.templateUrl&&promises.push(cachedResourceResolve(component.templateUrl).then((template=>{component.template=template})));const styleUrls=component.styleUrls,styles=component.styles||(component.styles=[]),styleOffset=component.styles.length;styleUrls&&styleUrls.forEach(((styleUrl,index)=>{styles.push(""),promises.push(cachedResourceResolve(styleUrl).then((style=>{styles[styleOffset+index]=style,styleUrls.splice(styleUrls.indexOf(styleUrl),1),0==styleUrls.length&&(component.styleUrls=void 0)})))}));const fullyResolved=Promise.all(promises).then((()=>function componentDefResolved(type){componentDefPendingResolution.delete(type)}(type)));componentResolved.push(fullyResolved)})),clearResolutionOfComponentResourcesQueue(),Promise.all(componentResolved).then((()=>{}))}let componentResourceResolutionQueue=new Map;const componentDefPendingResolution=new Set;function isComponentDefPendingResolution(type){return componentDefPendingResolution.has(type)}function clearResolutionOfComponentResourcesQueue(){const old=componentResourceResolutionQueue;return componentResourceResolutionQueue=new Map,old}function unwrapResponse(response){return"string"==typeof response?response:response.text()}const _global$1=(()=>"undefined"!=typeof globalThis&&globalThis||void 0!==__webpack_require__.g&&__webpack_require__.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self)();var FactoryTarget,R3TemplateDependencyKind,ViewEncapsulation$1;function getCompilerFacade(request){const globalNg=_global$1.ng;if(globalNg&&globalNg.ɵcompilerFacade)return globalNg.ɵcompilerFacade;if("undefined"==typeof ngDevMode||ngDevMode){console.error(`JIT compilation failed for ${request.kind}`,request.type);let message=`The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;throw 1===request.usage?(message+=`The ${request.kind} is part of a library that has been partially compiled.\n`,message+="However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n",message+="\n",message+="Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n"):message+="JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n",message+="Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n",message+="or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.",new Error(message)}throw new Error("JIT compiler unavailable")}function getClosureSafeProperty(objWithPropertyToExtract){for(let key in objWithPropertyToExtract)if(objWithPropertyToExtract[key]===getClosureSafeProperty)return key;throw Error("Could not find renamed property on target object.")}function stringify(token){if("string"==typeof token)return token;if(Array.isArray(token))return"["+token.map(stringify).join(", ")+"]";if(null==token)return""+token;if(token.overriddenName)return`${token.overriddenName}`;if(token.name)return`${token.name}`;const res=token.toString();if(null==res)return""+res;const newLineIndex=res.indexOf("\n");return-1===newLineIndex?res:res.substring(0,newLineIndex)}function concatStringsWithSpace(before,after){return null==before||""===before?null===after?"":after:null==after||""===after?before:before+" "+after}!function(FactoryTarget){FactoryTarget[FactoryTarget.Directive=0]="Directive",FactoryTarget[FactoryTarget.Component=1]="Component",FactoryTarget[FactoryTarget.Injectable=2]="Injectable",FactoryTarget[FactoryTarget.Pipe=3]="Pipe",FactoryTarget[FactoryTarget.NgModule=4]="NgModule"}(FactoryTarget||(FactoryTarget={})),function(R3TemplateDependencyKind){R3TemplateDependencyKind[R3TemplateDependencyKind.Directive=0]="Directive",R3TemplateDependencyKind[R3TemplateDependencyKind.Pipe=1]="Pipe",R3TemplateDependencyKind[R3TemplateDependencyKind.NgModule=2]="NgModule"}(R3TemplateDependencyKind||(R3TemplateDependencyKind={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation$1||(ViewEncapsulation$1={}));const __forward_ref__=getClosureSafeProperty({__forward_ref__:getClosureSafeProperty});function forwardRef(forwardRefFn){return forwardRefFn.__forward_ref__=forwardRef,forwardRefFn.toString=function(){return stringify(this())},forwardRefFn}function resolveForwardRef(type){return isForwardRef(type)?type():type}function isForwardRef(fn){return"function"==typeof fn&&fn.hasOwnProperty(__forward_ref__)&&fn.__forward_ref__===forwardRef}function ɵɵdefineInjectable(opts){return{token:opts.token,providedIn:opts.providedIn||null,factory:opts.factory,value:void 0}}function ɵɵdefineInjector(options){return{providers:options.providers||[],imports:options.imports||[]}}function getInjectableDef(type){return getOwnDefinition(type,NG_PROV_DEF)||getOwnDefinition(type,NG_INJECTABLE_DEF)}function getOwnDefinition(type,field){return type.hasOwnProperty(field)?type[field]:null}function getInjectorDef(type){return type&&(type.hasOwnProperty(NG_INJ_DEF)||type.hasOwnProperty(NG_INJECTOR_DEF))?type[NG_INJ_DEF]:null}const NG_PROV_DEF=getClosureSafeProperty({ɵprov:getClosureSafeProperty}),NG_INJ_DEF=getClosureSafeProperty({ɵinj:getClosureSafeProperty}),NG_INJECTABLE_DEF=getClosureSafeProperty({ngInjectableDef:getClosureSafeProperty}),NG_INJECTOR_DEF=getClosureSafeProperty({ngInjectorDef:getClosureSafeProperty}),ERROR_DETAILS_PAGE_BASE_URL="https://angular.io/errors";class RuntimeError extends Error{constructor(code,message){super(formatRuntimeError(code,message)),this.code=code}}function formatRuntimeError(code,message){const fullCode=`NG0${Math.abs(code)}`;let errorMessage=`${fullCode}${message?": "+message:""}`;if(ngDevMode&&code<0){const addPeriodSeparator=!errorMessage.match(/[.,;!?\n]$/);errorMessage=`${errorMessage}${addPeriodSeparator?".":""} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`}return errorMessage}const Type=Function;function isType(v){return"function"==typeof v}function assertNumber(actual,msg){"number"!=typeof actual&&throwError(msg,typeof actual,"number","===")}function assertString(actual,msg){"string"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"string","===")}function assertFunction(actual,msg){"function"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"function","===")}function assertEqual(actual,expected,msg){actual!=expected&&throwError(msg,actual,expected,"==")}function assertNotEqual(actual,expected,msg){actual==expected&&throwError(msg,actual,expected,"!=")}function assertSame(actual,expected,msg){actual!==expected&&throwError(msg,actual,expected,"===")}function assertNotSame(actual,expected,msg){actual===expected&&throwError(msg,actual,expected,"!==")}function assertLessThan(actual,expected,msg){actual<expected||throwError(msg,actual,expected,"<")}function assertGreaterThan(actual,expected,msg){actual>expected||throwError(msg,actual,expected,">")}function assertGreaterThanOrEqual(actual,expected,msg){actual>=expected||throwError(msg,actual,expected,">=")}function assertDefined(actual,msg){null==actual&&throwError(msg,actual,null,"!=")}function throwError(msg,actual,expected,comparison){throw new Error(`ASSERTION ERROR: ${msg}`+(null==comparison?"":` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`))}function assertIndexInRange(arr,index){assertDefined(arr,"Array must be defined.");const maxLen=arr.length;(index<0||index>=maxLen)&&throwError(`Index expected to be less than ${maxLen} but got ${index}`)}function deepForEach(input,fn){input.forEach((value=>Array.isArray(value)?deepForEach(value,fn):fn(value)))}function addToArray(arr,index,value){index>=arr.length?arr.push(value):arr.splice(index,0,value)}function removeFromArray(arr,index){return index>=arr.length-1?arr.pop():arr.splice(index,1)[0]}function newArray(size,value){const list=[];for(let i=0;i<size;i++)list.push(value);return list}function noSideEffects(fn){return{toString:fn}.toString()}const ANNOTATIONS="__annotations__",PARAMETERS="__parameters__",PROP_METADATA="__prop__metadata__";function makeMetadataCtor(props){return function ctor(...args){if(props){const values=props(...args);for(const propName in values)this[propName]=values[propName]}}}function makeParamDecorator(name,props,parentClass){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function ParamDecoratorFactory(...args){if(this instanceof ParamDecoratorFactory)return metaCtor.apply(this,args),this;const annotationInstance=new ParamDecoratorFactory(...args);return ParamDecorator.annotation=annotationInstance,ParamDecorator;function ParamDecorator(cls,unusedKey,index){const parameters=cls.hasOwnProperty(PARAMETERS)?cls[PARAMETERS]:Object.defineProperty(cls,PARAMETERS,{value:[]})[PARAMETERS];for(;parameters.length<=index;)parameters.push(null);return(parameters[index]=parameters[index]||[]).push(annotationInstance),cls}}return parentClass&&(ParamDecoratorFactory.prototype=Object.create(parentClass.prototype)),ParamDecoratorFactory.prototype.ngMetadataName=name,ParamDecoratorFactory.annotationCls=ParamDecoratorFactory,ParamDecoratorFactory}))}const ES5_DELEGATE_CTOR=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,ES2015_INHERITED_CLASS=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,ES2015_INHERITED_CLASS_WITH_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;class ReflectionCapabilities{constructor(reflect){this._reflect=reflect||_global$1.Reflect}factory(t){return(...args)=>new t(...args)}_zipTypesAndAnnotations(paramTypes,paramAnnotations){let result;result=newArray(void 0===paramTypes?paramAnnotations.length:paramTypes.length);for(let i=0;i<result.length;i++)void 0===paramTypes?result[i]=[]:paramTypes[i]&&paramTypes[i]!=Object?result[i]=[paramTypes[i]]:result[i]=[],paramAnnotations&&null!=paramAnnotations[i]&&(result[i]=result[i].concat(paramAnnotations[i]));return result}_ownParameters(type,parentCtor){if(function isDelegateCtor(typeStr){return ES5_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS.test(typeStr)&&!ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)}(type.toString()))return null;if(type.parameters&&type.parameters!==parentCtor.parameters)return type.parameters;const tsickleCtorParams=type.ctorParameters;if(tsickleCtorParams&&tsickleCtorParams!==parentCtor.ctorParameters){const ctorParameters="function"==typeof tsickleCtorParams?tsickleCtorParams():tsickleCtorParams,paramTypes=ctorParameters.map((ctorParam=>ctorParam&&ctorParam.type)),paramAnnotations=ctorParameters.map((ctorParam=>ctorParam&&convertTsickleDecoratorIntoMetadata(ctorParam.decorators)));return this._zipTypesAndAnnotations(paramTypes,paramAnnotations)}const paramAnnotations=type.hasOwnProperty(PARAMETERS)&&type[PARAMETERS],paramTypes=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",type);return paramTypes||paramAnnotations?this._zipTypesAndAnnotations(paramTypes,paramAnnotations):newArray(type.length)}parameters(type){if(!isType(type))return[];const parentCtor=getParentCtor(type);let parameters=this._ownParameters(type,parentCtor);return parameters||parentCtor===Object||(parameters=this.parameters(parentCtor)),parameters||[]}_ownAnnotations(typeOrFunc,parentCtor){if(typeOrFunc.annotations&&typeOrFunc.annotations!==parentCtor.annotations){let annotations=typeOrFunc.annotations;return"function"==typeof annotations&&annotations.annotations&&(annotations=annotations.annotations),annotations}return typeOrFunc.decorators&&typeOrFunc.decorators!==parentCtor.decorators?convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators):typeOrFunc.hasOwnProperty(ANNOTATIONS)?typeOrFunc[ANNOTATIONS]:null}annotations(typeOrFunc){if(!isType(typeOrFunc))return[];const parentCtor=getParentCtor(typeOrFunc),ownAnnotations=this._ownAnnotations(typeOrFunc,parentCtor)||[];return(parentCtor!==Object?this.annotations(parentCtor):[]).concat(ownAnnotations)}_ownPropMetadata(typeOrFunc,parentCtor){if(typeOrFunc.propMetadata&&typeOrFunc.propMetadata!==parentCtor.propMetadata){let propMetadata=typeOrFunc.propMetadata;return"function"==typeof propMetadata&&propMetadata.propMetadata&&(propMetadata=propMetadata.propMetadata),propMetadata}if(typeOrFunc.propDecorators&&typeOrFunc.propDecorators!==parentCtor.propDecorators){const propDecorators=typeOrFunc.propDecorators,propMetadata={};return Object.keys(propDecorators).forEach((prop=>{propMetadata[prop]=convertTsickleDecoratorIntoMetadata(propDecorators[prop])})),propMetadata}return typeOrFunc.hasOwnProperty(PROP_METADATA)?typeOrFunc[PROP_METADATA]:null}propMetadata(typeOrFunc){if(!isType(typeOrFunc))return{};const parentCtor=getParentCtor(typeOrFunc),propMetadata={};if(parentCtor!==Object){const parentPropMetadata=this.propMetadata(parentCtor);Object.keys(parentPropMetadata).forEach((propName=>{propMetadata[propName]=parentPropMetadata[propName]}))}const ownPropMetadata=this._ownPropMetadata(typeOrFunc,parentCtor);return ownPropMetadata&&Object.keys(ownPropMetadata).forEach((propName=>{const decorators=[];propMetadata.hasOwnProperty(propName)&&decorators.push(...propMetadata[propName]),decorators.push(...ownPropMetadata[propName]),propMetadata[propName]=decorators})),propMetadata}ownPropMetadata(typeOrFunc){return isType(typeOrFunc)&&this._ownPropMetadata(typeOrFunc,getParentCtor(typeOrFunc))||{}}hasLifecycleHook(type,lcProperty){return type instanceof Type&&lcProperty in type.prototype}}function convertTsickleDecoratorIntoMetadata(decoratorInvocations){return decoratorInvocations?decoratorInvocations.map((decoratorInvocation=>new(0,decoratorInvocation.type.annotationCls)(...decoratorInvocation.args?decoratorInvocation.args:[]))):[]}function getParentCtor(ctor){const parentProto=ctor.prototype?Object.getPrototypeOf(ctor.prototype):null;return(parentProto?parentProto.constructor:null)||Object}function initNgDevMode(){return!("undefined"!=typeof ngDevMode&&!ngDevMode)&&("object"!=typeof ngDevMode&&function ngDevModeResetPerfCounters(){const locationString="undefined"!=typeof location?location.toString():"",newCounters={namedConstructors:-1!=locationString.indexOf("ngDevMode=namedConstructors"),firstCreatePass:0,tNode:0,tView:0,rendererCreateTextNode:0,rendererSetText:0,rendererCreateElement:0,rendererAddEventListener:0,rendererSetAttribute:0,rendererRemoveAttribute:0,rendererSetProperty:0,rendererSetClassName:0,rendererAddClass:0,rendererRemoveClass:0,rendererSetStyle:0,rendererRemoveStyle:0,rendererDestroy:0,rendererDestroyNode:0,rendererMoveNode:0,rendererRemoveNode:0,rendererAppendChild:0,rendererInsertBefore:0,rendererCreateComment:0,hydratedNodes:0,hydratedComponents:0,dehydratedViewsRemoved:0,dehydratedViewsCleanupRuns:0,componentsSkippedHydration:0},allowNgDevModeTrue=-1===locationString.indexOf("ngDevMode=false");return _global$1.ngDevMode=allowNgDevModeTrue&&newCounters,newCounters}(),"undefined"!=typeof ngDevMode&&!!ngDevMode)}function isEnvironmentProviders(value){return value&&!!value.ɵproviders}function renderStringify(value){return"string"==typeof value?value:null==value?"":String(value)}function stringifyForError(value){return"function"==typeof value?value.name||value.toString():"object"==typeof value&&null!=value&&"function"==typeof value.type?value.type.name||value.type.toString():renderStringify(value)}function throwCyclicDependencyError(token,path){const depPath=path?`. Dependency path: ${path.join(" > ")} > ${token}`:"";throw new RuntimeError(-200,`Circular dependency in DI detected for ${token}${depPath}`)}function throwMixedMultiProviderError(){throw new Error("Cannot mix multi providers and regular providers")}function throwInvalidProviderError(ngModuleType,providers,provider){if(ngModuleType&&providers){const providerDetail=providers.map((v=>v==provider?"?"+provider+"?":"..."));throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`)}throw isEnvironmentProviders(provider)?provider.ɵfromNgModule?new RuntimeError(207,"Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers."):new RuntimeError(207,"Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers."):new Error("Invalid provider")}function throwProviderNotFoundError(token,injectorName){const injectorDetails=injectorName?` in ${injectorName}`:"";throw new RuntimeError(-201,ngDevMode&&`No provider for ${stringifyForError(token)} found${injectorDetails}`)}var InjectFlags;let _injectImplementation;function getInjectImplementation(){return _injectImplementation}function setInjectImplementation(impl){const previous=_injectImplementation;return _injectImplementation=impl,previous}function injectRootLimpMode(token,notFoundValue,flags){const injectableDef=getInjectableDef(token);return injectableDef&&"root"==injectableDef.providedIn?void 0===injectableDef.value?injectableDef.value=injectableDef.factory():injectableDef.value:flags&InjectFlags.Optional?null:void 0!==notFoundValue?notFoundValue:void throwProviderNotFoundError(stringify(token),"Injector")}!function(InjectFlags){InjectFlags[InjectFlags.Default=0]="Default",InjectFlags[InjectFlags.Host=1]="Host",InjectFlags[InjectFlags.Self=2]="Self",InjectFlags[InjectFlags.SkipSelf=4]="SkipSelf",InjectFlags[InjectFlags.Optional=8]="Optional"}(InjectFlags||(InjectFlags={}));const THROW_IF_NOT_FOUND={},DI_DECORATOR_FLAG="__NG_DI_FLAG__",NEW_LINE=/\n/gm,NO_NEW_LINE="ɵ";let _currentInjector;function setCurrentInjector(injector){const former=_currentInjector;return _currentInjector=injector,former}function injectInjectorOnly(token,flags=InjectFlags.Default){if(void 0===_currentInjector)throw new RuntimeError(-203,ngDevMode&&"inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`.");return null===_currentInjector?injectRootLimpMode(token,void 0,flags):_currentInjector.get(token,flags&InjectFlags.Optional?null:void 0,flags)}function ɵɵinject(token,flags=InjectFlags.Default){return(getInjectImplementation()||injectInjectorOnly)(resolveForwardRef(token),flags)}function ɵɵinvalidFactoryDep(index){throw new RuntimeError(202,ngDevMode&&`This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`)}function inject$1(token,flags=InjectFlags.Default){return ɵɵinject(token,convertToBitFlags(flags))}function convertToBitFlags(flags){return void 0===flags||"number"==typeof flags?flags:0|(flags.optional&&8)|(flags.host&&1)|(flags.self&&2)|(flags.skipSelf&&4)}function injectArgs(types){const args=[];for(let i=0;i<types.length;i++){const arg=resolveForwardRef(types[i]);if(Array.isArray(arg)){if(0===arg.length)throw new RuntimeError(900,ngDevMode&&"Arguments array must have arguments.");let type,flags=InjectFlags.Default;for(let j=0;j<arg.length;j++){const meta=arg[j],flag=meta[DI_DECORATOR_FLAG];"number"==typeof flag?-1===flag?type=meta.token:flags|=flag:type=meta}args.push(ɵɵinject(type,flags))}else args.push(ɵɵinject(arg))}return args}function attachInjectFlag(decorator,flag){return decorator[DI_DECORATOR_FLAG]=flag,decorator.prototype[DI_DECORATOR_FLAG]=flag,decorator}function catchInjectorError(e,token,injectorErrorName,source){const tokenPath=e.ngTempTokenPath;throw token.__source&&tokenPath.unshift(token.__source),e.message=function formatError(text,obj,injectorErrorName,source=null){text=text&&"\n"===text.charAt(0)&&text.charAt(1)==NO_NEW_LINE?text.slice(2):text;let context=stringify(obj);if(Array.isArray(obj))context=obj.map(stringify).join(" -> ");else if("object"==typeof obj){let parts=[];for(let key in obj)if(obj.hasOwnProperty(key)){let value=obj[key];parts.push(key+":"+("string"==typeof value?JSON.stringify(value):stringify(value)))}context=`{${parts.join(", ")}}`}return`${injectorErrorName}${source?"("+source+")":""}[${context}]: ${text.replace(NEW_LINE,"\n  ")}`}("\n"+e.message,tokenPath,injectorErrorName,source),e.ngTokenPath=tokenPath,e.ngTempTokenPath=null,e}const Inject=attachInjectFlag(makeParamDecorator("Inject",(token=>({token}))),-1),Optional=attachInjectFlag(makeParamDecorator("Optional"),8),Self=attachInjectFlag(makeParamDecorator("Self"),2),SkipSelf=attachInjectFlag(makeParamDecorator("SkipSelf"),4),Host=attachInjectFlag(makeParamDecorator("Host"),1);var ChangeDetectionStrategy,ViewEncapsulation;!function(ChangeDetectionStrategy){ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush=0]="OnPush",ChangeDetectionStrategy[ChangeDetectionStrategy.Default=1]="Default"}(ChangeDetectionStrategy||(ChangeDetectionStrategy={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation||(ViewEncapsulation={}));const EMPTY_OBJ={},EMPTY_ARRAY=[];("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode()&&(Object.freeze(EMPTY_OBJ),Object.freeze(EMPTY_ARRAY));const NG_COMP_DEF=getClosureSafeProperty({ɵcmp:getClosureSafeProperty}),NG_FACTORY_DEF=(getClosureSafeProperty({ɵdir:getClosureSafeProperty}),getClosureSafeProperty({ɵpipe:getClosureSafeProperty}),getClosureSafeProperty({ɵmod:getClosureSafeProperty}),getClosureSafeProperty({ɵfac:getClosureSafeProperty})),NG_ELEMENT_ID=getClosureSafeProperty({__NG_ELEMENT_ID__:getClosureSafeProperty}),NG_ENV_ID=getClosureSafeProperty({__NG_ENV_ID__:getClosureSafeProperty});function setUpAttributes(renderer,native,attrs){let i=0;for(;i<attrs.length;){const value=attrs[i];if("number"==typeof value){if(0!==value)break;i++;const namespaceURI=attrs[i++],attrName=attrs[i++],attrVal=attrs[i++];ngDevMode&&ngDevMode.rendererSetAttribute++,renderer.setAttribute(native,attrName,attrVal,namespaceURI)}else{const attrName=value,attrVal=attrs[++i];ngDevMode&&ngDevMode.rendererSetAttribute++,isAnimationProp(attrName)?renderer.setProperty(native,attrName,attrVal):renderer.setAttribute(native,attrName,attrVal),i++}}return i}function isNameOnlyAttributeMarker(marker){return 3===marker||4===marker||6===marker}function isAnimationProp(name){return 64===name.charCodeAt(0)}function mergeHostAttrs(dst,src){if(null===src||0===src.length);else if(null===dst||0===dst.length)dst=src.slice();else{let srcMarker=-1;for(let i=0;i<src.length;i++){const item=src[i];"number"==typeof item?srcMarker=item:0===srcMarker||mergeHostAttribute(dst,srcMarker,item,null,-1===srcMarker||2===srcMarker?src[++i]:null)}}return dst}function mergeHostAttribute(dst,marker,key1,key2,value){let i=0,markerInsertPosition=dst.length;if(-1===marker)markerInsertPosition=-1;else for(;i<dst.length;){const dstValue=dst[i++];if("number"==typeof dstValue){if(dstValue===marker){markerInsertPosition=-1;break}if(dstValue>marker){markerInsertPosition=i-1;break}}}for(;i<dst.length;){const item=dst[i];if("number"==typeof item)break;if(item===key1){if(null===key2)return void(null!==value&&(dst[i+1]=value));if(key2===dst[i+1])return void(dst[i+2]=value)}i++,null!==key2&&i++,null!==value&&i++}-1!==markerInsertPosition&&(dst.splice(markerInsertPosition,0,marker),i=markerInsertPosition+1),dst.splice(i++,0,key1),null!==key2&&dst.splice(i++,0,key2),null!==value&&dst.splice(i++,0,value)}const NG_TEMPLATE_SELECTOR="ng-template";function isInlineTemplate(tNode){return 4===tNode.type&&tNode.value!==NG_TEMPLATE_SELECTOR}function isPositive(mode){return 0==(1&mode)}function maybeWrapInNotSelector(isNegativeMode,chunk){return isNegativeMode?":not("+chunk.trim()+")":chunk}function stringifyCSSSelector(selector){let result=selector[0],i=1,mode=2,currentChunk="",isNegativeMode=!1;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)if(2&mode){const attrValue=selector[++i];currentChunk+="["+valueOrMarker+(attrValue.length>0?'="'+attrValue+'"':"")+"]"}else 8&mode?currentChunk+="."+valueOrMarker:4&mode&&(currentChunk+=" "+valueOrMarker);else""===currentChunk||isPositive(valueOrMarker)||(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk),currentChunk=""),mode=valueOrMarker,isNegativeMode=isNegativeMode||!isPositive(mode);i++}return""!==currentChunk&&(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk)),result}function stringifyCSSSelectorList(selectorList){return selectorList.map(stringifyCSSSelector).join(",")}function getComponentDef$1(type){return type[NG_COMP_DEF]||null}new Map;const HOST=0,TVIEW=1,FLAGS=2,PARENT=3,NEXT=4,DESCENDANT_VIEWS_TO_REFRESH=5,T_HOST=6,CLEANUP=7,CONTEXT=8,INJECTOR$1=9,ENVIRONMENT=10,RENDERER=11,CHILD_HEAD=12,CHILD_TAIL=13,DECLARATION_VIEW=14,DECLARATION_COMPONENT_VIEW=15,DECLARATION_LCONTAINER=16,PREORDER_HOOK_FLAGS=17,QUERIES=18,ID=19,EMBEDDED_VIEW_INJECTOR=20,ON_DESTROY_HOOKS=21,HYDRATION=22,REACTIVE_TEMPLATE_CONSUMER=23,REACTIVE_HOST_BINDING_CONSUMER=24,HEADER_OFFSET=25,TYPE=1,HAS_TRANSPLANTED_VIEWS=2,NATIVE=7,MOVED_VIEWS=9,CONTAINER_HEADER_OFFSET=11;function isLView(value){return Array.isArray(value)&&"object"==typeof value[TYPE]}function isLContainer(value){return Array.isArray(value)&&!0===value[TYPE]}function isContentQueryHost(tNode){return 0!=(4&tNode.flags)}function isComponentHost(tNode){return tNode.componentOffset>-1}function isComponentDef(def){return!!def.template}function isRootView(target){return 0!=(512&target[FLAGS])}function assertTNodeForLView(tNode,lView){assertTNodeForTView(tNode,lView[TVIEW])}function assertTNodeForTView(tNode,tView){assertTNode(tNode),tNode.hasOwnProperty("tView_")&&assertEqual(tNode.tView_,tView,"This TNode does not belong to this TView.")}function assertTNode(tNode){assertDefined(tNode,"TNode must be defined"),tNode&&"object"==typeof tNode&&tNode.hasOwnProperty("directiveStylingLast")||throwError("Not of type TNode, got: "+tNode)}function assertLContainer(value){assertDefined(value,"LContainer must be defined"),assertEqual(isLContainer(value),!0,"Expecting LContainer")}function assertLViewOrUndefined(value){value&&assertEqual(isLView(value),!0,"Expecting LView or undefined or null")}function assertLView(value){assertDefined(value,"LView must be defined"),assertEqual(isLView(value),!0,"Expecting LView")}function assertFirstCreatePass(tView,errMessage){assertEqual(tView.firstCreatePass,!0,errMessage||"Should only be called in first create pass.")}function assertFirstUpdatePass(tView,errMessage){assertEqual(tView.firstUpdatePass,!0,errMessage||"Should only be called in first update pass.")}function assertIndexInExpandoRange(lView,index){assertBetween(lView[1].expandoStartIndex,lView.length,index)}function assertBetween(lower,upper,index){lower<=index&&index<upper||throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`)}function assertParentView(lView,errMessage){assertDefined(lView,errMessage||"Component views should always have a parent view (component's host view)")}function assertNodeInjector(lView,injectorIndex){assertIndexInExpandoRange(lView,injectorIndex),assertIndexInExpandoRange(lView,injectorIndex+8),assertNumber(lView[injectorIndex+0],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+1],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+2],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+3],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+4],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+5],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+6],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+7],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+8],"injectorIndex should point to parent injector")}function getFactoryDef(type,throwNotFound){const hasFactoryDef=type.hasOwnProperty(NG_FACTORY_DEF);if(!hasFactoryDef&&!0===throwNotFound&&ngDevMode)throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);return hasFactoryDef?type[NG_FACTORY_DEF]:null}Symbol("SIGNAL");let WeakRefImpl=_global$1.WeakRef??class LeakyRef{constructor(ref){this.ref=ref}deref(){return this.ref}};let _nextReactiveId=0,activeConsumer=null,inNotificationPhase=!1;function setActiveConsumer(consumer){const prev=activeConsumer;return activeConsumer=consumer,prev}class ReactiveNode{constructor(){this.id=_nextReactiveId++,this.ref=function newWeakRef(value){if("undefined"!=typeof ngDevMode&&ngDevMode&&void 0===WeakRefImpl)throw new Error("Angular requires a browser which supports the 'WeakRef' API");return new WeakRefImpl(value)}(this),this.producers=new Map,this.consumers=new Map,this.trackingVersion=0,this.valueVersion=0}consumerPollProducersForChange(){for(const[producerId,edge]of this.producers){const producer=edge.producerNode.deref();if(void 0!==producer&&edge.atTrackingVersion===this.trackingVersion){if(producer.producerPollStatus(edge.seenValueVersion))return!0}else this.producers.delete(producerId),producer?.consumers.delete(this.id)}return!1}producerMayHaveChanged(){const prev=inNotificationPhase;inNotificationPhase=!0;try{for(const[consumerId,edge]of this.consumers){const consumer=edge.consumerNode.deref();void 0!==consumer&&consumer.trackingVersion===edge.atTrackingVersion?consumer.onConsumerDependencyMayHaveChanged():(this.consumers.delete(consumerId),consumer?.producers.delete(this.id))}}finally{inNotificationPhase=prev}}producerAccessed(){if(inNotificationPhase)throw new Error("undefined"!=typeof ngDevMode&&ngDevMode?"Assertion error: signal read during notification phase":"");if(null===activeConsumer)return;let edge=activeConsumer.producers.get(this.id);void 0===edge?(edge={consumerNode:activeConsumer.ref,producerNode:this.ref,seenValueVersion:this.valueVersion,atTrackingVersion:activeConsumer.trackingVersion},activeConsumer.producers.set(this.id,edge),this.consumers.set(activeConsumer.id,edge)):(edge.seenValueVersion=this.valueVersion,edge.atTrackingVersion=activeConsumer.trackingVersion)}get hasProducers(){return this.producers.size>0}get producerUpdatesAllowed(){return!1!==activeConsumer?.consumerAllowSignalWrites}producerPollStatus(lastSeenValueVersion){return this.valueVersion!==lastSeenValueVersion||(this.onProducerUpdateValueVersion(),this.valueVersion!==lastSeenValueVersion)}}Symbol("UNSET"),Symbol("COMPUTING"),Symbol("ERRORED");const NOOP_CLEANUP_FN=()=>{};class Watch extends ReactiveNode{constructor(watch,schedule,allowSignalWrites){super(),this.watch=watch,this.schedule=schedule,this.dirty=!1,this.cleanupFn=NOOP_CLEANUP_FN,this.registerOnCleanup=cleanupFn=>{this.cleanupFn=cleanupFn},this.consumerAllowSignalWrites=allowSignalWrites}notify(){this.dirty||this.schedule(this),this.dirty=!0}onConsumerDependencyMayHaveChanged(){this.notify()}onProducerUpdateValueVersion(){}run(){if(this.dirty=!1,0!==this.trackingVersion&&!this.consumerPollProducersForChange())return;const prevConsumer=setActiveConsumer(this);this.trackingVersion++;try{this.cleanupFn(),this.cleanupFn=NOOP_CLEANUP_FN,this.watch(this.registerOnCleanup)}finally{setActiveConsumer(prevConsumer)}}cleanup(){this.cleanupFn()}}class SimpleChange{constructor(previousValue,currentValue,firstChange){this.previousValue=previousValue,this.currentValue=currentValue,this.firstChange=firstChange}isFirstChange(){return this.firstChange}}function ɵɵNgOnChangesFeature(){return NgOnChangesFeatureImpl}function NgOnChangesFeatureImpl(definition){return definition.type.prototype.ngOnChanges&&(definition.setInput=ngOnChangesSetInput),rememberChangeHistoryAndInvokeOnChangesHook}function rememberChangeHistoryAndInvokeOnChangesHook(){const simpleChangesStore=getSimpleChangesStore(this),current=simpleChangesStore?.current;if(current){const previous=simpleChangesStore.previous;if(previous===EMPTY_OBJ)simpleChangesStore.previous=current;else for(let key in current)previous[key]=current[key];simpleChangesStore.current=null,this.ngOnChanges(current)}}function ngOnChangesSetInput(instance,value,publicName,privateName){const declaredName=this.declaredInputs[publicName];ngDevMode&&assertString(declaredName,"Name of input in ngOnChanges has to be a string");const simpleChangesStore=getSimpleChangesStore(instance)||function setSimpleChangesStore(instance,store){return instance[SIMPLE_CHANGES_STORE]=store}(instance,{previous:EMPTY_OBJ,current:null}),current=simpleChangesStore.current||(simpleChangesStore.current={}),previous=simpleChangesStore.previous,previousChange=previous[declaredName];current[declaredName]=new SimpleChange(previousChange&&previousChange.currentValue,value,previous===EMPTY_OBJ),instance[privateName]=value}ɵɵNgOnChangesFeature.ngInherit=!0;const SIMPLE_CHANGES_STORE="__ngSimpleChanges__";function getSimpleChangesStore(instance){return instance[SIMPLE_CHANGES_STORE]||null}let profilerCallback=null;const profiler=function(event,instance,hookOrListener){null!=profilerCallback&&profilerCallback(event,instance,hookOrListener)};function unwrapRNode(value){for(;Array.isArray(value);)value=value[HOST];return value}function getNativeByTNode(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertIndexInRange(lView,tNode.index);return unwrapRNode(lView[tNode.index])}function getTNode(tView,index){ngDevMode&&assertGreaterThan(index,-1,"wrong index for TNode"),ngDevMode&&assertLessThan(index,tView.data.length,"wrong index for TNode");const tNode=tView.data[index];return ngDevMode&&null!==tNode&&assertTNode(tNode),tNode}function getComponentLViewByIndex(nodeIndex,hostView){ngDevMode&&assertIndexInRange(hostView,nodeIndex);const slotValue=hostView[nodeIndex];return isLView(slotValue)?slotValue:slotValue[HOST]}function isCreationMode(view){return 4==(4&view[FLAGS])}function viewAttachedToChangeDetector(view){return 128==(128&view[FLAGS])}function resetPreOrderHookFlags(lView){lView[PREORDER_HOOK_FLAGS]=0}function markViewForRefresh(lView){0==(1024&lView[FLAGS])&&(lView[FLAGS]|=1024,updateViewsToRefresh(lView,1))}function clearViewRefreshFlag(lView){1024&lView[FLAGS]&&(lView[FLAGS]&=-1025,updateViewsToRefresh(lView,-1))}function updateViewsToRefresh(lView,amount){let parent=lView[PARENT];if(null===parent)return;parent[DESCENDANT_VIEWS_TO_REFRESH]+=amount;let viewOrContainer=parent;for(parent=parent[PARENT];null!==parent&&(1===amount&&1===viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH]||-1===amount&&0===viewOrContainer[DESCENDANT_VIEWS_TO_REFRESH]);)parent[DESCENDANT_VIEWS_TO_REFRESH]+=amount,viewOrContainer=parent,parent=parent[PARENT]}function storeLViewOnDestroy(lView,onDestroyCallback){if(256==(256&lView[FLAGS]))throw new RuntimeError(911,ngDevMode&&"View has already been destroyed.");null===lView[ON_DESTROY_HOOKS]&&(lView[ON_DESTROY_HOOKS]=[]),lView[ON_DESTROY_HOOKS].push(onDestroyCallback)}const instructionState={lFrame:createLFrame(null),bindingsEnabled:!0,skipHydrationRootTNode:null};let _isInCheckNoChangesMode=!1;function getLView(){return instructionState.lFrame.lView}function getTView(){return instructionState.lFrame.tView}function getCurrentTNode(){let currentTNode=getCurrentTNodePlaceholderOk();for(;null!==currentTNode&&64===currentTNode.type;)currentTNode=currentTNode.parent;return currentTNode}function getCurrentTNodePlaceholderOk(){return instructionState.lFrame.currentTNode}function getCurrentParentTNode(){const lFrame=instructionState.lFrame,currentTNode=lFrame.currentTNode;return lFrame.isParent?currentTNode:currentTNode.parent}function setCurrentTNode(tNode,isParent){ngDevMode&&tNode&&assertTNodeForTView(tNode,instructionState.lFrame.tView);const lFrame=instructionState.lFrame;lFrame.currentTNode=tNode,lFrame.isParent=isParent}function isCurrentTNodeParent(){return instructionState.lFrame.isParent}function isInCheckNoChangesMode(){return!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode}function setIsInCheckNoChangesMode(mode){!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode=mode}function setBindingIndex(value){return instructionState.lFrame.bindingIndex=value}function setBindingRootForHostBindings(bindingRootIndex,currentDirectiveIndex){const lFrame=instructionState.lFrame;lFrame.bindingIndex=lFrame.bindingRootIndex=bindingRootIndex,setCurrentDirectiveIndex(currentDirectiveIndex)}function setCurrentDirectiveIndex(currentDirectiveIndex){instructionState.lFrame.currentDirectiveIndex=currentDirectiveIndex}function setCurrentQueryIndex(value){instructionState.lFrame.currentQueryIndex=value}function getDeclarationTNode(lView){const tView=lView[TVIEW];return 2===tView.type?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tView.type?lView[T_HOST]:null}function enterDI(lView,tNode,flags){if(ngDevMode&&assertLViewOrUndefined(lView),flags&InjectFlags.SkipSelf){ngDevMode&&assertTNodeForTView(tNode,lView[TVIEW]);let parentTNode=tNode,parentLView=lView;for(;!(ngDevMode&&assertDefined(parentTNode,"Parent TNode should be defined"),parentTNode=parentTNode.parent,null!==parentTNode||flags&InjectFlags.Host||(parentTNode=getDeclarationTNode(parentLView),null===parentTNode)||(ngDevMode&&assertDefined(parentLView,"Parent LView should be defined"),parentLView=parentLView[DECLARATION_VIEW],10&parentTNode.type)););if(null===parentTNode)return!1;tNode=parentTNode,lView=parentLView}ngDevMode&&assertTNodeForLView(tNode,lView);const lFrame=instructionState.lFrame=allocLFrame();return lFrame.currentTNode=tNode,lFrame.lView=lView,!0}function enterView(newView){ngDevMode&&assertNotEqual(newView[0],newView[1],"????"),ngDevMode&&assertLViewOrUndefined(newView);const newLFrame=allocLFrame();ngDevMode&&(assertEqual(newLFrame.isParent,!0,"Expected clean LFrame"),assertEqual(newLFrame.lView,null,"Expected clean LFrame"),assertEqual(newLFrame.tView,null,"Expected clean LFrame"),assertEqual(newLFrame.selectedIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.elementDepthCount,0,"Expected clean LFrame"),assertEqual(newLFrame.currentDirectiveIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentNamespace,null,"Expected clean LFrame"),assertEqual(newLFrame.bindingRootIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentQueryIndex,0,"Expected clean LFrame"));const tView=newView[TVIEW];instructionState.lFrame=newLFrame,ngDevMode&&tView.firstChild&&assertTNodeForTView(tView.firstChild,tView),newLFrame.currentTNode=tView.firstChild,newLFrame.lView=newView,newLFrame.tView=tView,newLFrame.contextLView=newView,newLFrame.bindingIndex=tView.bindingStartIndex,newLFrame.inI18n=!1}function allocLFrame(){const currentLFrame=instructionState.lFrame,childLFrame=null===currentLFrame?null:currentLFrame.child;return null===childLFrame?createLFrame(currentLFrame):childLFrame}function createLFrame(parent){const lFrame={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent,child:null,inI18n:!1};return null!==parent&&(parent.child=lFrame),lFrame}function leaveViewLight(){const oldLFrame=instructionState.lFrame;return instructionState.lFrame=oldLFrame.parent,oldLFrame.currentTNode=null,oldLFrame.lView=null,oldLFrame}const leaveDI=leaveViewLight;function leaveView(){const oldLFrame=leaveViewLight();oldLFrame.isParent=!0,oldLFrame.tView=null,oldLFrame.selectedIndex=-1,oldLFrame.contextLView=null,oldLFrame.elementDepthCount=0,oldLFrame.currentDirectiveIndex=-1,oldLFrame.currentNamespace=null,oldLFrame.bindingRootIndex=-1,oldLFrame.bindingIndex=-1,oldLFrame.currentQueryIndex=0}function getSelectedIndex(){return instructionState.lFrame.selectedIndex}function setSelectedIndex(index){ngDevMode&&-1!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"Index must be past HEADER_OFFSET (or -1)."),ngDevMode&&assertLessThan(index,instructionState.lFrame.lView.length,"Can't set index passed end of LView"),instructionState.lFrame.selectedIndex=index}function registerPostOrderHooks(tView,tNode){ngDevMode&&assertFirstCreatePass(tView);for(let i=tNode.directiveStart,end=tNode.directiveEnd;i<end;i++){const directiveDef=tView.data[i];ngDevMode&&assertDefined(directiveDef,"Expecting DirectiveDef");const lifecycleHooks=directiveDef.type.prototype,{ngAfterContentInit,ngAfterContentChecked,ngAfterViewInit,ngAfterViewChecked,ngOnDestroy}=lifecycleHooks;ngAfterContentInit&&(tView.contentHooks??=[]).push(-i,ngAfterContentInit),ngAfterContentChecked&&((tView.contentHooks??=[]).push(i,ngAfterContentChecked),(tView.contentCheckHooks??=[]).push(i,ngAfterContentChecked)),ngAfterViewInit&&(tView.viewHooks??=[]).push(-i,ngAfterViewInit),ngAfterViewChecked&&((tView.viewHooks??=[]).push(i,ngAfterViewChecked),(tView.viewCheckHooks??=[]).push(i,ngAfterViewChecked)),null!=ngOnDestroy&&(tView.destroyHooks??=[]).push(i,ngOnDestroy)}}function executeCheckHooks(lView,hooks,nodeIndex){callHooks(lView,hooks,3,nodeIndex)}function executeInitAndCheckHooks(lView,hooks,initPhase,nodeIndex){ngDevMode&&assertNotEqual(initPhase,3,"Init pre-order hooks should not be called more than once"),(3&lView[FLAGS])===initPhase&&callHooks(lView,hooks,initPhase,nodeIndex)}function incrementInitPhaseFlags(lView,initPhase){ngDevMode&&assertNotEqual(initPhase,3,"Init hooks phase should not be incremented after all init hooks have been run.");let flags=lView[FLAGS];(3&flags)===initPhase&&(flags&=4095,flags+=1,lView[FLAGS]=flags)}function callHooks(currentView,arr,initPhase,currentNodeIndex){ngDevMode&&assertEqual(isInCheckNoChangesMode(),!1,"Hooks should never be run when in check no changes mode.");const startIndex=void 0!==currentNodeIndex?65535&currentView[PREORDER_HOOK_FLAGS]:0,nodeIndexLimit=null!=currentNodeIndex?currentNodeIndex:-1,max=arr.length-1;let lastNodeIndexFound=0;for(let i=startIndex;i<max;i++){if("number"==typeof arr[i+1]){if(lastNodeIndexFound=arr[i],null!=currentNodeIndex&&lastNodeIndexFound>=currentNodeIndex)break}else{arr[i]<0&&(currentView[PREORDER_HOOK_FLAGS]+=65536),(lastNodeIndexFound<nodeIndexLimit||-1==nodeIndexLimit)&&(callHook(currentView,initPhase,arr,i),currentView[PREORDER_HOOK_FLAGS]=(4294901760&currentView[PREORDER_HOOK_FLAGS])+i+2),i++}}}function callHookInternal(directive,hook){profiler(4,directive,hook);const prevConsumer=setActiveConsumer(null);try{hook.call(directive)}finally{setActiveConsumer(prevConsumer),profiler(5,directive,hook)}}function callHook(currentView,initPhase,arr,i){const isInitHook=arr[i]<0,hook=arr[i+1],directive=currentView[isInitHook?-arr[i]:arr[i]];if(isInitHook){currentView[FLAGS]>>12<currentView[PREORDER_HOOK_FLAGS]>>16&&(3&currentView[FLAGS])===initPhase&&(currentView[FLAGS]+=4096,callHookInternal(directive,hook))}else callHookInternal(directive,hook)}const NO_PARENT_INJECTOR=-1;class NodeInjectorFactory{constructor(factory,isViewProvider,injectImplementation){this.factory=factory,this.resolving=!1,ngDevMode&&assertDefined(factory,"Factory not specified"),ngDevMode&&assertEqual(typeof factory,"function","Expected factory function."),this.canSeeViewProviders=isViewProvider,this.injectImpl=injectImplementation}}function toTNodeTypeAsString(tNodeType){let text="";return 1&tNodeType&&(text+="|Text"),2&tNodeType&&(text+="|Element"),4&tNodeType&&(text+="|Container"),8&tNodeType&&(text+="|ElementContainer"),16&tNodeType&&(text+="|Projection"),32&tNodeType&&(text+="|IcuContainer"),64&tNodeType&&(text+="|Placeholder"),text.length>0?text.substring(1):text}function assertTNodeType(tNode,expectedTypes,message){assertDefined(tNode,"should be called with a TNode"),0==(tNode.type&expectedTypes)&&throwError(message||`Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`)}function hasParentInjector(parentLocation){return parentLocation!==NO_PARENT_INJECTOR}function getParentInjectorIndex(parentLocation){ngDevMode&&assertNumber(parentLocation,"Number expected"),ngDevMode&&assertNotEqual(parentLocation,-1,"Not a valid state.");return ngDevMode&&assertGreaterThan(32767&parentLocation,HEADER_OFFSET,"Parent injector must be pointing past HEADER_OFFSET."),32767&parentLocation}function getParentInjectorView(location,startView){let viewOffset=function getParentInjectorViewOffset(parentLocation){return parentLocation>>16}(location),parentView=startView;for(;viewOffset>0;)parentView=parentView[DECLARATION_VIEW],viewOffset--;return parentView}let includeViewProviders=!0;function setIncludeViewProviders(v){const oldValue=includeViewProviders;return includeViewProviders=v,oldValue}const BLOOM_MASK=255,BLOOM_BUCKET_BITS=5;let nextNgElementId=0;const NOT_FOUND={};function getOrCreateNodeInjectorForNode(tNode,lView){const existingInjectorIndex=getInjectorIndex(tNode,lView);if(-1!==existingInjectorIndex)return existingInjectorIndex;const tView=lView[TVIEW];tView.firstCreatePass&&(tNode.injectorIndex=lView.length,insertBloom(tView.data,tNode),insertBloom(lView,null),insertBloom(tView.blueprint,null));const parentLoc=getParentInjectorLocation(tNode,lView),injectorIndex=tNode.injectorIndex;if(hasParentInjector(parentLoc)){const parentIndex=getParentInjectorIndex(parentLoc),parentLView=getParentInjectorView(parentLoc,lView),parentData=parentLView[TVIEW].data;for(let i=0;i<8;i++)lView[injectorIndex+i]=parentLView[parentIndex+i]|parentData[parentIndex+i]}return lView[injectorIndex+8]=parentLoc,injectorIndex}function insertBloom(arr,footer){arr.push(0,0,0,0,0,0,0,0,footer)}function getInjectorIndex(tNode,lView){return-1===tNode.injectorIndex||tNode.parent&&tNode.parent.injectorIndex===tNode.injectorIndex||null===lView[tNode.injectorIndex+8]?-1:(ngDevMode&&assertIndexInRange(lView,tNode.injectorIndex),tNode.injectorIndex)}function getParentInjectorLocation(tNode,lView){if(tNode.parent&&-1!==tNode.parent.injectorIndex)return tNode.parent.injectorIndex;let declarationViewOffset=0,parentTNode=null,lViewCursor=lView;for(;null!==lViewCursor;){if(parentTNode=getTNodeFromLView(lViewCursor),null===parentTNode)return NO_PARENT_INJECTOR;if(ngDevMode&&parentTNode&&assertTNodeForLView(parentTNode,lViewCursor[DECLARATION_VIEW]),declarationViewOffset++,lViewCursor=lViewCursor[DECLARATION_VIEW],-1!==parentTNode.injectorIndex)return parentTNode.injectorIndex|declarationViewOffset<<16}return NO_PARENT_INJECTOR}function diPublicInInjector(injectorIndex,tView,token){!function bloomAdd(injectorIndex,tView,type){let id;ngDevMode&&assertEqual(tView.firstCreatePass,!0,"expected firstCreatePass to be true"),"string"==typeof type?id=type.charCodeAt(0)||0:type.hasOwnProperty(NG_ELEMENT_ID)&&(id=type[NG_ELEMENT_ID]),null==id&&(id=type[NG_ELEMENT_ID]=nextNgElementId++);const bloomHash=id&BLOOM_MASK,mask=1<<bloomHash;tView.data[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]|=mask}(injectorIndex,tView,token)}function notFoundValueOrThrow(notFoundValue,token,flags){if(flags&InjectFlags.Optional||void 0!==notFoundValue)return notFoundValue;throwProviderNotFoundError(token,"NodeInjector")}function lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue){if(flags&InjectFlags.Optional&&void 0===notFoundValue&&(notFoundValue=null),0==(flags&(InjectFlags.Self|InjectFlags.Host))){const moduleInjector=lView[INJECTOR$1],previousInjectImplementation=setInjectImplementation(void 0);try{return moduleInjector?moduleInjector.get(token,notFoundValue,flags&InjectFlags.Optional):injectRootLimpMode(token,notFoundValue,flags&InjectFlags.Optional)}finally{setInjectImplementation(previousInjectImplementation)}}return notFoundValueOrThrow(notFoundValue,token,flags)}function getOrCreateInjectable(tNode,lView,token,flags=InjectFlags.Default,notFoundValue){if(null!==tNode){if(2048&lView[FLAGS]){const embeddedInjectorValue=function lookupTokenUsingEmbeddedInjector(tNode,lView,token,flags,notFoundValue){let currentTNode=tNode,currentLView=lView;for(;null!==currentTNode&&null!==currentLView&&2048&currentLView[FLAGS]&&!(512&currentLView[FLAGS]);){ngDevMode&&assertTNodeForLView(currentTNode,currentLView);const nodeInjectorValue=lookupTokenUsingNodeInjector(currentTNode,currentLView,token,flags|InjectFlags.Self,NOT_FOUND);if(nodeInjectorValue!==NOT_FOUND)return nodeInjectorValue;let parentTNode=currentTNode.parent;if(!parentTNode){const embeddedViewInjector=currentLView[EMBEDDED_VIEW_INJECTOR];if(embeddedViewInjector){const embeddedViewInjectorValue=embeddedViewInjector.get(token,NOT_FOUND,flags);if(embeddedViewInjectorValue!==NOT_FOUND)return embeddedViewInjectorValue}parentTNode=getTNodeFromLView(currentLView),currentLView=currentLView[DECLARATION_VIEW]}currentTNode=parentTNode}return notFoundValue}(tNode,lView,token,flags,NOT_FOUND);if(embeddedInjectorValue!==NOT_FOUND)return embeddedInjectorValue}const value=lookupTokenUsingNodeInjector(tNode,lView,token,flags,NOT_FOUND);if(value!==NOT_FOUND)return value}return lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue)}function lookupTokenUsingNodeInjector(tNode,lView,token,flags,notFoundValue){const bloomHash=function bloomHashBitOrFactory(token){if(ngDevMode&&assertDefined(token,"token must be defined"),"string"==typeof token)return token.charCodeAt(0)||0;const tokenId=token.hasOwnProperty(NG_ELEMENT_ID)?token[NG_ELEMENT_ID]:void 0;return"number"==typeof tokenId?tokenId>=0?tokenId&BLOOM_MASK:(ngDevMode&&assertEqual(tokenId,-1,"Expecting to get Special Injector Id"),createNodeInjector):tokenId}(token);if("function"==typeof bloomHash){if(!enterDI(lView,tNode,flags))return flags&InjectFlags.Host?notFoundValueOrThrow(notFoundValue,token,flags):lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue);try{const value=bloomHash(flags);if(null!=value||flags&InjectFlags.Optional)return value;throwProviderNotFoundError(token)}finally{leaveDI()}}else if("number"==typeof bloomHash){let previousTView=null,injectorIndex=getInjectorIndex(tNode,lView),parentLocation=NO_PARENT_INJECTOR,hostTElementNode=flags&InjectFlags.Host?lView[DECLARATION_COMPONENT_VIEW][T_HOST]:null;for((-1===injectorIndex||flags&InjectFlags.SkipSelf)&&(parentLocation=-1===injectorIndex?getParentInjectorLocation(tNode,lView):lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,!1)?(previousTView=lView[TVIEW],injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1);-1!==injectorIndex;){ngDevMode&&assertNodeInjector(lView,injectorIndex);const tView=lView[TVIEW];if(ngDevMode&&assertTNodeForLView(tView.data[injectorIndex+8],lView),bloomHasToken(bloomHash,injectorIndex,tView.data)){const instance=searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode);if(instance!==NOT_FOUND)return instance}parentLocation=lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,lView[TVIEW].data[injectorIndex+8]===hostTElementNode)&&bloomHasToken(bloomHash,injectorIndex,lView)?(previousTView=tView,injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1}}return notFoundValue}function searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode){const currentTView=lView[TVIEW],tNode=currentTView.data[injectorIndex+8],injectableIdx=locateDirectiveOrProvider(tNode,currentTView,token,null==previousTView?isComponentHost(tNode)&&includeViewProviders:previousTView!=currentTView&&0!=(3&tNode.type),flags&InjectFlags.Host&&hostTElementNode===tNode);return null!==injectableIdx?getNodeInjectable(lView,currentTView,injectableIdx,tNode):NOT_FOUND}function locateDirectiveOrProvider(tNode,tView,token,canAccessViewProviders,isHostSpecialCase){const nodeProviderIndexes=tNode.providerIndexes,tInjectables=tView.data,injectablesStart=1048575&nodeProviderIndexes,directivesStart=tNode.directiveStart,directiveEnd=tNode.directiveEnd,cptViewProvidersCount=nodeProviderIndexes>>20,endIndex=isHostSpecialCase?injectablesStart+cptViewProvidersCount:directiveEnd;for(let i=canAccessViewProviders?injectablesStart:injectablesStart+cptViewProvidersCount;i<endIndex;i++){const providerTokenOrDef=tInjectables[i];if(i<directivesStart&&token===providerTokenOrDef||i>=directivesStart&&providerTokenOrDef.type===token)return i}if(isHostSpecialCase){const dirDef=tInjectables[directivesStart];if(dirDef&&isComponentDef(dirDef)&&dirDef.type===token)return directivesStart}return null}function getNodeInjectable(lView,tView,index,tNode){let value=lView[index];const tData=tView.data;if(function isFactory(obj){return obj instanceof NodeInjectorFactory}(value)){const factory=value;factory.resolving&&throwCyclicDependencyError(stringifyForError(tData[index]));const previousIncludeViewProviders=setIncludeViewProviders(factory.canSeeViewProviders);factory.resolving=!0;const previousInjectImplementation=factory.injectImpl?setInjectImplementation(factory.injectImpl):null,success=enterDI(lView,tNode,InjectFlags.Default);ngDevMode&&assertEqual(success,!0,"Because flags do not contain `SkipSelf' we expect this to always succeed.");try{value=lView[index]=factory.factory(void 0,tData,lView,tNode),tView.firstCreatePass&&index>=tNode.directiveStart&&(ngDevMode&&function assertDirectiveDef(obj){void 0!==obj.type&&null!=obj.selectors&&void 0!==obj.inputs||throwError("Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.")}(tData[index]),function registerPreOrderHooks(directiveIndex,directiveDef,tView){ngDevMode&&assertFirstCreatePass(tView);const{ngOnChanges,ngOnInit,ngDoCheck}=directiveDef.type.prototype;if(ngOnChanges){const wrappedOnChanges=NgOnChangesFeatureImpl(directiveDef);(tView.preOrderHooks??=[]).push(directiveIndex,wrappedOnChanges),(tView.preOrderCheckHooks??=[]).push(directiveIndex,wrappedOnChanges)}ngOnInit&&(tView.preOrderHooks??=[]).push(0-directiveIndex,ngOnInit),ngDoCheck&&((tView.preOrderHooks??=[]).push(directiveIndex,ngDoCheck),(tView.preOrderCheckHooks??=[]).push(directiveIndex,ngDoCheck))}(index,tData[index],tView))}finally{null!==previousInjectImplementation&&setInjectImplementation(previousInjectImplementation),setIncludeViewProviders(previousIncludeViewProviders),factory.resolving=!1,leaveDI()}}return value}function bloomHasToken(bloomHash,injectorIndex,injectorView){const mask=1<<bloomHash;return!!(injectorView[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]&mask)}function shouldSearchParent(flags,isFirstHostTNode){return!(flags&InjectFlags.Self||flags&InjectFlags.Host&&isFirstHostTNode)}class NodeInjector{constructor(_tNode,_lView){this._tNode=_tNode,this._lView=_lView}get(token,notFoundValue,flags){return getOrCreateInjectable(this._tNode,this._lView,token,convertToBitFlags(flags),notFoundValue)}}function createNodeInjector(){return new NodeInjector(getCurrentTNode(),getLView())}function getTNodeFromLView(lView){const tView=lView[TVIEW],tViewType=tView.type;return 2===tViewType?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tViewType?lView[T_HOST]:null}function ɵɵinjectAttribute(attrNameToInject){return function injectAttributeImpl(tNode,attrNameToInject){if(ngDevMode&&assertTNodeType(tNode,15),ngDevMode&&assertDefined(tNode,"expecting tNode"),"class"===attrNameToInject)return tNode.classes;if("style"===attrNameToInject)return tNode.styles;const attrs=tNode.attrs;if(attrs){const attrsLength=attrs.length;let i=0;for(;i<attrsLength;){const value=attrs[i];if(isNameOnlyAttributeMarker(value))break;if(0===value)i+=2;else if("number"==typeof value)for(i++;i<attrsLength&&"string"==typeof attrs[i];)i++;else{if(value===attrNameToInject)return attrs[i+1];i+=2}}}return null}(getCurrentTNode(),attrNameToInject)}const Attribute=makeParamDecorator("Attribute",(attributeName=>({attributeName,__NG_ELEMENT_ID__:()=>ɵɵinjectAttribute(attributeName)})));let _reflect=null;function reflectDependencies(type){return convertDependencies(function getReflect(){return _reflect=_reflect||new ReflectionCapabilities}().parameters(type))}function convertDependencies(deps){return deps.map((dep=>function reflectDependency(dep){const meta={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(dep)&&dep.length>0)for(let j=0;j<dep.length;j++){const param=dep[j];if(void 0===param)continue;const proto=Object.getPrototypeOf(param);if(param instanceof Optional||"Optional"===proto.ngMetadataName)meta.optional=!0;else if(param instanceof SkipSelf||"SkipSelf"===proto.ngMetadataName)meta.skipSelf=!0;else if(param instanceof Self||"Self"===proto.ngMetadataName)meta.self=!0;else if(param instanceof Host||"Host"===proto.ngMetadataName)meta.host=!0;else if(param instanceof Inject)meta.token=param.token;else if(param instanceof Attribute){if(void 0===param.attributeName)throw new RuntimeError(204,ngDevMode&&"Attribute name must be defined.");meta.attribute=param.attributeName}else meta.token=param}else void 0===dep||Array.isArray(dep)&&0===dep.length?meta.token=null:meta.token=dep;return meta}(dep)))}new Map;let shouldThrowErrorOnUnknownProperty=!1;function reportUnknownPropertyError(message){if(shouldThrowErrorOnUnknownProperty)throw new RuntimeError(303,message);console.error(formatRuntimeError(303,message))}new Map([["ngIf","NgIf"],["ngFor","NgFor"],["ngSwitchCase","NgSwitchCase"],["ngSwitchDefault","NgSwitchDefault"]]);var RendererStyleFlags2;!function(RendererStyleFlags2){RendererStyleFlags2[RendererStyleFlags2.Important=1]="Important",RendererStyleFlags2[RendererStyleFlags2.DashCase=2]="DashCase"}(RendererStyleFlags2||(RendererStyleFlags2={}));const TRACKED_LVIEWS=new Map;let uniqueIdCounter=0;const MONKEY_PATCH_KEY_NAME="__ngContext__";function attachPatchData(target,data){ngDevMode&&assertDefined(target,"Target expected"),isLView(data)?(target[MONKEY_PATCH_KEY_NAME]=data[ID],function registerLView(lView){ngDevMode&&assertNumber(lView[ID],"LView must have an ID in order to be registered"),TRACKED_LVIEWS.set(lView[ID],lView)}(data)):target[MONKEY_PATCH_KEY_NAME]=data}let _icuContainerIterate;function icuContainerIterate(tIcuContainerNode,lView){return _icuContainerIterate(tIcuContainerNode,lView)}function getLViewParent(lView){ngDevMode&&assertLView(lView);const parent=lView[PARENT];return isLContainer(parent)?parent[PARENT]:parent}function getFirstLContainer(lView){return getNearestLContainer(lView[CHILD_HEAD])}function getNextLContainer(container){return getNearestLContainer(container[NEXT])}function getNearestLContainer(viewOrContainer){for(;null!==viewOrContainer&&!isLContainer(viewOrContainer);)viewOrContainer=viewOrContainer[NEXT];return viewOrContainer}function applyToElementOrContainer(action,renderer,parent,lNodeToHandle,beforeNode){if(null!=lNodeToHandle){let lContainer,isComponent=!1;isLContainer(lNodeToHandle)?lContainer=lNodeToHandle:isLView(lNodeToHandle)&&(isComponent=!0,ngDevMode&&assertDefined(lNodeToHandle[HOST],"HOST must be defined for a component LView"),lNodeToHandle=lNodeToHandle[HOST]);const rNode=unwrapRNode(lNodeToHandle);0===action&&null!==parent?null==beforeNode?nativeAppendChild(renderer,parent,rNode):nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):1===action&&null!==parent?nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):2===action?nativeRemoveNode(renderer,rNode,isComponent):3===action&&(ngDevMode&&ngDevMode.rendererDestroyNode++,renderer.destroyNode(rNode)),null!=lContainer&&function applyContainer(renderer,action,lContainer,parentRElement,beforeNode){ngDevMode&&assertLContainer(lContainer);const anchor=lContainer[NATIVE],native=unwrapRNode(lContainer);anchor!==native&&applyToElementOrContainer(action,renderer,parentRElement,anchor,beforeNode);for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const lView=lContainer[i];applyView(lView[TVIEW],lView,renderer,action,parentRElement,anchor)}}(renderer,action,lContainer,parent,beforeNode)}}function createElementNode(renderer,name,namespace){return ngDevMode&&ngDevMode.rendererCreateElement++,renderer.createElement(name,namespace)}function insertView(tView,lView,lContainer,index){ngDevMode&&assertLView(lView),ngDevMode&&assertLContainer(lContainer);const indexInContainer=CONTAINER_HEADER_OFFSET+index,containerLength=lContainer.length;index>0&&(lContainer[indexInContainer-1][NEXT]=lView),index<containerLength-CONTAINER_HEADER_OFFSET?(lView[NEXT]=lContainer[indexInContainer],addToArray(lContainer,CONTAINER_HEADER_OFFSET+index,lView)):(lContainer.push(lView),lView[NEXT]=null),lView[PARENT]=lContainer;const declarationLContainer=lView[DECLARATION_LCONTAINER];null!==declarationLContainer&&lContainer!==declarationLContainer&&function trackMovedView(declarationContainer,lView){ngDevMode&&assertDefined(lView,"LView required"),ngDevMode&&assertLContainer(declarationContainer);const movedViews=declarationContainer[MOVED_VIEWS],insertedLContainer=lView[PARENT];ngDevMode&&assertLContainer(insertedLContainer);const insertedComponentLView=insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(insertedComponentLView,"Missing insertedComponentLView");const declaredComponentLView=lView[DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(declaredComponentLView,"Missing declaredComponentLView"),declaredComponentLView!==insertedComponentLView&&(declarationContainer[HAS_TRANSPLANTED_VIEWS]=!0);null===movedViews?declarationContainer[MOVED_VIEWS]=[lView]:movedViews.push(lView)}(declarationLContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.insertView(tView),lView[FLAGS]|=128}function detachMovedView(declarationContainer,lView){ngDevMode&&assertLContainer(declarationContainer),ngDevMode&&assertDefined(declarationContainer[MOVED_VIEWS],"A projected view should belong to a non-empty projected views collection");const movedViews=declarationContainer[MOVED_VIEWS],declarationViewIndex=movedViews.indexOf(lView),insertionLContainer=lView[PARENT];ngDevMode&&assertLContainer(insertionLContainer),clearViewRefreshFlag(lView),movedViews.splice(declarationViewIndex,1)}function detachView(lContainer,removeIndex){if(lContainer.length<=CONTAINER_HEADER_OFFSET)return;const indexInContainer=CONTAINER_HEADER_OFFSET+removeIndex,viewToDetach=lContainer[indexInContainer];if(viewToDetach){const declarationLContainer=viewToDetach[DECLARATION_LCONTAINER];null!==declarationLContainer&&declarationLContainer!==lContainer&&detachMovedView(declarationLContainer,viewToDetach),removeIndex>0&&(lContainer[indexInContainer-1][NEXT]=viewToDetach[NEXT]);const removedLView=removeFromArray(lContainer,CONTAINER_HEADER_OFFSET+removeIndex);!function removeViewFromContainer(tView,lView){applyView(tView,lView,lView[RENDERER],2,null,null),lView[HOST]=null,lView[T_HOST]=null}(viewToDetach[TVIEW],viewToDetach);const lQueries=removedLView[QUERIES];null!==lQueries&&lQueries.detachView(removedLView[TVIEW]),viewToDetach[PARENT]=null,viewToDetach[NEXT]=null,viewToDetach[FLAGS]&=-129}return viewToDetach}function destroyLView(tView,lView){if(!(256&lView[FLAGS])){const renderer=lView[RENDERER];lView[REACTIVE_TEMPLATE_CONSUMER]?.destroy(),lView[REACTIVE_HOST_BINDING_CONSUMER]?.destroy(),renderer.destroyNode&&applyView(tView,lView,renderer,3,null,null),function destroyViewTree(rootView){let lViewOrLContainer=rootView[CHILD_HEAD];if(!lViewOrLContainer)return cleanUpView(rootView[TVIEW],rootView);for(;lViewOrLContainer;){let next=null;if(isLView(lViewOrLContainer))next=lViewOrLContainer[CHILD_HEAD];else{ngDevMode&&assertLContainer(lViewOrLContainer);const firstView=lViewOrLContainer[CONTAINER_HEADER_OFFSET];firstView&&(next=firstView)}if(!next){for(;lViewOrLContainer&&!lViewOrLContainer[NEXT]&&lViewOrLContainer!==rootView;)isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),lViewOrLContainer=lViewOrLContainer[PARENT];null===lViewOrLContainer&&(lViewOrLContainer=rootView),isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),next=lViewOrLContainer&&lViewOrLContainer[NEXT]}lViewOrLContainer=next}}(lView)}}function cleanUpView(tView,lView){if(!(256&lView[FLAGS])){lView[FLAGS]&=-129,lView[FLAGS]|=256,function executeOnDestroys(tView,lView){let destroyHooks;if(null!=tView&&null!=(destroyHooks=tView.destroyHooks))for(let i=0;i<destroyHooks.length;i+=2){const context=lView[destroyHooks[i]];if(!(context instanceof NodeInjectorFactory)){const toCall=destroyHooks[i+1];if(Array.isArray(toCall))for(let j=0;j<toCall.length;j+=2){const callContext=context[toCall[j]],hook=toCall[j+1];profiler(4,callContext,hook);try{hook.call(callContext)}finally{profiler(5,callContext,hook)}}else{profiler(4,context,toCall);try{toCall.call(context)}finally{profiler(5,context,toCall)}}}}}(tView,lView),function processCleanups(tView,lView){const tCleanup=tView.cleanup,lCleanup=lView[CLEANUP];if(null!==tCleanup)for(let i=0;i<tCleanup.length-1;i+=2)if("string"==typeof tCleanup[i]){const targetIdx=tCleanup[i+3];ngDevMode&&assertNumber(targetIdx,"cleanup target must be a number"),targetIdx>=0?lCleanup[targetIdx]():lCleanup[-targetIdx].unsubscribe(),i+=2}else{const context=lCleanup[tCleanup[i+1]];tCleanup[i].call(context)}null!==lCleanup&&(lView[CLEANUP]=null);const destroyHooks=lView[ON_DESTROY_HOOKS];if(null!==destroyHooks){for(let i=0;i<destroyHooks.length;i++){const destroyHooksFn=destroyHooks[i];ngDevMode&&assertFunction(destroyHooksFn,"Expecting destroy hook to be a function."),destroyHooksFn()}lView[ON_DESTROY_HOOKS]=null}}(tView,lView),1===lView[TVIEW].type&&(ngDevMode&&ngDevMode.rendererDestroy++,lView[RENDERER].destroy());const declarationContainer=lView[DECLARATION_LCONTAINER];if(null!==declarationContainer&&isLContainer(lView[PARENT])){declarationContainer!==lView[PARENT]&&detachMovedView(declarationContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.detachView(tView)}!function unregisterLView(lView){ngDevMode&&assertNumber(lView[ID],"Cannot stop tracking an LView that does not have an ID"),TRACKED_LVIEWS.delete(lView[ID])}(lView)}}function nativeInsertBefore(renderer,parent,child,beforeNode,isMove){ngDevMode&&ngDevMode.rendererInsertBefore++,renderer.insertBefore(parent,child,beforeNode,isMove)}function nativeAppendChild(renderer,parent,child){ngDevMode&&ngDevMode.rendererAppendChild++,ngDevMode&&assertDefined(parent,"parent node must be defined"),renderer.appendChild(parent,child)}function nativeParentNode(renderer,node){return renderer.parentNode(node)}let DOCUMENT;function getFirstNativeNode(lView,tNode){if(null!==tNode){ngDevMode&&assertTNodeType(tNode,63);const tNodeType=tNode.type;if(3&tNodeType)return getNativeByTNode(tNode,lView);if(4&tNodeType)return getBeforeNodeForView(-1,lView[tNode.index]);if(8&tNodeType){const elIcuContainerChild=tNode.child;if(null!==elIcuContainerChild)return getFirstNativeNode(lView,elIcuContainerChild);{const rNodeOrLContainer=lView[tNode.index];return isLContainer(rNodeOrLContainer)?getBeforeNodeForView(-1,rNodeOrLContainer):unwrapRNode(rNodeOrLContainer)}}if(32&tNodeType){return icuContainerIterate(tNode,lView)()||unwrapRNode(lView[tNode.index])}{const projectionNodes=getProjectionNodes(lView,tNode);if(null!==projectionNodes){if(Array.isArray(projectionNodes))return projectionNodes[0];const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);return ngDevMode&&assertParentView(parentView),getFirstNativeNode(parentView,projectionNodes)}return getFirstNativeNode(lView,tNode.next)}}return null}function getProjectionNodes(lView,tNode){if(null!==tNode){const componentHost=lView[DECLARATION_COMPONENT_VIEW][T_HOST],slotIdx=tNode.projection;return ngDevMode&&function assertProjectionSlots(lView,errMessage){assertDefined(lView[DECLARATION_COMPONENT_VIEW],"Component views should exist."),assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection,errMessage||"Components with projection nodes (<ng-content>) must have projection slots defined.")}(lView),componentHost.projection[slotIdx]}return null}function getBeforeNodeForView(viewIndexInContainer,lContainer){const nextViewIndex=CONTAINER_HEADER_OFFSET+viewIndexInContainer+1;if(nextViewIndex<lContainer.length){const lView=lContainer[nextViewIndex],firstTNodeOfView=lView[TVIEW].firstChild;if(null!==firstTNodeOfView)return getFirstNativeNode(lView,firstTNodeOfView)}return lContainer[NATIVE]}function nativeRemoveNode(renderer,rNode,isHostElement){ngDevMode&&ngDevMode.rendererRemoveNode++;const nativeParent=nativeParentNode(renderer,rNode);nativeParent&&function nativeRemoveChild(renderer,parent,child,isHostElement){renderer.removeChild(parent,child,isHostElement)}(renderer,nativeParent,rNode,isHostElement)}function applyNodes(renderer,action,tNode,lView,parentRElement,beforeNode,isProjection){for(;null!=tNode;){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertTNodeType(tNode,63);const rawSlotValue=lView[tNode.index],tNodeType=tNode.type;if(isProjection&&0===action&&(rawSlotValue&&attachPatchData(unwrapRNode(rawSlotValue),lView),tNode.flags|=2),32!=(32&tNode.flags))if(8&tNodeType)applyNodes(renderer,action,tNode.child,lView,parentRElement,beforeNode,!1),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)applyToElementOrContainer(action,renderer,parentRElement,rNode,beforeNode);applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode)}else 16&tNodeType?applyProjectionRecursive(renderer,action,lView,tNode,parentRElement,beforeNode):(ngDevMode&&assertTNodeType(tNode,7),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode));tNode=isProjection?tNode.projectionNext:tNode.next}}function applyView(tView,lView,renderer,action,parentRElement,beforeNode){applyNodes(renderer,action,tView.firstChild,lView,parentRElement,beforeNode,!1)}function applyProjectionRecursive(renderer,action,lView,tProjectionNode,parentRElement,beforeNode){const componentLView=lView[DECLARATION_COMPONENT_VIEW],componentNode=componentLView[T_HOST];ngDevMode&&assertEqual(typeof tProjectionNode.projection,"number","expecting projection index");const nodeToProjectOrRNodes=componentNode.projection[tProjectionNode.projection];if(Array.isArray(nodeToProjectOrRNodes))for(let i=0;i<nodeToProjectOrRNodes.length;i++){applyToElementOrContainer(action,renderer,parentRElement,nodeToProjectOrRNodes[i],beforeNode)}else{applyNodes(renderer,action,nodeToProjectOrRNodes,componentLView[PARENT],parentRElement,beforeNode,!0)}}function writeDirectClass(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),""===newValue?renderer.removeAttribute(element,"class"):renderer.setAttribute(element,"class",newValue),ngDevMode&&ngDevMode.rendererSetClassName++}function setupStaticAttributes(renderer,element,tNode){const{mergedAttrs,classes,styles}=tNode;null!==mergedAttrs&&setUpAttributes(renderer,element,mergedAttrs),null!==classes&&writeDirectClass(renderer,element,classes),null!==styles&&function writeDirectStyle(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),renderer.setAttribute(element,"style",newValue),ngDevMode&&ngDevMode.rendererSetStyle++}(renderer,element,styles)}function getDocument(){return void 0!==DOCUMENT?DOCUMENT:"undefined"!=typeof document?document:void 0}function tagSet(tags){const res={};for(const t of tags.split(","))res[t]=!0;return res}function merge(...sets){const res={};for(const s of sets)for(const v in s)s.hasOwnProperty(v)&&(res[v]=!0);return res}const VOID_ELEMENTS=tagSet("area,br,col,hr,img,wbr"),OPTIONAL_END_TAG_BLOCK_ELEMENTS=tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),OPTIONAL_END_TAG_INLINE_ELEMENTS=tagSet("rp,rt"),OPTIONAL_END_TAG_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,OPTIONAL_END_TAG_BLOCK_ELEMENTS),BLOCK_ELEMENTS=merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS,tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),INLINE_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),URI_ATTRS=(merge(VOID_ELEMENTS,BLOCK_ELEMENTS,INLINE_ELEMENTS,OPTIONAL_END_TAG_ELEMENTS),tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href")),HTML_ATTRS=tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),ARIA_ATTRS=tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");merge(URI_ATTRS,HTML_ATTRS,ARIA_ATTRS),tagSet("script,style,template");var SecurityContext;!function(SecurityContext){SecurityContext[SecurityContext.NONE=0]="NONE",SecurityContext[SecurityContext.HTML=1]="HTML",SecurityContext[SecurityContext.STYLE=2]="STYLE",SecurityContext[SecurityContext.SCRIPT=3]="SCRIPT",SecurityContext[SecurityContext.URL=4]="URL",SecurityContext[SecurityContext.RESOURCE_URL=5]="RESOURCE_URL"}(SecurityContext||(SecurityContext={}));class InjectionToken{constructor(_desc,options){this._desc=_desc,this.ngMetadataName="InjectionToken",this.ɵprov=void 0,"number"==typeof options?(("undefined"==typeof ngDevMode||ngDevMode)&&assertLessThan(options,0,"Only negative numbers are supported here"),this.__NG_ELEMENT_ID__=options):void 0!==options&&(this.ɵprov=ɵɵdefineInjectable({token:this,providedIn:options.providedIn||"root",factory:options.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}const ENVIRONMENT_INITIALIZER=new InjectionToken("ENVIRONMENT_INITIALIZER"),INJECTOR=new InjectionToken("INJECTOR",-1),INJECTOR_DEF_TYPES=new InjectionToken("INJECTOR_DEF_TYPES");class NullInjector{get(token,notFoundValue=THROW_IF_NOT_FOUND){if(notFoundValue===THROW_IF_NOT_FOUND){const error=new Error(`NullInjectorError: No provider for ${stringify(token)}!`);throw error.name="NullInjectorError",error}return notFoundValue}}function importProvidersFrom(...sources){return{ɵproviders:internalImportProvidersFrom(!0,sources),ɵfromNgModule:!0}}function internalImportProvidersFrom(checkForStandaloneCmp,...sources){const providersOut=[],dedup=new Set;let injectorTypesWithProviders;return deepForEach(sources,(source=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&checkForStandaloneCmp){const cmpDef=getComponentDef$1(source);if(cmpDef?.standalone)throw new RuntimeError(800,`Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`)}const internalSource=source;walkProviderTree(internalSource,providersOut,[],dedup)&&(injectorTypesWithProviders||=[],injectorTypesWithProviders.push(internalSource))})),void 0!==injectorTypesWithProviders&&processInjectorTypesWithProviders(injectorTypesWithProviders,providersOut),providersOut}function processInjectorTypesWithProviders(typesWithProviders,providersOut){for(let i=0;i<typesWithProviders.length;i++){const{ngModule,providers}=typesWithProviders[i];deepForEachProvider(providers,(provider=>{ngDevMode&&validateProvider(provider,providers||EMPTY_ARRAY,ngModule),providersOut.push(provider)}))}}function walkProviderTree(container,providersOut,parents,dedup){if(!(container=resolveForwardRef(container)))return!1;let defType=null,injDef=getInjectorDef(container);const cmpDef=!injDef&&getComponentDef$1(container);if(injDef||cmpDef){if(cmpDef&&!cmpDef.standalone)return!1;defType=container}else{const ngModule=container.ngModule;if(injDef=getInjectorDef(ngModule),!injDef)return!1;defType=ngModule}if(ngDevMode&&-1!==parents.indexOf(defType)){throwCyclicDependencyError(stringify(defType),parents.map(stringify))}const isDuplicate=dedup.has(defType);if(cmpDef){if(isDuplicate)return!1;if(dedup.add(defType),cmpDef.dependencies){const deps="function"==typeof cmpDef.dependencies?cmpDef.dependencies():cmpDef.dependencies;for(const dep of deps)walkProviderTree(dep,providersOut,parents,dedup)}}else{if(!injDef)return!1;{if(null!=injDef.imports&&!isDuplicate){let importTypesWithProviders;ngDevMode&&parents.push(defType),dedup.add(defType);try{deepForEach(injDef.imports,(imported=>{walkProviderTree(imported,providersOut,parents,dedup)&&(importTypesWithProviders||=[],importTypesWithProviders.push(imported))}))}finally{ngDevMode&&parents.pop()}void 0!==importTypesWithProviders&&processInjectorTypesWithProviders(importTypesWithProviders,providersOut)}if(!isDuplicate){const factory=getFactoryDef(defType)||(()=>new defType);providersOut.push({provide:defType,useFactory:factory,deps:EMPTY_ARRAY},{provide:INJECTOR_DEF_TYPES,useValue:defType,multi:!0},{provide:ENVIRONMENT_INITIALIZER,useValue:()=>ɵɵinject(defType),multi:!0})}const defProviders=injDef.providers;if(null!=defProviders&&!isDuplicate){const injectorType=container;deepForEachProvider(defProviders,(provider=>{ngDevMode&&validateProvider(provider,defProviders,injectorType),providersOut.push(provider)}))}}}return defType!==container&&void 0!==container.providers}function validateProvider(provider,providers,containerType){if(isTypeProvider(provider)||isValueProvider(provider)||isFactoryProvider(provider)||isExistingProvider(provider))return;resolveForwardRef(provider&&(provider.useClass||provider.provide))||throwInvalidProviderError(containerType,providers,provider)}function deepForEachProvider(providers,fn){for(let provider of providers)isEnvironmentProviders(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?deepForEachProvider(provider,fn):fn(provider)}const USE_VALUE$1=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isValueProvider(value){return null!==value&&"object"==typeof value&&USE_VALUE$1 in value}function isExistingProvider(value){return!(!value||!value.useExisting)}function isFactoryProvider(value){return!(!value||!value.useFactory)}function isTypeProvider(value){return"function"==typeof value}const INJECTOR_SCOPE=new InjectionToken("Set Injector scope."),NOT_YET={},CIRCULAR={};let NULL_INJECTOR$1;function getNullInjector(){return void 0===NULL_INJECTOR$1&&(NULL_INJECTOR$1=new NullInjector),NULL_INJECTOR$1}class EnvironmentInjector{}class R3Injector extends EnvironmentInjector{get destroyed(){return this._destroyed}constructor(providers,parent,source,scopes){super(),this.parent=parent,this.source=source,this.scopes=scopes,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,forEachSingleProvider(providers,(provider=>this.processProvider(provider))),this.records.set(INJECTOR,makeRecord(void 0,this)),scopes.has("environment")&&this.records.set(EnvironmentInjector,makeRecord(void 0,this));const record=this.records.get(INJECTOR_SCOPE);null!=record&&"string"==typeof record.value&&this.scopes.add(record.value),this.injectorDefTypes=new Set(this.get(INJECTOR_DEF_TYPES.multi,EMPTY_ARRAY,InjectFlags.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{for(const service of this._ngOnDestroyHooks)service.ngOnDestroy();for(const hook of this._onDestroyHooks)hook()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),this._onDestroyHooks.length=0}}onDestroy(callback){return this.assertNotDestroyed(),this._onDestroyHooks.push(callback),()=>this.removeOnDestroy(callback)}runInContext(fn){this.assertNotDestroyed();const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{return fn()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation)}}get(token,notFoundValue=THROW_IF_NOT_FOUND,flags=InjectFlags.Default){if(this.assertNotDestroyed(),token.hasOwnProperty(NG_ENV_ID))return token[NG_ENV_ID](this);flags=convertToBitFlags(flags);const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{if(!(flags&InjectFlags.SkipSelf)){let record=this.records.get(token);if(void 0===record){const def=function couldBeInjectableType(value){return"function"==typeof value||"object"==typeof value&&value instanceof InjectionToken}(token)&&getInjectableDef(token);record=def&&this.injectableDefInScope(def)?makeRecord(injectableDefOrInjectorDefFactory(token),NOT_YET):null,this.records.set(token,record)}if(null!=record)return this.hydrate(token,record)}const nextInjector=flags&InjectFlags.Self?getNullInjector():this.parent;return notFoundValue=flags&InjectFlags.Optional&&notFoundValue===THROW_IF_NOT_FOUND?null:notFoundValue,nextInjector.get(token,notFoundValue)}catch(e){if("NullInjectorError"===e.name){if((e.ngTempTokenPath=e.ngTempTokenPath||[]).unshift(stringify(token)),previousInjector)throw e;return catchInjectorError(e,token,"R3InjectorError",this.source)}throw e}finally{setInjectImplementation(previousInjectImplementation),setCurrentInjector(previousInjector)}}resolveInjectorInitializers(){const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{const initializers=this.get(ENVIRONMENT_INITIALIZER.multi,EMPTY_ARRAY,InjectFlags.Self);if(ngDevMode&&!Array.isArray(initializers))throw new RuntimeError(-209,`Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);for(const initializer of initializers)initializer()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation)}}toString(){const tokens=[],records=this.records;for(const token of records.keys())tokens.push(stringify(token));return`R3Injector[${tokens.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new RuntimeError(205,ngDevMode&&"Injector has already been destroyed.")}processProvider(provider){let token=isTypeProvider(provider=resolveForwardRef(provider))?provider:resolveForwardRef(provider&&provider.provide);const record=function providerToRecord(provider){if(isValueProvider(provider))return makeRecord(void 0,provider.useValue);return makeRecord(providerToFactory(provider),NOT_YET)}(provider);if(isTypeProvider(provider)||!0!==provider.multi){const existing=this.records.get(token);ngDevMode&&existing&&void 0!==existing.multi&&throwMixedMultiProviderError()}else{let multiRecord=this.records.get(token);multiRecord?ngDevMode&&void 0===multiRecord.multi&&throwMixedMultiProviderError():(multiRecord=makeRecord(void 0,NOT_YET,!0),multiRecord.factory=()=>injectArgs(multiRecord.multi),this.records.set(token,multiRecord)),token=provider,multiRecord.multi.push(provider)}this.records.set(token,record)}hydrate(token,record){return ngDevMode&&record.value===CIRCULAR?throwCyclicDependencyError(stringify(token)):record.value===NOT_YET&&(record.value=CIRCULAR,record.value=record.factory()),"object"==typeof record.value&&record.value&&function hasOnDestroy(value){return null!==value&&"object"==typeof value&&"function"==typeof value.ngOnDestroy}(record.value)&&this._ngOnDestroyHooks.add(record.value),record.value}injectableDefInScope(def){if(!def.providedIn)return!1;const providedIn=resolveForwardRef(def.providedIn);return"string"==typeof providedIn?"any"===providedIn||this.scopes.has(providedIn):this.injectorDefTypes.has(providedIn)}removeOnDestroy(callback){const destroyCBIdx=this._onDestroyHooks.indexOf(callback);-1!==destroyCBIdx&&this._onDestroyHooks.splice(destroyCBIdx,1)}}function injectableDefOrInjectorDefFactory(token){const injectableDef=getInjectableDef(token),factory=null!==injectableDef?injectableDef.factory:getFactoryDef(token);if(null!==factory)return factory;if(token instanceof InjectionToken)throw new RuntimeError(204,ngDevMode&&`Token ${stringify(token)} is missing a ɵprov definition.`);if(token instanceof Function)return function getUndecoratedInjectableFactory(token){const paramLength=token.length;if(paramLength>0){const args=newArray(paramLength,"?");throw new RuntimeError(204,ngDevMode&&`Can't resolve all parameters for ${stringify(token)}: (${args.join(", ")}).`)}const inheritedInjectableDef=function getInheritedInjectableDef(type){const def=type&&(type[NG_PROV_DEF]||type[NG_INJECTABLE_DEF]);return def?(ngDevMode&&console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`),def):null}(token);return null!==inheritedInjectableDef?()=>inheritedInjectableDef.factory(token):()=>new token}(token);throw new RuntimeError(204,ngDevMode&&"unreachable")}function providerToFactory(provider,ngModuleType,providers){let factory;if(ngDevMode&&isEnvironmentProviders(provider)&&throwInvalidProviderError(void 0,providers,provider),isTypeProvider(provider)){const unwrappedProvider=resolveForwardRef(provider);return getFactoryDef(unwrappedProvider)||injectableDefOrInjectorDefFactory(unwrappedProvider)}if(isValueProvider(provider))factory=()=>resolveForwardRef(provider.useValue);else if(isFactoryProvider(provider))factory=()=>provider.useFactory(...injectArgs(provider.deps||[]));else if(isExistingProvider(provider))factory=()=>ɵɵinject(resolveForwardRef(provider.useExisting));else{const classRef=resolveForwardRef(provider&&(provider.useClass||provider.provide));if(ngDevMode&&!classRef&&throwInvalidProviderError(ngModuleType,providers,provider),!function hasDeps(value){return!!value.deps}(provider))return getFactoryDef(classRef)||injectableDefOrInjectorDefFactory(classRef);factory=()=>new classRef(...injectArgs(provider.deps))}return factory}function makeRecord(factory,value,multi=!1){return{factory,value,multi:multi?[]:void 0}}function forEachSingleProvider(providers,fn){for(const provider of providers)Array.isArray(provider)?forEachSingleProvider(provider,fn):provider&&isEnvironmentProviders(provider)?forEachSingleProvider(provider.ɵproviders,fn):fn(provider)}const APP_ID=new InjectionToken("AppId",{providedIn:"root",factory:()=>DEFAULT_APP_ID}),DEFAULT_APP_ID="ng";new InjectionToken("Platform Initializer"),new InjectionToken("Platform ID",{providedIn:"platform",factory:()=>"unknown"}),new InjectionToken("Application Packages Root URL"),new InjectionToken("AnimationModuleType"),new InjectionToken("CSP nonce",{providedIn:"root",factory:()=>getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"ENABLED_SSR_FEATURES":"",{providedIn:"root",factory:()=>new Set});function initTransferState(){const transferState=new TransferState;return transferState.store=function retrieveTransferredState(doc,appId){const script=doc.getElementById(appId+"-state");let initialState={};if(script&&script.textContent)try{initialState=JSON.parse(function unescapeTransferStateContent(text){const unescapedText={"&a;":"&","&q;":'"',"&s;":"'","&l;":"<","&g;":">"};return text.replace(/&[^;]+;/g,(s=>unescapedText[s]))}(script.textContent))}catch(e){console.warn("Exception while restoring TransferState for app "+appId,e)}return initialState}(getDocument(),inject$1(APP_ID)),transferState}class TransferState{constructor(){this.store={},this.onSerializeCallbacks={}}static#_=this.ɵprov=ɵɵdefineInjectable({token:TransferState,providedIn:"root",factory:initTransferState});get(key,defaultValue){return void 0!==this.store[key]?this.store[key]:defaultValue}set(key,value){this.store[key]=value}remove(key){delete this.store[key]}hasKey(key){return this.store.hasOwnProperty(key)}get isEmpty(){return 0===Object.keys(this.store).length}onSerialize(key,callback){this.onSerializeCallbacks[key]=callback}toJson(){for(const key in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(key))try{this.store[key]=this.onSerializeCallbacks[key]()}catch(e){console.warn("Exception in onSerialize callback: ",e)}return JSON.stringify(this.store)}}const REFERENCE_NODE_HOST="h",REFERENCE_NODE_BODY="b";var NodeNavigationStep;!function(NodeNavigationStep){NodeNavigationStep.FirstChild="f",NodeNavigationStep.NextSibling="n"}(NodeNavigationStep||(NodeNavigationStep={}));let _retrieveHydrationInfoImpl=(rNode,injector)=>null;function retrieveHydrationInfo(rNode,injector){return _retrieveHydrationInfoImpl(rNode,injector)}class ComponentRef$1{}class ComponentFactory$1{}const ERROR_COMPONENT="ngComponent";class _NullComponentFactoryResolver{resolveComponentFactory(component){throw function noComponentFactoryError(component){const error=Error(`No component factory found for ${stringify(component)}.`);return error[ERROR_COMPONENT]=component,error}(component)}}class ComponentFactoryResolver$1{static#_=this.NULL=new _NullComponentFactoryResolver}function injectElementRef(){return createElementRef(getCurrentTNode(),getLView())}function createElementRef(tNode,lView){return new ElementRef(getNativeByTNode(tNode,lView))}class ElementRef{constructor(nativeElement){this.nativeElement=nativeElement}static#_=this.__NG_ELEMENT_ID__=injectElementRef}class RendererFactory2{}class Renderer2{static#_=this.__NG_ELEMENT_ID__=()=>function injectRenderer2(){const lView=getLView(),nodeAtIndex=getComponentLViewByIndex(getCurrentTNode().index,lView);return(isLView(nodeAtIndex)?nodeAtIndex:lView)[RENDERER]}()}class Sanitizer{static#_=this.ɵprov=ɵɵdefineInjectable({token:Sanitizer,providedIn:"root",factory:()=>null})}const VERSION=new class Version{constructor(full){this.full=full,this.major=full.split(".")[0],this.minor=full.split(".")[1],this.patch=full.split(".").slice(2).join(".")}}("16.0.0"),NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR={};function markViewDirty(lView){for(;lView;){lView[FLAGS]|=64;const parent=getLViewParent(lView);if(isRootView(lView)&&!parent)return lView;lView=parent}return null}function getOriginalError(error){return error.ngOriginalError}class ErrorHandler{constructor(){this._console=console}handleError(error){const originalError=this._findOriginalError(error);this._console.error("ERROR",error),originalError&&this._console.error("ORIGINAL ERROR",originalError)}_findOriginalError(error){let e=error&&getOriginalError(error);for(;e&&getOriginalError(e);)e=getOriginalError(e);return e||null}}new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_HYDRATION_DOM_REUSE_ENABLED":"");const PRESERVE_HOST_CONTENT=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"PRESERVE_HOST_CONTENT":"",{providedIn:"root",factory:()=>false});class ReactiveLViewConsumer extends ReactiveNode{constructor(){super(...arguments),this.consumerAllowSignalWrites=!1,this._lView=null}set lView(lView){("undefined"==typeof ngDevMode||ngDevMode)&&assertEqual(this._lView,null,"Consumer already associated with a view."),this._lView=lView}onConsumerDependencyMayHaveChanged(){("undefined"==typeof ngDevMode||ngDevMode)&&assertDefined(this._lView,"Updating a signal during template or host binding execution is not allowed."),markViewDirty(this._lView)}onProducerUpdateValueVersion(){}get hasReadASignal(){return this.hasProducers}runInContext(fn,rf,ctx){const prevConsumer=setActiveConsumer(this);this.trackingVersion++;try{fn(rf,ctx)}finally{setActiveConsumer(prevConsumer)}}destroy(){this.trackingVersion++}}let currentConsumer=null;function getOrCreateCurrentLViewConsumer(){return currentConsumer??=new ReactiveLViewConsumer,currentConsumer}function getReactiveLViewConsumer(lView,slot){return lView[slot]??getOrCreateCurrentLViewConsumer()}function commitLViewConsumerIfHasProducers(lView,slot){const consumer=getOrCreateCurrentLViewConsumer();consumer.hasReadASignal&&(lView[slot]=currentConsumer,consumer.lView=lView,currentConsumer=new ReactiveLViewConsumer)}const NO_CHANGE="undefined"==typeof ngDevMode||ngDevMode?{__brand__:"NO_CHANGE"}:{};function selectIndexInternal(tView,lView,index,checkNoChangesMode){if(ngDevMode&&function assertIndexInDeclRange(lView,index){const tView=lView[1];assertBetween(HEADER_OFFSET,tView.bindingStartIndex,index)}(lView,index),!checkNoChangesMode){if(3==(3&lView[FLAGS])){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,index)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,index)}}setSelectedIndex(index)}const angularCoreDiEnv={ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵinject,ɵɵinvalidFactoryDep,resolveForwardRef};function compileInjectable(type,meta){let ngInjectableDef=null,ngFactoryDef=null;type.hasOwnProperty(NG_PROV_DEF)||Object.defineProperty(type,NG_PROV_DEF,{get:()=>{if(null===ngInjectableDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngInjectableDef=compiler.compileInjectable(angularCoreDiEnv,`ng:///${type.name}/ɵprov.js`,function getInjectableMetadata(type,srcMeta){const meta=srcMeta||{providedIn:null},compilerMeta={name:type.name,type,typeArgumentCount:0,providedIn:meta.providedIn};(isUseClassProvider(meta)||isUseFactoryProvider(meta))&&void 0!==meta.deps&&(compilerMeta.deps=convertDependencies(meta.deps));isUseClassProvider(meta)?compilerMeta.useClass=meta.useClass:!function isUseValueProvider(meta){return USE_VALUE in meta}(meta)?isUseFactoryProvider(meta)?compilerMeta.useFactory=meta.useFactory:function isUseExistingProvider(meta){return void 0!==meta.useExisting}(meta)&&(compilerMeta.useExisting=meta.useExisting):compilerMeta.useValue=meta.useValue;return compilerMeta}(type,meta))}return ngInjectableDef}}),type.hasOwnProperty(NG_FACTORY_DEF)||Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngFactoryDef=compiler.compileFactory(angularCoreDiEnv,`ng:///${type.name}/ɵfac.js`,{name:type.name,type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Injectable})}return ngFactoryDef},configurable:!0})}const USE_VALUE=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isUseClassProvider(meta){return void 0!==meta.useClass}function isUseFactoryProvider(meta){return void 0!==meta.useFactory}(function makeDecorator(name,props,parentClass,additionalProcessing,typeFn){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function DecoratorFactory(...args){if(this instanceof DecoratorFactory)return metaCtor.call(this,...args),this;const annotationInstance=new DecoratorFactory(...args);return function TypeDecorator(cls){typeFn&&typeFn(cls,...args);return(cls.hasOwnProperty(ANNOTATIONS)?cls[ANNOTATIONS]:Object.defineProperty(cls,ANNOTATIONS,{value:[]})[ANNOTATIONS]).push(annotationInstance),additionalProcessing&&additionalProcessing(cls),cls}}return parentClass&&(DecoratorFactory.prototype=Object.create(parentClass.prototype)),DecoratorFactory.prototype.ngMetadataName=name,DecoratorFactory.annotationCls=DecoratorFactory,DecoratorFactory}))})("Injectable",void 0,void 0,void 0,((type,meta)=>compileInjectable(type,meta)));function createInjector(defType,parent=null,additionalProviders=null,name){const injector=createInjectorWithoutInjectorInstances(defType,parent,additionalProviders,name);return injector.resolveInjectorInitializers(),injector}function createInjectorWithoutInjectorInstances(defType,parent=null,additionalProviders=null,name,scopes=new Set){const providers=[additionalProviders||EMPTY_ARRAY,importProvidersFrom(defType)];return name=name||("object"==typeof defType?void 0:stringify(defType)),new R3Injector(providers,parent||getNullInjector(),name||null,scopes)}class testing_Injector{static#_=this.THROW_IF_NOT_FOUND=THROW_IF_NOT_FOUND;static#_2=this.NULL=new NullInjector;static create(options,parent){if(Array.isArray(options))return createInjector({name:""},parent,options,"");{const name=options.name??"";return createInjector({name},options.parent,options.providers,name)}}static#_3=this.ɵprov=ɵɵdefineInjectable({token:testing_Injector,providedIn:"any",factory:()=>ɵɵinject(INJECTOR)});static#_4=this.__NG_ELEMENT_ID__=-1}function ɵɵdirectiveInject(token,flags=InjectFlags.Default){const lView=getLView();if(null===lView)return ngDevMode&&function assertInjectImplementationNotEqual(fn){ngDevMode&&assertNotEqual(_injectImplementation,fn,"Calling ɵɵinject would cause infinite recursion")}(ɵɵdirectiveInject),ɵɵinject(token,flags);return getOrCreateInjectable(getCurrentTNode(),lView,resolveForwardRef(token),flags)}function createLView(parentLView,tView,context,flags,host,tHostNode,environment,renderer,injector,embeddedViewInjector,hydrationInfo){const lView=tView.blueprint.slice();return lView[HOST]=host,lView[FLAGS]=140|flags,(null!==embeddedViewInjector||parentLView&&2048&parentLView[FLAGS])&&(lView[FLAGS]|=2048),resetPreOrderHookFlags(lView),ngDevMode&&tView.declTNode&&parentLView&&assertTNodeForLView(tView.declTNode,parentLView),lView[PARENT]=lView[DECLARATION_VIEW]=parentLView,lView[CONTEXT]=context,lView[ENVIRONMENT]=environment||parentLView&&parentLView[ENVIRONMENT],ngDevMode&&assertDefined(lView[ENVIRONMENT],"LViewEnvironment is required"),lView[RENDERER]=renderer||parentLView&&parentLView[RENDERER],ngDevMode&&assertDefined(lView[RENDERER],"Renderer is required"),lView[INJECTOR$1]=injector||parentLView&&parentLView[INJECTOR$1]||null,lView[T_HOST]=tHostNode,lView[ID]=function getUniqueLViewId(){return uniqueIdCounter++}(),lView[HYDRATION]=hydrationInfo,lView[EMBEDDED_VIEW_INJECTOR]=embeddedViewInjector,ngDevMode&&assertEqual(2!=tView.type||null!==parentLView,!0,"Embedded views must have parentLView"),lView[DECLARATION_COMPONENT_VIEW]=2==tView.type?parentLView[DECLARATION_COMPONENT_VIEW]:lView,lView}function getOrCreateTNode(tView,index,type,name,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&function assertPureTNodeType(type){2!==type&&1!==type&&4!==type&&8!==type&&32!==type&&16!==type&&64!==type&&throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`)}(type);let tNode=tView.data[index];if(null===tNode)tNode=createTNodeAtIndex(tView,index,type,name,attrs),function isInI18nBlock(){return instructionState.lFrame.inI18n}()&&(tNode.flags|=32);else if(64&tNode.type){tNode.type=type,tNode.value=name,tNode.attrs=attrs;const parent=getCurrentParentTNode();tNode.injectorIndex=null===parent?-1:parent.injectorIndex,ngDevMode&&assertTNodeForTView(tNode,tView),ngDevMode&&assertEqual(index,tNode.index,"Expecting same index")}return setCurrentTNode(tNode,!0),tNode}function createTNodeAtIndex(tView,index,type,name,attrs){const currentTNode=getCurrentTNodePlaceholderOk(),isParent=isCurrentTNodeParent(),parent=isParent?currentTNode:currentTNode&&currentTNode.parent,tNode=tView.data[index]=function createTNode(tView,tParent,type,index,value,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&assertNotSame(attrs,void 0,"'undefined' is not valid value for 'attrs'"),ngDevMode&&ngDevMode.tNode++,ngDevMode&&tParent&&assertTNodeForTView(tParent,tView);let injectorIndex=tParent?tParent.injectorIndex:-1;const tNode={type,index,insertBeforeIndex:null,injectorIndex,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags:0,providerIndexes:0,value,attrs,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:tParent,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0};ngDevMode&&Object.seal(tNode);return tNode}(tView,parent,type,index,name,attrs);return null===tView.firstChild&&(tView.firstChild=tNode),null!==currentTNode&&(isParent?null==currentTNode.child&&null!==tNode.parent&&(currentTNode.child=tNode):null===currentTNode.next&&(currentTNode.next=tNode,tNode.prev=currentTNode)),tNode}function allocExpando(tView,lView,numSlotsToAlloc,initialValue){if(0===numSlotsToAlloc)return-1;ngDevMode&&(assertFirstCreatePass(tView),assertSame(tView,lView[TVIEW],"`LView` must be associated with `TView`!"),assertEqual(tView.data.length,lView.length,"Expecting LView to be same size as TView"),assertEqual(tView.data.length,tView.blueprint.length,"Expecting Blueprint to be same size as TView"),assertFirstUpdatePass(tView));const allocIdx=lView.length;for(let i=0;i<numSlotsToAlloc;i++)lView.push(initialValue),tView.blueprint.push(initialValue),tView.data.push(null);return allocIdx}function executeTemplate(tView,lView,templateFn,rf,context){const consumer=getReactiveLViewConsumer(lView,REACTIVE_TEMPLATE_CONSUMER),prevSelectedIndex=getSelectedIndex(),isUpdatePhase=2&rf;try{setSelectedIndex(-1),isUpdatePhase&&lView.length>HEADER_OFFSET&&selectIndexInternal(tView,lView,HEADER_OFFSET,!!ngDevMode&&isInCheckNoChangesMode());if(profiler(isUpdatePhase?2:0,context),isUpdatePhase)consumer.runInContext(templateFn,rf,context);else{const prevConsumer=setActiveConsumer(null);try{templateFn(rf,context)}finally{setActiveConsumer(prevConsumer)}}}finally{isUpdatePhase&&null===lView[REACTIVE_TEMPLATE_CONSUMER]&&commitLViewConsumerIfHasProducers(lView,REACTIVE_TEMPLATE_CONSUMER),setSelectedIndex(prevSelectedIndex);profiler(isUpdatePhase?3:1,context)}}function executeContentQueries(tView,tNode,lView){if(isContentQueryHost(tNode)){const prevConsumer=setActiveConsumer(null);try{const start=tNode.directiveStart,end=tNode.directiveEnd;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const def=tView.data[directiveIndex];def.contentQueries&&def.contentQueries(1,lView[directiveIndex],directiveIndex)}}finally{setActiveConsumer(prevConsumer)}}}function getOrCreateComponentTView(def){const tView=def.tView;if(null===tView||tView.incompleteFirstPass){const declTNode=null;return def.tView=createTView(1,declTNode,def.template,def.decls,def.vars,def.directiveDefs,def.pipeDefs,def.viewQuery,def.schemas,def.consts,def.id)}return tView}function createTView(type,declTNode,templateFn,decls,vars,directives,pipes,viewQuery,schemas,constsOrFactory,ssrId){ngDevMode&&ngDevMode.tView++;const bindingStartIndex=HEADER_OFFSET+decls,initialViewLength=bindingStartIndex+vars,blueprint=function createViewBlueprint(bindingStartIndex,initialViewLength){const blueprint=[];for(let i=0;i<initialViewLength;i++)blueprint.push(i<bindingStartIndex?null:NO_CHANGE);return blueprint}(bindingStartIndex,initialViewLength),consts="function"==typeof constsOrFactory?constsOrFactory():constsOrFactory,tView=blueprint[TVIEW]={type,blueprint,template:templateFn,queries:null,viewQuery,declTNode,data:blueprint.slice().fill(null,bindingStartIndex),bindingStartIndex,expandoStartIndex:initialViewLength,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof directives?directives():directives,pipeRegistry:"function"==typeof pipes?pipes():pipes,firstChild:null,schemas,consts,incompleteFirstPass:!1,ssrId};return ngDevMode&&Object.seal(tView),tView}function locateHostElement(renderer,elementOrSelector,encapsulation,injector){const preserveContent=injector.get(PRESERVE_HOST_CONTENT,false)||encapsulation===ViewEncapsulation.ShadowDom,rootElement=renderer.selectRootElement(elementOrSelector,preserveContent);return function applyRootElementTransform(rootElement){_applyRootElementTransformImpl(rootElement)}(rootElement),rootElement}let _applyRootElementTransformImpl=rootElement=>null;function generatePropertyAliases(aliasMap,directiveIndex,propertyAliases,hostDirectiveAliasMap){for(let publicName in aliasMap)if(aliasMap.hasOwnProperty(publicName)){propertyAliases=null===propertyAliases?{}:propertyAliases;const internalName=aliasMap[publicName];null===hostDirectiveAliasMap?addPropertyAlias(propertyAliases,directiveIndex,publicName,internalName):hostDirectiveAliasMap.hasOwnProperty(publicName)&&addPropertyAlias(propertyAliases,directiveIndex,hostDirectiveAliasMap[publicName],internalName)}return propertyAliases}function addPropertyAlias(propertyAliases,directiveIndex,publicName,internalName){propertyAliases.hasOwnProperty(publicName)?propertyAliases[publicName].push(directiveIndex,internalName):propertyAliases[publicName]=[directiveIndex,internalName]}function initializeDirectives(tView,lView,tNode,directives,exportsMap,hostDirectiveDefs){ngDevMode&&assertFirstCreatePass(tView);for(let i=0;i<directives.length;i++)diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,directives[i].type);!function initTNodeFlags(tNode,index,numberOfDirectives){ngDevMode&&assertNotEqual(numberOfDirectives,tNode.directiveEnd-tNode.directiveStart,"Reached the max number of directives"),tNode.flags|=1,tNode.directiveStart=index,tNode.directiveEnd=index+numberOfDirectives,tNode.providerIndexes=index}(tNode,tView.data.length,directives.length);for(let i=0;i<directives.length;i++){const def=directives[i];def.providersResolver&&def.providersResolver(def)}let preOrderHooksFound=!1,preOrderCheckHooksFound=!1,directiveIdx=allocExpando(tView,lView,directives.length,null);ngDevMode&&assertSame(directiveIdx,tNode.directiveStart,"TNode.directiveStart should point to just allocated space");for(let i=0;i<directives.length;i++){const def=directives[i];tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs),configureViewWithDirective(tView,tNode,lView,directiveIdx,def),saveNameToExportMap(directiveIdx,def,exportsMap),null!==def.contentQueries&&(tNode.flags|=4),null===def.hostBindings&&null===def.hostAttrs&&0===def.hostVars||(tNode.flags|=64);const lifeCycleHooks=def.type.prototype;!preOrderHooksFound&&(lifeCycleHooks.ngOnChanges||lifeCycleHooks.ngOnInit||lifeCycleHooks.ngDoCheck)&&((tView.preOrderHooks??=[]).push(tNode.index),preOrderHooksFound=!0),preOrderCheckHooksFound||!lifeCycleHooks.ngOnChanges&&!lifeCycleHooks.ngDoCheck||((tView.preOrderCheckHooks??=[]).push(tNode.index),preOrderCheckHooksFound=!0),directiveIdx++}!function initializeInputAndOutputAliases(tView,tNode,hostDirectiveDefinitionMap){ngDevMode&&assertFirstCreatePass(tView);const start=tNode.directiveStart,end=tNode.directiveEnd,tViewData=tView.data,tNodeAttrs=tNode.attrs,inputsFromAttrs=[];let inputsStore=null,outputsStore=null;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const directiveDef=tViewData[directiveIndex],aliasData=hostDirectiveDefinitionMap?hostDirectiveDefinitionMap.get(directiveDef):null,aliasedInputs=aliasData?aliasData.inputs:null,aliasedOutputs=aliasData?aliasData.outputs:null;inputsStore=generatePropertyAliases(directiveDef.inputs,directiveIndex,inputsStore,aliasedInputs),outputsStore=generatePropertyAliases(directiveDef.outputs,directiveIndex,outputsStore,aliasedOutputs);const initialInputs=null===inputsStore||null===tNodeAttrs||isInlineTemplate(tNode)?null:generateInitialInputs(inputsStore,directiveIndex,tNodeAttrs);inputsFromAttrs.push(initialInputs)}null!==inputsStore&&(inputsStore.hasOwnProperty("class")&&(tNode.flags|=8),inputsStore.hasOwnProperty("style")&&(tNode.flags|=16)),tNode.initialInputs=inputsFromAttrs,tNode.inputs=inputsStore,tNode.outputs=outputsStore}(tView,tNode,hostDirectiveDefs)}function invokeDirectivesHostBindings(tView,lView,tNode){const start=tNode.directiveStart,end=tNode.directiveEnd,elementIndex=tNode.index,currentDirectiveIndex=function getCurrentDirectiveIndex(){return instructionState.lFrame.currentDirectiveIndex}();try{setSelectedIndex(elementIndex);for(let dirIndex=start;dirIndex<end;dirIndex++){const def=tView.data[dirIndex],directive=lView[dirIndex];setCurrentDirectiveIndex(dirIndex),null===def.hostBindings&&0===def.hostVars&&null===def.hostAttrs||invokeHostBindingsInCreationMode(def,directive)}}finally{setSelectedIndex(-1),setCurrentDirectiveIndex(currentDirectiveIndex)}}function invokeHostBindingsInCreationMode(def,directive){null!==def.hostBindings&&def.hostBindings(1,directive)}function markAsComponentHost(tView,hostTNode,componentOffset){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertGreaterThan(componentOffset,-1,"componentOffset must be great than -1"),hostTNode.componentOffset=componentOffset,(tView.components??=[]).push(hostTNode.index)}function saveNameToExportMap(directiveIdx,def,exportsMap){if(exportsMap){if(def.exportAs)for(let i=0;i<def.exportAs.length;i++)exportsMap[def.exportAs[i]]=directiveIdx;isComponentDef(def)&&(exportsMap[""]=directiveIdx)}}function configureViewWithDirective(tView,tNode,lView,directiveIndex,def){ngDevMode&&assertGreaterThanOrEqual(directiveIndex,HEADER_OFFSET,"Must be in Expando section"),tView.data[directiveIndex]=def;const directiveFactory=def.factory||(def.factory=getFactoryDef(def.type,!0)),nodeInjectorFactory=new NodeInjectorFactory(directiveFactory,isComponentDef(def),ɵɵdirectiveInject);tView.blueprint[directiveIndex]=nodeInjectorFactory,lView[directiveIndex]=nodeInjectorFactory,function registerHostBindingOpCodes(tView,tNode,directiveIdx,directiveVarsIdx,def){ngDevMode&&assertFirstCreatePass(tView);const hostBindings=def.hostBindings;if(hostBindings){let hostBindingOpCodes=tView.hostBindingOpCodes;null===hostBindingOpCodes&&(hostBindingOpCodes=tView.hostBindingOpCodes=[]);const elementIndx=~tNode.index;(function lastSelectedElementIdx(hostBindingOpCodes){let i=hostBindingOpCodes.length;for(;i>0;){const value=hostBindingOpCodes[--i];if("number"==typeof value&&value<0)return value}return 0})(hostBindingOpCodes)!=elementIndx&&hostBindingOpCodes.push(elementIndx),hostBindingOpCodes.push(directiveIdx,directiveVarsIdx,hostBindings)}}(tView,tNode,directiveIndex,allocExpando(tView,lView,def.hostVars,NO_CHANGE),def)}function writeToDirectiveInput(def,instance,publicName,privateName,value){const prevConsumer=setActiveConsumer(null);try{null!==def.setInput?def.setInput(instance,value,publicName,privateName):instance[privateName]=value}finally{setActiveConsumer(prevConsumer)}}function generateInitialInputs(inputs,directiveIndex,attrs){let inputsToStore=null,i=0;for(;i<attrs.length;){const attrName=attrs[i];if(0!==attrName)if(5!==attrName){if("number"==typeof attrName)break;if(inputs.hasOwnProperty(attrName)){null===inputsToStore&&(inputsToStore=[]);const inputConfig=inputs[attrName];for(let j=0;j<inputConfig.length;j+=2)if(inputConfig[j]===directiveIndex){inputsToStore.push(attrName,inputConfig[j+1],attrs[i+1]);break}}i+=2}else i+=2;else i+=4}return inputsToStore}function createLContainer(hostNative,currentView,native,tNode){ngDevMode&&assertLView(currentView);const lContainer=[hostNative,!0,!1,currentView,null,0,tNode,native,null,null,null];return ngDevMode&&assertEqual(lContainer.length,CONTAINER_HEADER_OFFSET,"Should allocate correct number of slots for LContainer header."),lContainer}function refreshContentQueries(tView,lView){const contentQueries=tView.contentQueries;if(null!==contentQueries)for(let i=0;i<contentQueries.length;i+=2){const queryStartIdx=contentQueries[i],directiveDefIdx=contentQueries[i+1];if(-1!==directiveDefIdx){const directiveDef=tView.data[directiveDefIdx];ngDevMode&&assertDefined(directiveDef,"DirectiveDef not found."),ngDevMode&&assertDefined(directiveDef.contentQueries,"contentQueries function should be defined"),setCurrentQueryIndex(queryStartIdx),directiveDef.contentQueries(2,lView[directiveDefIdx],directiveDefIdx)}}}function addToViewTree(lView,lViewOrLContainer){return lView[CHILD_HEAD]?lView[CHILD_TAIL][NEXT]=lViewOrLContainer:lView[CHILD_HEAD]=lViewOrLContainer,lView[CHILD_TAIL]=lViewOrLContainer,lViewOrLContainer}function executeViewQueryFn(flags,viewQueryFn,component){ngDevMode&&assertDefined(viewQueryFn,"View queries function to execute must be defined."),setCurrentQueryIndex(0);const prevConsumer=setActiveConsumer(null);try{viewQueryFn(flags,component)}finally{setActiveConsumer(prevConsumer)}}function handleError(lView,error){const injector=lView[INJECTOR$1],errorHandler=injector?injector.get(ErrorHandler,null):null;errorHandler&&errorHandler.handleError(error)}function setInputsForProperty(tView,lView,inputs,publicName,value){for(let i=0;i<inputs.length;){const index=inputs[i++],privateName=inputs[i++],instance=lView[index];ngDevMode&&assertIndexInRange(lView,index);writeToDirectiveInput(tView.data[index],instance,publicName,privateName,value)}}function renderComponent(hostLView,componentHostIdx){ngDevMode&&assertEqual(isCreationMode(hostLView),!0,"Should be run in creation mode");const componentView=getComponentLViewByIndex(componentHostIdx,hostLView),componentTView=componentView[TVIEW];!function syncViewWithBlueprint(tView,lView){for(let i=lView.length;i<tView.blueprint.length;i++)lView.push(tView.blueprint[i])}(componentTView,componentView);const hostRNode=componentView[HOST];null!==hostRNode&&null===componentView[HYDRATION]&&(componentView[HYDRATION]=retrieveHydrationInfo(hostRNode,componentView[INJECTOR$1])),renderView(componentTView,componentView,componentView[CONTEXT])}function renderView(tView,lView,context){ngDevMode&&assertEqual(isCreationMode(lView),!0,"Should be run in creation mode"),enterView(lView);try{const viewQuery=tView.viewQuery;null!==viewQuery&&executeViewQueryFn(1,viewQuery,context);const templateFn=tView.template;null!==templateFn&&executeTemplate(tView,lView,templateFn,1,context),tView.firstCreatePass&&(tView.firstCreatePass=!1),tView.staticContentQueries&&refreshContentQueries(tView,lView),tView.staticViewQueries&&executeViewQueryFn(2,tView.viewQuery,context);const components=tView.components;null!==components&&function renderChildComponents(hostLView,components){for(let i=0;i<components.length;i++)renderComponent(hostLView,components[i])}(lView,components)}catch(error){throw tView.firstCreatePass&&(tView.incompleteFirstPass=!0,tView.firstCreatePass=!1),error}finally{lView[FLAGS]&=-5,leaveView()}}class DestroyRef{static#_=this.__NG_ELEMENT_ID__=injectDestroyRef;static#_2=this.__NG_ENV_ID__=injector=>injector}class NodeInjectorDestroyRef extends DestroyRef{constructor(_lView){super(),this._lView=_lView}onDestroy(callback){return storeLViewOnDestroy(this._lView,callback),()=>function removeLViewOnDestroy(lView,onDestroyCallback){if(null===lView[ON_DESTROY_HOOKS])return;const destroyCBIdx=lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);-1!==destroyCBIdx&&lView[ON_DESTROY_HOOKS].splice(destroyCBIdx,1)}(this._lView,callback)}}function injectDestroyRef(){return new NodeInjectorDestroyRef(getLView())}class EffectManager{constructor(){this.all=new Set,this.queue=new Map}create(effectFn,destroyRef,allowSignalWrites){const zone="undefined"==typeof Zone?null:Zone.current,watch=new Watch(effectFn,(watch=>{this.all.has(watch)&&this.queue.set(watch,zone)}),allowSignalWrites);let unregisterOnDestroy;this.all.add(watch),watch.notify();const destroy=()=>{watch.cleanup(),unregisterOnDestroy?.(),this.all.delete(watch),this.queue.delete(watch)};return unregisterOnDestroy=destroyRef?.onDestroy(destroy),{destroy}}flush(){if(0!==this.queue.size)for(const[watch,zone]of this.queue)this.queue.delete(watch),zone?zone.run((()=>watch.run())):watch.run()}get isQueueEmpty(){return 0===this.queue.size}static#_=this.ɵprov=ɵɵdefineInjectable({token:EffectManager,providedIn:"root",factory:()=>new EffectManager})}function computeStaticStyling(tNode,attrs,writeToHost){ngDevMode&&assertFirstCreatePass(getTView(),"Expecting to be called in first template pass only");let styles=writeToHost?tNode.styles:null,classes=writeToHost?tNode.classes:null,mode=0;if(null!==attrs)for(let i=0;i<attrs.length;i++){const value=attrs[i];if("number"==typeof value)mode=value;else if(1==mode)classes=concatStringsWithSpace(classes,value);else if(2==mode){styles=concatStringsWithSpace(styles,value+": "+attrs[++i]+";")}}writeToHost?tNode.styles=styles:tNode.stylesWithoutHost=styles,writeToHost?tNode.classes=classes:tNode.classesWithoutHost=classes}function collectNativeNodes(tView,lView,tNode,result,isProjection=!1){for(;null!==tNode;){ngDevMode&&assertTNodeType(tNode,63);const lNode=lView[tNode.index];if(null!==lNode&&result.push(unwrapRNode(lNode)),isLContainer(lNode)){for(let i=CONTAINER_HEADER_OFFSET;i<lNode.length;i++){const lViewInAContainer=lNode[i],lViewFirstChildTNode=lViewInAContainer[TVIEW].firstChild;null!==lViewFirstChildTNode&&collectNativeNodes(lViewInAContainer[TVIEW],lViewInAContainer,lViewFirstChildTNode,result)}lNode[NATIVE]!==lNode[HOST]&&result.push(lNode[NATIVE])}const tNodeType=tNode.type;if(8&tNodeType)collectNativeNodes(tView,lView,tNode.child,result);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)result.push(rNode)}else if(16&tNodeType){const nodesInSlot=getProjectionNodes(lView,tNode);if(Array.isArray(nodesInSlot))result.push(...nodesInSlot);else{const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);ngDevMode&&assertParentView(parentView),collectNativeNodes(parentView[TVIEW],parentView,nodesInSlot,result,!0)}}tNode=isProjection?tNode.projectionNext:tNode.next}return result}function detectChangesInternal(tView,lView,context,notifyErrorHandler=!0){const rendererFactory=lView[ENVIRONMENT].rendererFactory,checkNoChangesMode=!!ngDevMode&&isInCheckNoChangesMode();!checkNoChangesMode&&rendererFactory.begin&&rendererFactory.begin();try{refreshView(tView,lView,tView.template,context)}catch(error){throw notifyErrorHandler&&handleError(lView,error),error}finally{!checkNoChangesMode&&rendererFactory.end&&rendererFactory.end(),!checkNoChangesMode&&lView[ENVIRONMENT].effectManager?.flush()}}function checkNoChangesInternal(tView,lView,context,notifyErrorHandler=!0){setIsInCheckNoChangesMode(!0);try{detectChangesInternal(tView,lView,context,notifyErrorHandler)}finally{setIsInCheckNoChangesMode(!1)}}function refreshView(tView,lView,templateFn,context){ngDevMode&&assertEqual(isCreationMode(lView),!1,"Should be run in update mode");const flags=lView[FLAGS];if(256==(256&flags))return;const isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode();!isInCheckNoChangesPass&&lView[ENVIRONMENT].effectManager?.flush(),enterView(lView);try{resetPreOrderHookFlags(lView),setBindingIndex(tView.bindingStartIndex),null!==templateFn&&executeTemplate(tView,lView,templateFn,2,context);const hooksInitPhaseCompleted=3==(3&flags);if(!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,null)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,null),incrementInitPhaseFlags(lView,0)}if(function markTransplantedViewsForRefresh(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer)){if(!lContainer[HAS_TRANSPLANTED_VIEWS])continue;const movedViews=lContainer[MOVED_VIEWS];ngDevMode&&assertDefined(movedViews,"Transplanted View flags set but missing MOVED_VIEWS");for(let i=0;i<movedViews.length;i++){const movedLView=movedViews[i],insertionLContainer=movedLView[PARENT];ngDevMode&&assertLContainer(insertionLContainer),markViewForRefresh(movedLView)}}}(lView),function refreshEmbeddedViews(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer))for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const embeddedLView=lContainer[i],embeddedTView=embeddedLView[TVIEW];ngDevMode&&assertDefined(embeddedTView,"TView must be allocated"),viewAttachedToChangeDetector(embeddedLView)&&refreshView(embeddedTView,embeddedLView,embeddedTView.template,embeddedLView[CONTEXT])}}(lView),null!==tView.contentQueries&&refreshContentQueries(tView,lView),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const contentCheckHooks=tView.contentCheckHooks;null!==contentCheckHooks&&executeCheckHooks(lView,contentCheckHooks)}else{const contentHooks=tView.contentHooks;null!==contentHooks&&executeInitAndCheckHooks(lView,contentHooks,1),incrementInitPhaseFlags(lView,1)}!function processHostBindingOpCodes(tView,lView){const hostBindingOpCodes=tView.hostBindingOpCodes;if(null===hostBindingOpCodes)return;const consumer=getReactiveLViewConsumer(lView,REACTIVE_HOST_BINDING_CONSUMER);try{for(let i=0;i<hostBindingOpCodes.length;i++){const opCode=hostBindingOpCodes[i];if(opCode<0)setSelectedIndex(~opCode);else{const directiveIdx=opCode,bindingRootIndx=hostBindingOpCodes[++i],hostBindingFn=hostBindingOpCodes[++i];setBindingRootForHostBindings(bindingRootIndx,directiveIdx);const context=lView[directiveIdx];consumer.runInContext(hostBindingFn,2,context)}}}finally{null===lView[REACTIVE_HOST_BINDING_CONSUMER]&&commitLViewConsumerIfHasProducers(lView,REACTIVE_HOST_BINDING_CONSUMER),setSelectedIndex(-1)}}(tView,lView);const components=tView.components;null!==components&&function refreshChildComponents(hostLView,components){for(let i=0;i<components.length;i++)refreshComponent(hostLView,components[i])}(lView,components);const viewQuery=tView.viewQuery;if(null!==viewQuery&&executeViewQueryFn(2,viewQuery,context),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const viewCheckHooks=tView.viewCheckHooks;null!==viewCheckHooks&&executeCheckHooks(lView,viewCheckHooks)}else{const viewHooks=tView.viewHooks;null!==viewHooks&&executeInitAndCheckHooks(lView,viewHooks,2),incrementInitPhaseFlags(lView,2)}!0===tView.firstUpdatePass&&(tView.firstUpdatePass=!1),isInCheckNoChangesPass||(lView[FLAGS]&=-73),clearViewRefreshFlag(lView)}finally{leaveView()}}function refreshComponent(hostLView,componentHostIdx){ngDevMode&&assertEqual(isCreationMode(hostLView),!1,"Should be run in update mode");const componentView=getComponentLViewByIndex(componentHostIdx,hostLView);if(viewAttachedToChangeDetector(componentView)){const tView=componentView[TVIEW];80&componentView[FLAGS]?refreshView(tView,componentView,tView.template,componentView[CONTEXT]):componentView[DESCENDANT_VIEWS_TO_REFRESH]>0&&refreshContainsDirtyView(componentView)}}function refreshContainsDirtyView(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer))for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const embeddedLView=lContainer[i];if(viewAttachedToChangeDetector(embeddedLView))if(1024&embeddedLView[FLAGS]){const embeddedTView=embeddedLView[TVIEW];ngDevMode&&assertDefined(embeddedTView,"TView must be allocated"),refreshView(embeddedTView,embeddedLView,embeddedTView.template,embeddedLView[CONTEXT])}else embeddedLView[DESCENDANT_VIEWS_TO_REFRESH]>0&&refreshContainsDirtyView(embeddedLView)}const components=lView[TVIEW].components;if(null!==components)for(let i=0;i<components.length;i++){const componentView=getComponentLViewByIndex(components[i],lView);viewAttachedToChangeDetector(componentView)&&componentView[DESCENDANT_VIEWS_TO_REFRESH]>0&&refreshContainsDirtyView(componentView)}}class ViewRef{get rootNodes(){const lView=this._lView,tView=lView[TVIEW];return collectNativeNodes(tView,lView,tView.firstChild,[])}constructor(_lView,_cdRefInjectingView){this._lView=_lView,this._cdRefInjectingView=_cdRefInjectingView,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[CONTEXT]}set context(value){this._lView[CONTEXT]=value}get destroyed(){return 256==(256&this._lView[FLAGS])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const parent=this._lView[PARENT];if(isLContainer(parent)){const viewRefs=parent[8],index=viewRefs?viewRefs.indexOf(this):-1;index>-1&&(ngDevMode&&assertEqual(index,parent.indexOf(this._lView)-CONTAINER_HEADER_OFFSET,"An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array."),detachView(parent,index),removeFromArray(viewRefs,index))}this._attachedToViewContainer=!1}destroyLView(this._lView[TVIEW],this._lView)}onDestroy(callback){storeLViewOnDestroy(this._lView,callback)}markForCheck(){markViewDirty(this._cdRefInjectingView||this._lView)}detach(){this._lView[FLAGS]&=-129}reattach(){this._lView[FLAGS]|=128}detectChanges(){detectChangesInternal(this._lView[TVIEW],this._lView,this.context)}checkNoChanges(){ngDevMode&&checkNoChangesInternal(this._lView[TVIEW],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new RuntimeError(902,ngDevMode&&"This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,function renderDetachView(tView,lView){applyView(tView,lView,lView[RENDERER],2,null,null)}(this._lView[TVIEW],this._lView)}attachToAppRef(appRef){if(this._attachedToViewContainer)throw new RuntimeError(902,ngDevMode&&"This view is already attached to a ViewContainer!");this._appRef=appRef}}class RootViewRef extends ViewRef{constructor(_view){super(_view),this._view=_view}detectChanges(){const lView=this._view;detectChangesInternal(lView[TVIEW],lView,lView[CONTEXT],!1)}checkNoChanges(){if(ngDevMode){const lView=this._view;checkNoChangesInternal(lView[TVIEW],lView,lView[CONTEXT],!1)}}get context(){return null}}class ComponentFactoryResolver extends ComponentFactoryResolver$1{constructor(ngModule){super(),this.ngModule=ngModule}resolveComponentFactory(component){ngDevMode&&function assertComponentType(actual,msg="Type passed in is not ComponentType, it does not have 'ɵcmp' property."){getComponentDef$1(actual)||throwError(msg)}(component);const componentDef=getComponentDef$1(component);return new ComponentFactory(componentDef,this.ngModule)}}function toRefArray(map){const array=[];for(let nonMinified in map)if(map.hasOwnProperty(nonMinified)){const minified=map[nonMinified];array.push({propName:minified,templateName:nonMinified})}return array}class ChainedInjector{constructor(injector,parentInjector){this.injector=injector,this.parentInjector=parentInjector}get(token,notFoundValue,flags){flags=convertToBitFlags(flags);const value=this.injector.get(token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,flags);return value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR?value:this.parentInjector.get(token,notFoundValue,flags)}}class ComponentFactory extends ComponentFactory$1{get inputs(){return toRefArray(this.componentDef.inputs)}get outputs(){return toRefArray(this.componentDef.outputs)}constructor(componentDef,ngModule){super(),this.componentDef=componentDef,this.ngModule=ngModule,this.componentType=componentDef.type,this.selector=stringifyCSSSelectorList(componentDef.selectors),this.ngContentSelectors=componentDef.ngContentSelectors?componentDef.ngContentSelectors:[],this.isBoundToModule=!!ngModule}create(injector,projectableNodes,rootSelectorOrNode,environmentInjector){let realEnvironmentInjector=(environmentInjector=environmentInjector||this.ngModule)instanceof EnvironmentInjector?environmentInjector:environmentInjector?.injector;realEnvironmentInjector&&null!==this.componentDef.getStandaloneInjector&&(realEnvironmentInjector=this.componentDef.getStandaloneInjector(realEnvironmentInjector)||realEnvironmentInjector);const rootViewInjector=realEnvironmentInjector?new ChainedInjector(injector,realEnvironmentInjector):injector,rendererFactory=rootViewInjector.get(RendererFactory2,null);if(null===rendererFactory)throw new RuntimeError(407,ngDevMode&&"Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");const environment={rendererFactory,sanitizer:rootViewInjector.get(Sanitizer,null),effectManager:rootViewInjector.get(EffectManager,null)},hostRenderer=rendererFactory.createRenderer(null,this.componentDef),elementName=this.componentDef.selectors[0][0]||"div",hostRNode=rootSelectorOrNode?locateHostElement(hostRenderer,rootSelectorOrNode,this.componentDef.encapsulation,rootViewInjector):createElementNode(hostRenderer,elementName,function getNamespace(elementName){const name=elementName.toLowerCase();return"svg"===name?"svg":"math"===name?"math":null}(elementName)),rootFlags=this.componentDef.onPush?576:528,rootTView=createTView(0,null,null,1,0,null,null,null,null,null,null),rootLView=createLView(null,rootTView,null,rootFlags,null,null,environment,hostRenderer,rootViewInjector,null,null);let component,tElementNode;enterView(rootLView);try{const rootComponentDef=this.componentDef;let rootDirectives,hostDirectiveDefs=null;rootComponentDef.findHostDirectiveDefs?(rootDirectives=[],hostDirectiveDefs=new Map,rootComponentDef.findHostDirectiveDefs(rootComponentDef,rootDirectives,hostDirectiveDefs),rootDirectives.push(rootComponentDef)):rootDirectives=[rootComponentDef];const componentView=function createRootComponentView(tNode,hostRNode,rootComponentDef,rootDirectives,rootView,environment,hostRenderer){const tView=rootView[TVIEW];!function applyRootComponentStyling(rootDirectives,tNode,rNode,hostRenderer){for(const def of rootDirectives)tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs);null!==tNode.mergedAttrs&&(computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==rNode&&setupStaticAttributes(hostRenderer,rNode,tNode))}(rootDirectives,tNode,hostRNode,hostRenderer);let hydrationInfo=null;null!==hostRNode&&(hydrationInfo=retrieveHydrationInfo(hostRNode,rootView[INJECTOR$1]));const viewRenderer=environment.rendererFactory.createRenderer(hostRNode,rootComponentDef),componentView=createLView(rootView,getOrCreateComponentTView(rootComponentDef),null,rootComponentDef.onPush?64:16,rootView[tNode.index],tNode,environment,viewRenderer,null,null,hydrationInfo);tView.firstCreatePass&&markAsComponentHost(tView,tNode,rootDirectives.length-1);return addToViewTree(rootView,componentView),rootView[tNode.index]=componentView}(function createRootComponentTNode(lView,rNode){const tView=lView[TVIEW],index=HEADER_OFFSET;return ngDevMode&&assertIndexInRange(lView,index),lView[index]=rNode,getOrCreateTNode(tView,index,2,"#host",null)}(rootLView,hostRNode),hostRNode,rootComponentDef,rootDirectives,rootLView,environment,hostRenderer);tElementNode=getTNode(rootTView,HEADER_OFFSET),hostRNode&&function setRootNodeAttributes(hostRenderer,componentDef,hostRNode,rootSelectorOrNode){if(rootSelectorOrNode)setUpAttributes(hostRenderer,hostRNode,["ng-version",VERSION.full]);else{const{attrs,classes}=function extractAttrsAndClassesFromSelector(selector){const attrs=[],classes=[];let i=1,mode=2;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)2===mode?""!==valueOrMarker&&attrs.push(valueOrMarker,selector[++i]):8===mode&&classes.push(valueOrMarker);else{if(!isPositive(mode))break;mode=valueOrMarker}i++}return{attrs,classes}}(componentDef.selectors[0]);attrs&&setUpAttributes(hostRenderer,hostRNode,attrs),classes&&classes.length>0&&writeDirectClass(hostRenderer,hostRNode,classes.join(" "))}}(hostRenderer,rootComponentDef,hostRNode,rootSelectorOrNode),void 0!==projectableNodes&&function projectNodes(tNode,ngContentSelectors,projectableNodes){const projection=tNode.projection=[];for(let i=0;i<ngContentSelectors.length;i++){const nodesforSlot=projectableNodes[i];projection.push(null!=nodesforSlot?Array.from(nodesforSlot):null)}}(tElementNode,this.ngContentSelectors,projectableNodes),component=function createRootComponent(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,hostFeatures){const rootTNode=getCurrentTNode();ngDevMode&&assertDefined(rootTNode,"tNode should have been already created");const tView=rootLView[TVIEW],native=getNativeByTNode(rootTNode,rootLView);initializeDirectives(tView,rootLView,rootTNode,rootDirectives,null,hostDirectiveDefs);for(let i=0;i<rootDirectives.length;i++){attachPatchData(getNodeInjectable(rootLView,tView,rootTNode.directiveStart+i,rootTNode),rootLView)}invokeDirectivesHostBindings(tView,rootLView,rootTNode),native&&attachPatchData(native,rootLView);ngDevMode&&assertGreaterThan(rootTNode.componentOffset,-1,"componentOffset must be great than -1");const component=getNodeInjectable(rootLView,tView,rootTNode.directiveStart+rootTNode.componentOffset,rootTNode);if(componentView[CONTEXT]=rootLView[CONTEXT]=component,null!==hostFeatures)for(const feature of hostFeatures)feature(component,rootComponentDef);return executeContentQueries(tView,rootTNode,componentView),component}(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,[LifecycleHooksFeature]),renderView(rootTView,rootLView,null)}finally{leaveView()}return new ComponentRef(this.componentType,component,createElementRef(tElementNode,rootLView),rootLView,tElementNode)}}class ComponentRef extends ComponentRef$1{constructor(componentType,instance,location,_rootLView,_tNode){super(),this.location=location,this._rootLView=_rootLView,this._tNode=_tNode,this.previousInputValues=null,this.instance=instance,this.hostView=this.changeDetectorRef=new RootViewRef(_rootLView),this.componentType=componentType}setInput(name,value){const inputData=this._tNode.inputs;let dataValue;if(null!==inputData&&(dataValue=inputData[name])){if(this.previousInputValues??=new Map,this.previousInputValues.has(name)&&Object.is(this.previousInputValues.get(name),value))return;const lView=this._rootLView;setInputsForProperty(lView[TVIEW],lView,dataValue,name,value),this.previousInputValues.set(name,value);markViewDirty(getComponentLViewByIndex(this._tNode.index,lView))}else if(ngDevMode){let message=`Can't set value of the '${name}' input on the '${stringifyForError(this.componentType)}' component. `;message+=`Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`,reportUnknownPropertyError(message)}}get injector(){return new NodeInjector(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(callback){this.hostView.onDestroy(callback)}}function LifecycleHooksFeature(){const tNode=getCurrentTNode();ngDevMode&&assertDefined(tNode,"TNode is required"),registerPostOrderHooks(getLView()[TVIEW],tNode)}new Set(["ngh","ng-version","ng-server-context"]);new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);"undefined"==typeof ngI18nClosureMode&&(_global$1.ngI18nClosureMode="undefined"!=typeof goog&&"function"==typeof goog.getMsg);var LocaleDataIndex;!function(LocaleDataIndex){LocaleDataIndex[LocaleDataIndex.LocaleId=0]="LocaleId",LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat=1]="DayPeriodsFormat",LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone=2]="DayPeriodsStandalone",LocaleDataIndex[LocaleDataIndex.DaysFormat=3]="DaysFormat",LocaleDataIndex[LocaleDataIndex.DaysStandalone=4]="DaysStandalone",LocaleDataIndex[LocaleDataIndex.MonthsFormat=5]="MonthsFormat",LocaleDataIndex[LocaleDataIndex.MonthsStandalone=6]="MonthsStandalone",LocaleDataIndex[LocaleDataIndex.Eras=7]="Eras",LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek=8]="FirstDayOfWeek",LocaleDataIndex[LocaleDataIndex.WeekendRange=9]="WeekendRange",LocaleDataIndex[LocaleDataIndex.DateFormat=10]="DateFormat",LocaleDataIndex[LocaleDataIndex.TimeFormat=11]="TimeFormat",LocaleDataIndex[LocaleDataIndex.DateTimeFormat=12]="DateTimeFormat",LocaleDataIndex[LocaleDataIndex.NumberSymbols=13]="NumberSymbols",LocaleDataIndex[LocaleDataIndex.NumberFormats=14]="NumberFormats",LocaleDataIndex[LocaleDataIndex.CurrencyCode=15]="CurrencyCode",LocaleDataIndex[LocaleDataIndex.CurrencySymbol=16]="CurrencySymbol",LocaleDataIndex[LocaleDataIndex.CurrencyName=17]="CurrencyName",LocaleDataIndex[LocaleDataIndex.Currencies=18]="Currencies",LocaleDataIndex[LocaleDataIndex.Directionality=19]="Directionality",LocaleDataIndex[LocaleDataIndex.PluralCase=20]="PluralCase",LocaleDataIndex[LocaleDataIndex.ExtraData=21]="ExtraData"}(LocaleDataIndex||(LocaleDataIndex={}));var I18nCreateOpCode;!function(I18nCreateOpCode){I18nCreateOpCode[I18nCreateOpCode.SHIFT=2]="SHIFT",I18nCreateOpCode[I18nCreateOpCode.APPEND_EAGERLY=1]="APPEND_EAGERLY",I18nCreateOpCode[I18nCreateOpCode.COMMENT=2]="COMMENT"}(I18nCreateOpCode||(I18nCreateOpCode={}));class NgModuleRef$1{}class EnvironmentNgModuleRefAdapter extends NgModuleRef$1{constructor(config){super(),this.componentFactoryResolver=new ComponentFactoryResolver(this),this.instance=null;const injector=new R3Injector([...config.providers,{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver}],config.parent||getNullInjector(),config.debugName,new Set(["environment"]));this.injector=injector,config.runEnvironmentInitializers&&injector.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(callback){this.injector.onDestroy(callback)}}class StandaloneService{constructor(_injector){this._injector=_injector,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(componentDef){if(!componentDef.standalone)return null;if(!this.cachedInjectors.has(componentDef.id)){const providers=internalImportProvidersFrom(!1,componentDef.type),standaloneInjector=providers.length>0?function createEnvironmentInjector(providers,parent,debugName=null){return new EnvironmentNgModuleRefAdapter({providers,parent,debugName,runEnvironmentInitializers:!0}).injector}([providers],this._injector,`Standalone[${componentDef.type.name}]`):null;this.cachedInjectors.set(componentDef.id,standaloneInjector)}return this.cachedInjectors.get(componentDef.id)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static#_=this.ɵprov=ɵɵdefineInjectable({token:StandaloneService,providedIn:"environment",factory:()=>new StandaloneService(ɵɵinject(EnvironmentInjector))})}Subject.x;Symbol.iterator;class TemplateRef{static#_=this.__NG_ELEMENT_ID__=injectTemplateRef}const ViewEngineTemplateRef=TemplateRef,R3TemplateRef=class TemplateRef extends ViewEngineTemplateRef{constructor(_declarationLView,_declarationTContainer,elementRef){super(),this._declarationLView=_declarationLView,this._declarationTContainer=_declarationTContainer,this.elementRef=elementRef}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(context,injector){return this.createEmbeddedViewImpl(context,injector,null)}createEmbeddedViewImpl(context,injector,hydrationInfo){const embeddedTView=this._declarationTContainer.tView,embeddedLView=createLView(this._declarationLView,embeddedTView,context,16,null,embeddedTView.declTNode,null,null,null,injector||null,hydrationInfo||null),declarationLContainer=this._declarationLView[this._declarationTContainer.index];ngDevMode&&assertLContainer(declarationLContainer),embeddedLView[DECLARATION_LCONTAINER]=declarationLContainer;const declarationViewLQueries=this._declarationLView[QUERIES];return null!==declarationViewLQueries&&(embeddedLView[QUERIES]=declarationViewLQueries.createEmbeddedView(embeddedTView)),renderView(embeddedTView,embeddedLView,context),new ViewRef(embeddedLView)}};function injectTemplateRef(){return createTemplateRef(getCurrentTNode(),getLView())}function createTemplateRef(hostTNode,hostLView){return 4&hostTNode.type?(ngDevMode&&assertDefined(hostTNode.tView,"TView must be allocated"),new R3TemplateRef(hostLView,hostTNode,createElementRef(hostTNode,hostLView))):null}let _findMatchingDehydratedViewImpl=(lContainer,template)=>null;function findMatchingDehydratedView(lContainer,template){return _findMatchingDehydratedViewImpl(lContainer,template)}class ViewContainerRef{static#_=this.__NG_ELEMENT_ID__=injectViewContainerRef}function injectViewContainerRef(){return createContainerRef(getCurrentTNode(),getLView())}const VE_ViewContainerRef=ViewContainerRef,R3ViewContainerRef=class ViewContainerRef extends VE_ViewContainerRef{constructor(_lContainer,_hostTNode,_hostLView){super(),this._lContainer=_lContainer,this._hostTNode=_hostTNode,this._hostLView=_hostLView}get element(){return createElementRef(this._hostTNode,this._hostLView)}get injector(){return new NodeInjector(this._hostTNode,this._hostLView)}get parentInjector(){const parentLocation=getParentInjectorLocation(this._hostTNode,this._hostLView);if(hasParentInjector(parentLocation)){const parentView=getParentInjectorView(parentLocation,this._hostLView),injectorIndex=getParentInjectorIndex(parentLocation);ngDevMode&&assertNodeInjector(parentView,injectorIndex);const parentTNode=parentView[TVIEW].data[injectorIndex+8];return new NodeInjector(parentTNode,parentView)}return new NodeInjector(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(index){const viewRefs=getViewRefs(this._lContainer);return null!==viewRefs&&viewRefs[index]||null}get length(){return this._lContainer.length-CONTAINER_HEADER_OFFSET}createEmbeddedView(templateRef,context,indexOrOptions){let index,injector;"number"==typeof indexOrOptions?index=indexOrOptions:null!=indexOrOptions&&(index=indexOrOptions.index,injector=indexOrOptions.injector);const hydrationInfo=findMatchingDehydratedView(this._lContainer,templateRef.ssrId),viewRef=templateRef.createEmbeddedViewImpl(context||{},injector,hydrationInfo);return this.insertImpl(viewRef,index,!!hydrationInfo),viewRef}createComponent(componentFactoryOrType,indexOrOptions,injector,projectableNodes,environmentInjector){const isComponentFactory=componentFactoryOrType&&!isType(componentFactoryOrType);let index;if(isComponentFactory)ngDevMode&&assertEqual("object"!=typeof indexOrOptions,!0,"It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)"),index=indexOrOptions;else{ngDevMode&&(assertDefined(getComponentDef$1(componentFactoryOrType),"Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator."),assertEqual("number"!=typeof indexOrOptions,!0,"It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead."));const options=indexOrOptions||{};ngDevMode&&options.environmentInjector&&options.ngModuleRef&&throwError("Cannot pass both environmentInjector and ngModuleRef options to createComponent()."),index=options.index,injector=options.injector,projectableNodes=options.projectableNodes,environmentInjector=options.environmentInjector||options.ngModuleRef}const componentFactory=isComponentFactory?componentFactoryOrType:new ComponentFactory(getComponentDef$1(componentFactoryOrType)),contextInjector=injector||this.parentInjector;if(!environmentInjector&&null==componentFactory.ngModule){const result=(isComponentFactory?contextInjector:this.parentInjector).get(EnvironmentInjector,null);result&&(environmentInjector=result)}const componentDef=getComponentDef$1(componentFactory.componentType??{}),dehydratedView=findMatchingDehydratedView(this._lContainer,componentDef?.id??null),rNode=dehydratedView?.firstChild??null,componentRef=componentFactory.create(contextInjector,projectableNodes,rNode,environmentInjector);return this.insertImpl(componentRef.hostView,index,!!dehydratedView),componentRef}insert(viewRef,index){return this.insertImpl(viewRef,index,!1)}insertImpl(viewRef,index,skipDomInsertion){const lView=viewRef._lView,tView=lView[TVIEW];if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(function viewAttachedToContainer(view){return isLContainer(view[PARENT])}(lView)){const prevIdx=this.indexOf(viewRef);if(-1!==prevIdx)this.detach(prevIdx);else{const prevLContainer=lView[PARENT];ngDevMode&&assertEqual(isLContainer(prevLContainer),!0,"An attached view should have its PARENT point to a container.");const prevVCRef=new R3ViewContainerRef(prevLContainer,prevLContainer[T_HOST],prevLContainer[PARENT]);prevVCRef.detach(prevVCRef.indexOf(viewRef))}}const adjustedIdx=this._adjustIndex(index),lContainer=this._lContainer;if(insertView(tView,lView,lContainer,adjustedIdx),!skipDomInsertion){const beforeNode=getBeforeNodeForView(adjustedIdx,lContainer),renderer=lView[RENDERER],parentRNode=nativeParentNode(renderer,lContainer[NATIVE]);null!==parentRNode&&function addViewToContainer(tView,parentTNode,renderer,lView,parentNativeNode,beforeNode){lView[HOST]=parentNativeNode,lView[T_HOST]=parentTNode,applyView(tView,lView,renderer,1,parentNativeNode,beforeNode)}(tView,lContainer[T_HOST],renderer,lView,parentRNode,beforeNode)}return viewRef.attachToViewContainerRef(),addToArray(getOrCreateViewRefs(lContainer),adjustedIdx,viewRef),viewRef}move(viewRef,newIndex){if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(viewRef,newIndex)}indexOf(viewRef){const viewRefsArr=getViewRefs(this._lContainer);return null!==viewRefsArr?viewRefsArr.indexOf(viewRef):-1}remove(index){const adjustedIdx=this._adjustIndex(index,-1),detachedView=detachView(this._lContainer,adjustedIdx);detachedView&&(removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx),destroyLView(detachedView[TVIEW],detachedView))}detach(index){const adjustedIdx=this._adjustIndex(index,-1),view=detachView(this._lContainer,adjustedIdx);return view&&null!=removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx)?new ViewRef(view):null}_adjustIndex(index,shift=0){return null==index?this.length+shift:(ngDevMode&&(assertGreaterThan(index,-1,`ViewRef index must be positive, got ${index}`),assertLessThan(index,this.length+1+shift,"index")),index)}};function getViewRefs(lContainer){return lContainer[8]}function getOrCreateViewRefs(lContainer){return lContainer[8]||(lContainer[8]=[])}function createContainerRef(hostTNode,hostLView){let lContainer;ngDevMode&&assertTNodeType(hostTNode,15);const slotValue=hostLView[hostTNode.index];return isLContainer(slotValue)?lContainer=slotValue:(lContainer=createLContainer(slotValue,hostLView,null,hostTNode),hostLView[hostTNode.index]=lContainer,addToViewTree(hostLView,lContainer)),_locateOrCreateAnchorNode(lContainer,hostLView,hostTNode,slotValue),new R3ViewContainerRef(lContainer,hostTNode,hostLView)}let _locateOrCreateAnchorNode=createAnchorNode;function createAnchorNode(lContainer,hostLView,hostTNode,slotValue){if(lContainer[NATIVE])return;let commentNode;commentNode=8&hostTNode.type?unwrapRNode(slotValue):function insertAnchorNode(hostLView,hostTNode){const renderer=hostLView[RENDERER];ngDevMode&&ngDevMode.rendererCreateComment++;const commentNode=renderer.createComment(ngDevMode?"container":""),hostNative=getNativeByTNode(hostTNode,hostLView);return nativeInsertBefore(renderer,nativeParentNode(renderer,hostNative),commentNode,function nativeNextSibling(renderer,node){return renderer.nextSibling(node)}(renderer,hostNative),!1),commentNode}(hostLView,hostTNode),lContainer[NATIVE]=commentNode}function generateStandaloneInDeclarationsError(type,location){return`${`Unexpected "${stringifyForError(type)}" found in the "declarations" array of the`} ${location}, ${`"${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`}`}new WeakMap,new WeakMap;let _nextReferenceId=0;class MetadataOverrider{constructor(){this._references=new Map}overrideMetadata(metadataClass,oldMetadata,override){const props={};if(oldMetadata&&function _valueProps(obj){const props=[];Object.keys(obj).forEach((prop=>{prop.startsWith("_")||props.push(prop)}));let proto=obj;for(;proto=Object.getPrototypeOf(proto);)Object.keys(proto).forEach((protoProp=>{const desc=Object.getOwnPropertyDescriptor(proto,protoProp);!protoProp.startsWith("_")&&desc&&"get"in desc&&props.push(protoProp)}));return props}(oldMetadata).forEach((prop=>props[prop]=oldMetadata[prop])),override.set){if(override.remove||override.add)throw new Error(`Cannot set and add/remove ${(0,core["ɵstringify"])(metadataClass)} at the same time!`);!function setMetadata(metadata,set){for(const prop in set)metadata[prop]=set[prop]}(props,override.set)}return override.remove&&function removeMetadata(metadata,remove,references){const removeObjects=new Set;for(const prop in remove){const removeValue=remove[prop];Array.isArray(removeValue)?removeValue.forEach((value=>{removeObjects.add(_propHashKey(prop,value,references))})):removeObjects.add(_propHashKey(prop,removeValue,references))}for(const prop in metadata){const propValue=metadata[prop];Array.isArray(propValue)?metadata[prop]=propValue.filter((value=>!removeObjects.has(_propHashKey(prop,value,references)))):removeObjects.has(_propHashKey(prop,propValue,references))&&(metadata[prop]=void 0)}}(props,override.remove,this._references),override.add&&function addMetadata(metadata,add){for(const prop in add){const addValue=add[prop],propValue=metadata[prop];null!=propValue&&Array.isArray(propValue)?metadata[prop]=propValue.concat(addValue):metadata[prop]=addValue}}(props,override.add),new metadataClass(props)}}function _propHashKey(propName,propValue,references){let nextObjectId=0;const objectIds=new Map;return`${propName}:${JSON.stringify(propValue,((key,value)=>null!==value&&"object"==typeof value?objectIds.has(value)?objectIds.get(value):(objectIds.set(value,"ɵobj#"+nextObjectId++),value):("function"==typeof value&&(value=function _serializeReference(ref,references){let id=references.get(ref);id||(id=`${(0,core["ɵstringify"])(ref)}${_nextReferenceId++}`,references.set(ref,id));return id}(value,references)),value)))}`}const reflection=new core["ɵReflectionCapabilities"];class OverrideResolver{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(type,override){const overrides=this.overrides.get(type)||[];overrides.push(override),this.overrides.set(type,overrides),this.resolved.delete(type)}setOverrides(overrides){this.overrides.clear(),overrides.forEach((([type,override])=>{this.addOverride(type,override)}))}getAnnotation(type){const annotations=reflection.annotations(type);for(let i=annotations.length-1;i>=0;i--){const annotation=annotations[i];if(annotation instanceof core.Directive||annotation instanceof core.Component||annotation instanceof core.Pipe||annotation instanceof core.NgModule)return annotation instanceof this.type?annotation:null}return null}resolve(type){let resolved=this.resolved.get(type)||null;if(!resolved){if(resolved=this.getAnnotation(type),resolved){const overrides=this.overrides.get(type);if(overrides){const overrider=new MetadataOverrider;overrides.forEach((override=>{resolved=overrider.overrideMetadata(this.type,resolved,override)}))}}this.resolved.set(type,resolved)}return resolved}}class DirectiveResolver extends OverrideResolver{get type(){return core.Directive}}class ComponentResolver extends OverrideResolver{get type(){return core.Component}}class PipeResolver extends OverrideResolver{get type(){return core.Pipe}}class NgModuleResolver extends OverrideResolver{get type(){return core.NgModule}}var TestingModuleOverride;!function(TestingModuleOverride){TestingModuleOverride[TestingModuleOverride.DECLARATION=0]="DECLARATION",TestingModuleOverride[TestingModuleOverride.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE"}(TestingModuleOverride||(TestingModuleOverride={}));class TestBedCompiler{constructor(platform,additionalModuleTypes){this.platform=platform,this.additionalModuleTypes=additionalModuleTypes,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=function initResolvers(){return{module:new NgModuleResolver,component:new ComponentResolver,directive:new DirectiveResolver,pipe:new PipeResolver}}(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.scopesWithOverriddenProviders=new Set,this.testModuleRef=null;this.testModuleType=class DynamicTestModule{}}setCompilerProviders(providers){this.compilerProviders=providers,this._injector=null}configureTestingModule(moduleDef){void 0!==moduleDef.declarations&&(!function assertNoStandaloneComponents(types,resolver,location){types.forEach((type=>{const component=resolver.resolve(type);if(component&&component.standalone)throw new Error(generateStandaloneInDeclarationsError(type,location))}))}(moduleDef.declarations,this.resolvers.component,'"TestBed.configureTestingModule" call'),this.queueTypeArray(moduleDef.declarations,TestingModuleOverride.DECLARATION),this.declarations.push(...moduleDef.declarations)),void 0!==moduleDef.imports&&(this.queueTypesFromModulesArray(moduleDef.imports),this.imports.push(...moduleDef.imports)),void 0!==moduleDef.providers&&this.providers.push(...moduleDef.providers),void 0!==moduleDef.schemas&&this.schemas.push(...moduleDef.schemas)}overrideModule(ngModule,override){this.overriddenModules.add(ngModule),this.resolvers.module.addOverride(ngModule,override);const metadata=this.resolvers.module.resolve(ngModule);if(null===metadata)throw invalidTypeError(ngModule.name,"NgModule");this.recompileNgModule(ngModule,metadata),this.queueTypesFromModulesArray([ngModule])}overrideComponent(component,override){this.verifyNoStandaloneFlagOverrides(component,override),this.resolvers.component.addOverride(component,override),this.pendingComponents.add(component)}overrideDirective(directive,override){this.verifyNoStandaloneFlagOverrides(directive,override),this.resolvers.directive.addOverride(directive,override),this.pendingDirectives.add(directive)}overridePipe(pipe,override){this.verifyNoStandaloneFlagOverrides(pipe,override),this.resolvers.pipe.addOverride(pipe,override),this.pendingPipes.add(pipe)}verifyNoStandaloneFlagOverrides(type,override){if(override.add?.hasOwnProperty("standalone")||override.set?.hasOwnProperty("standalone")||override.remove?.hasOwnProperty("standalone"))throw new Error(`An override for the ${type.name} class has the \`standalone\` flag. Changing the \`standalone\` flag via TestBed overrides is not supported.`)}overrideProvider(token,provider){let providerDef;providerDef=void 0!==provider.useFactory?{provide:token,useFactory:provider.useFactory,deps:provider.deps||[],multi:provider.multi}:void 0!==provider.useValue?{provide:token,useValue:provider.useValue,multi:provider.multi}:{provide:token};const injectableDef="string"!=typeof token?(0,core["ɵgetInjectableDef"])(token):null,providedIn=null===injectableDef?null:(0,core.resolveForwardRef)(injectableDef.providedIn);if(("root"===providedIn?this.rootProviderOverrides:this.providerOverrides).push(providerDef),this.providerOverridesByToken.set(token,providerDef),null!==injectableDef&&null!==providedIn&&"string"!=typeof providedIn){const existingOverrides=this.providerOverridesByModule.get(providedIn);void 0!==existingOverrides?existingOverrides.push(providerDef):this.providerOverridesByModule.set(providedIn,[providerDef])}}overrideTemplateUsingTestingModule(type,template){const def=type[core["ɵNG_COMP_DEF"]],overrideStyleUrls=!!def&&!isComponentDefPendingResolution(type)&&(()=>{const metadata=this.resolvers.component.resolve(type);return!!metadata.styleUrls&&metadata.styleUrls.length>0})(),override=overrideStyleUrls?{template,styles:[],styleUrls:[]}:{template};this.overrideComponent(type,{set:override}),overrideStyleUrls&&def.styles&&def.styles.length>0&&this.existingComponentStyles.set(type,def.styles),this.componentToModuleScope.set(type,TestingModuleOverride.OVERRIDE_TEMPLATE)}compileComponents(){var _this=this;return(0,asyncToGenerator.Z)((function*(){if(_this.clearComponentResolutionQueue(),_this.compileTypesSync()){let resourceLoader,resolver=url=>(resourceLoader||(resourceLoader=_this.injector.get(compiler.ResourceLoader)),Promise.resolve(resourceLoader.get(url)));yield resolveComponentResources(resolver)}}))()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear();const parentInjector=this.platform.injector;this.testModuleRef=new core["ɵRender3NgModuleRef"](this.testModuleType,parentInjector,[]),this.testModuleRef.injector.get(core.ApplicationInitStatus).runInitializers();const localeId=this.testModuleRef.injector.get(core.LOCALE_ID,core["ɵDEFAULT_LOCALE_ID"]);return(0,core["ɵsetLocaleId"])(localeId),this.testModuleRef}_compileNgModuleSync(moduleType){this.queueTypesFromModulesArray([moduleType]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesInScope(moduleType),this.applyTransitiveScopes()}_compileNgModuleAsync(moduleType){var _this2=this;return(0,asyncToGenerator.Z)((function*(){_this2.queueTypesFromModulesArray([moduleType]),yield _this2.compileComponents(),_this2.applyProviderOverrides(),_this2.applyProviderOverridesInScope(moduleType),_this2.applyTransitiveScopes()}))()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(moduleType){return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce(((factories,declaration)=>{const componentDef=declaration.ɵcmp;return componentDef&&factories.push(new core["ɵRender3ComponentFactory"](componentDef,this.testModuleRef)),factories}),[])}compileTypesSync(){let needsAsyncResources=!1;return this.pendingComponents.forEach((declaration=>{needsAsyncResources=needsAsyncResources||isComponentDefPendingResolution(declaration);const metadata=this.resolvers.component.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Component");this.maybeStoreNgDef(core["ɵNG_COMP_DEF"],declaration),(0,core["ɵcompileComponent"])(declaration,metadata)})),this.pendingComponents.clear(),this.pendingDirectives.forEach((declaration=>{const metadata=this.resolvers.directive.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Directive");this.maybeStoreNgDef(core["ɵNG_DIR_DEF"],declaration),(0,core["ɵcompileDirective"])(declaration,metadata)})),this.pendingDirectives.clear(),this.pendingPipes.forEach((declaration=>{const metadata=this.resolvers.pipe.resolve(declaration);if(null===metadata)throw invalidTypeError(declaration.name,"Pipe");this.maybeStoreNgDef(core["ɵNG_PIPE_DEF"],declaration),(0,core["ɵcompilePipe"])(declaration,metadata)})),this.pendingPipes.clear(),needsAsyncResources}applyTransitiveScopes(){if(this.overriddenModules.size>0){const testingModuleDef=this.testModuleType[core["ɵNG_MOD_DEF"]],affectedModules=this.collectModulesAffectedByOverrides(testingModuleDef.imports);affectedModules.size>0&&affectedModules.forEach((moduleType=>{this.storeFieldOfDefOnType(moduleType,core["ɵNG_MOD_DEF"],"transitiveCompileScopes"),moduleType[core["ɵNG_MOD_DEF"]].transitiveCompileScopes=null}))}const moduleToScope=new Map,getScopeOfModule=moduleType=>{if(!moduleToScope.has(moduleType)){const realType=function isTestingModuleOverride(value){return value===TestingModuleOverride.DECLARATION||value===TestingModuleOverride.OVERRIDE_TEMPLATE}(moduleType)?this.testModuleType:moduleType;moduleToScope.set(moduleType,(0,core["ɵtransitiveScopesFor"])(realType))}return moduleToScope.get(moduleType)};this.componentToModuleScope.forEach(((moduleType,componentType)=>{const moduleScope=getScopeOfModule(moduleType);this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"directiveDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"pipeDefs"),this.storeFieldOfDefOnType(componentType,core["ɵNG_COMP_DEF"],"tView"),(0,core["ɵpatchComponentDefWithScope"])(componentType.ɵcmp,moduleScope)})),this.componentToModuleScope.clear()}applyProviderOverrides(){const maybeApplyOverrides=field=>type=>{const metadata=(field===core["ɵNG_COMP_DEF"]?this.resolvers.component:this.resolvers.directive).resolve(type);this.hasProviderOverrides(metadata.providers)&&this.patchDefWithProviderOverrides(type,field)};this.seenComponents.forEach(maybeApplyOverrides(core["ɵNG_COMP_DEF"])),this.seenDirectives.forEach(maybeApplyOverrides(core["ɵNG_DIR_DEF"])),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesInScope(type){if(!(isStandaloneComponent(type)||function isNgModule(value){return hasNgModuleDef(value)}(type))||this.scopesWithOverriddenProviders.has(type))return;this.scopesWithOverriddenProviders.add(type);const injectorDef=type[core["ɵNG_INJ_DEF"]];if(0!==this.providerOverridesByToken.size)if(isStandaloneComponent(type)){const dependencies=maybeUnwrapFn(getComponentDef(type).dependencies??[]);for(const dependency of dependencies)this.applyProviderOverridesInScope(dependency)}else{const providers=[...injectorDef.providers,...this.providerOverridesByModule.get(type)||[]];this.hasProviderOverrides(providers)&&(this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],type),this.storeFieldOfDefOnType(type,core["ɵNG_INJ_DEF"],"providers"),injectorDef.providers=this.getOverriddenProviders(providers));const imports=maybeUnwrapFn(type[core["ɵNG_MOD_DEF"]].imports);for(const importedModule of imports)this.applyProviderOverridesInScope(importedModule);for(const importedModule of flatten(injectorDef.imports))isModuleWithProviders(importedModule)&&(this.defCleanupOps.push({object:importedModule,fieldName:"providers",originalValue:importedModule.providers}),importedModule.providers=this.getOverriddenProviders(importedModule.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach(((styles,type)=>type[core["ɵNG_COMP_DEF"]].styles=styles)),this.existingComponentStyles.clear()}queueTypeArray(arr,moduleType){for(const value of arr)Array.isArray(value)?this.queueTypeArray(value,moduleType):this.queueType(value,moduleType)}recompileNgModule(ngModule,metadata){this.maybeStoreNgDef(core["ɵNG_MOD_DEF"],ngModule),this.maybeStoreNgDef(core["ɵNG_INJ_DEF"],ngModule),(0,core["ɵcompileNgModuleDefs"])(ngModule,metadata)}queueType(type,moduleType){if(this.resolvers.component.resolve(type))return!isComponentDefPendingResolution(type)&&type.hasOwnProperty(core["ɵNG_COMP_DEF"])||this.pendingComponents.add(type),this.seenComponents.add(type),void(null===moduleType||this.componentToModuleScope.has(type)&&this.componentToModuleScope.get(type)!==TestingModuleOverride.DECLARATION||this.componentToModuleScope.set(type,moduleType));if(this.resolvers.directive.resolve(type))return type.hasOwnProperty(core["ɵNG_DIR_DEF"])||this.pendingDirectives.add(type),void this.seenDirectives.add(type);!this.resolvers.pipe.resolve(type)||type.hasOwnProperty(core["ɵNG_PIPE_DEF"])||this.pendingPipes.add(type)}queueTypesFromModulesArray(arr){const processedDefs=new Set,queueTypesFromModulesArrayRecur=arr=>{for(const value of arr)if(Array.isArray(value))queueTypesFromModulesArrayRecur(value);else if(hasNgModuleDef(value)){const def=value.ɵmod;if(processedDefs.has(def))continue;processedDefs.add(def),this.queueTypeArray(maybeUnwrapFn(def.declarations),value),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports)),queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports))}else if(isModuleWithProviders(value))queueTypesFromModulesArrayRecur([value.ngModule]);else if(isStandaloneComponent(value)){this.queueType(value,null);const def=getComponentDef(value);if(processedDefs.has(def))continue;processedDefs.add(def);maybeUnwrapFn(def.dependencies??[]).forEach((dependency=>{isStandaloneComponent(dependency)||hasNgModuleDef(dependency)?queueTypesFromModulesArrayRecur([dependency]):this.queueType(dependency,null)}))}};queueTypesFromModulesArrayRecur(arr)}collectModulesAffectedByOverrides(arr){const seenModules=new Set,affectedModules=new Set,calcAffectedModulesRecur=(arr,path)=>{for(const value of arr)if(Array.isArray(value))calcAffectedModulesRecur(value,path);else if(hasNgModuleDef(value)){if(seenModules.has(value)){affectedModules.has(value)&&path.forEach((item=>affectedModules.add(item)));continue}seenModules.add(value),this.overriddenModules.has(value)&&path.forEach((item=>affectedModules.add(item)));const moduleDef=value[core["ɵNG_MOD_DEF"]];calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports),path.concat(value))}};return calcAffectedModulesRecur(arr,[]),affectedModules}maybeStoreNgDef(prop,type){this.initialNgDefs.has(type)||this.initialNgDefs.set(type,new Map);const currentDefs=this.initialNgDefs.get(type);if(!currentDefs.has(prop)){const currentDef=Object.getOwnPropertyDescriptor(type,prop);currentDefs.set(prop,currentDef)}}storeFieldOfDefOnType(type,defField,fieldName){const def=type[defField],originalValue=def[fieldName];this.defCleanupOps.push({object:def,fieldName,originalValue})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),clearResolutionOfComponentResourcesQueue().forEach(((value,key)=>this.originalComponentResolutionQueue.set(key,value)))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&(!function restoreComponentResolutionQueue(queue){componentDefPendingResolution.clear(),queue.forEach(((_,type)=>componentDefPendingResolution.add(type))),componentResourceResolutionQueue=queue}(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){forEachRight(this.defCleanupOps,(op=>{op.object[op.fieldName]=op.originalValue})),this.initialNgDefs.forEach(((defs,type)=>{defs.forEach(((descriptor,prop)=>{descriptor?Object.defineProperty(type,prop,descriptor):delete type[prop]}))})),this.initialNgDefs.clear(),this.scopesWithOverriddenProviders.clear(),this.restoreComponentResolutionQueue(),(0,core["ɵsetLocaleId"])(core["ɵDEFAULT_LOCALE_ID"])}compileTestModule(){class RootScopeModule{}(0,core["ɵcompileNgModuleDefs"])(RootScopeModule,{providers:[...this.rootProviderOverrides]});const providers=[(0,core.provideZoneChangeDetection)(),{provide:core.Compiler,useFactory:()=>new R3TestCompiler(this)},...this.providers,...this.providerOverrides],imports=[RootScopeModule,this.additionalModuleTypes,this.imports||[]];(0,core["ɵcompileNgModuleDefs"])(this.testModuleType,{declarations:this.declarations,imports,schemas:this.schemas,providers},!0),this.applyProviderOverridesInScope(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const providers=[];return this.platform.injector.get(core.COMPILER_OPTIONS).forEach((opts=>{opts.providers&&providers.push(opts.providers)})),null!==this.compilerProviders&&providers.push(...this.compilerProviders),this._injector=core.Injector.create({providers,parent:this.platform.injector}),this._injector}getSingleProviderOverrides(provider){const token=getProviderToken(provider);return this.providerOverridesByToken.get(token)||null}getProviderOverrides(providers){return providers&&providers.length&&0!==this.providerOverridesByToken.size?flatten(flattenProviders(providers,(provider=>this.getSingleProviderOverrides(provider)||[]))):[]}getOverriddenProviders(providers){if(!providers||!providers.length||0===this.providerOverridesByToken.size)return[];const flattenedProviders=flattenProviders(providers),overrides=this.getProviderOverrides(flattenedProviders),overriddenProviders=[...flattenedProviders,...overrides],final=[],seenOverriddenProviders=new Set;return forEachRight(overriddenProviders,(provider=>{const token=getProviderToken(provider);this.providerOverridesByToken.has(token)?seenOverriddenProviders.has(token)||(seenOverriddenProviders.add(token),final.unshift({...provider,multi:!1})):final.unshift(provider)})),final}hasProviderOverrides(providers){return this.getProviderOverrides(providers).length>0}patchDefWithProviderOverrides(declaration,field){const def=declaration[field];if(def&&def.providersResolver){this.maybeStoreNgDef(field,declaration);const resolver=def.providersResolver,processProvidersFn=providers=>this.getOverriddenProviders(providers);this.storeFieldOfDefOnType(declaration,field,"providersResolver"),def.providersResolver=ngDef=>resolver(ngDef,processProvidersFn)}}}function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}function getComponentDef(value){return value.ɵcmp??null}function hasNgModuleDef(value){return value.hasOwnProperty("ɵmod")}function maybeUnwrapFn(maybeFn){return maybeFn instanceof Function?maybeFn():maybeFn}function flatten(values){const out=[];return values.forEach((value=>{Array.isArray(value)?out.push(...flatten(value)):out.push(value)})),out}function identityFn(value){return value}function flattenProviders(providers,mapFn=identityFn){const out=[];for(let provider of providers)(0,core["ɵisEnvironmentProviders"])(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?out.push(...flattenProviders(provider,mapFn)):out.push(mapFn(provider));return out}function getProviderToken(provider){return function getProviderField(provider,field){return provider&&"object"==typeof provider&&provider[field]}(provider,"provide")||provider}function isModuleWithProviders(value){return value.hasOwnProperty("ngModule")}function forEachRight(values,fn){for(let idx=values.length-1;idx>=0;idx--)fn(values[idx],idx)}function invalidTypeError(name,expectedType){return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`)}class R3TestCompiler{constructor(testBed){this.testBed=testBed}compileModuleSync(moduleType){return this.testBed._compileNgModuleSync(moduleType),new core["ɵNgModuleFactory"](moduleType)}compileModuleAsync(moduleType){var _this3=this;return(0,asyncToGenerator.Z)((function*(){return yield _this3.testBed._compileNgModuleAsync(moduleType),new core["ɵNgModuleFactory"](moduleType)}))()}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=this.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){var _this4=this;return(0,asyncToGenerator.Z)((function*(){const ngModuleFactory=yield _this4.compileModuleAsync(moduleType),componentFactories=_this4.testBed._getComponentFactories(moduleType);return new core.ModuleWithComponentFactories(ngModuleFactory,componentFactories)}))()}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){const meta=this.testBed._getModuleResolver().resolve(moduleType);return meta&&meta.id||void 0}}let _nextRootElementId=0;class TestBedImpl{constructor(){this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this.globalCompilationChecked=!1}static#_=this._INSTANCE=null;static get INSTANCE(){return TestBedImpl._INSTANCE=TestBedImpl._INSTANCE||new TestBedImpl}static initTestEnvironment(ngModule,platform,options){const testBed=TestBedImpl.INSTANCE;return testBed.initTestEnvironment(ngModule,platform,options),testBed}static resetTestEnvironment(){TestBedImpl.INSTANCE.resetTestEnvironment()}static configureCompiler(config){return TestBedImpl.INSTANCE.configureCompiler(config)}static configureTestingModule(moduleDef){return TestBedImpl.INSTANCE.configureTestingModule(moduleDef)}static compileComponents(){return TestBedImpl.INSTANCE.compileComponents()}static overrideModule(ngModule,override){return TestBedImpl.INSTANCE.overrideModule(ngModule,override)}static overrideComponent(component,override){return TestBedImpl.INSTANCE.overrideComponent(component,override)}static overrideDirective(directive,override){return TestBedImpl.INSTANCE.overrideDirective(directive,override)}static overridePipe(pipe,override){return TestBedImpl.INSTANCE.overridePipe(pipe,override)}static overrideTemplate(component,template){return TestBedImpl.INSTANCE.overrideTemplate(component,template)}static overrideTemplateUsingTestingModule(component,template){return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component,template)}static overrideProvider(token,provider){return TestBedImpl.INSTANCE.overrideProvider(token,provider)}static inject(token,notFoundValue,flags){return TestBedImpl.INSTANCE.inject(token,notFoundValue,(0,core["ɵconvertToBitFlags"])(flags))}static get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return TestBedImpl.INSTANCE.inject(token,notFoundValue,flags)}static runInInjectionContext(fn){return TestBedImpl.INSTANCE.runInInjectionContext(fn)}static createComponent(component){return TestBedImpl.INSTANCE.createComponent(component)}static resetTestingModule(){return TestBedImpl.INSTANCE.resetTestingModule()}static execute(tokens,fn,context){return TestBedImpl.INSTANCE.execute(tokens,fn,context)}static get platform(){return TestBedImpl.INSTANCE.platform}static get ngModule(){return TestBedImpl.INSTANCE.ngModule}initTestEnvironment(ngModule,platform,options){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");TestBedImpl._environmentTeardownOptions=options?.teardown,TestBedImpl._environmentErrorOnUnknownElementsOption=options?.errorOnUnknownElements,TestBedImpl._environmentErrorOnUnknownPropertiesOption=options?.errorOnUnknownProperties,this.platform=platform,this.ngModule=ngModule,this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!0)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,TestBedImpl._environmentTeardownOptions=void 0,(0,core["ɵsetAllowDuplicateNgModuleIdsForTest"])(!1)}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,core["ɵresetCompiledComponents"])(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new TestBedCompiler(this.platform,this.ngModule),(0,core["ɵsetUnknownElementStrictMode"])(this._previousErrorOnUnknownElementsOption??false),(0,core["ɵsetUnknownPropertyStrictMode"])(this._previousErrorOnUnknownPropertiesOption??false);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0,this._instanceErrorOnUnknownElementsOption=void 0,this._instanceErrorOnUnknownPropertiesOption=void 0}}return this}configureCompiler(config){if(null!=config.useJit)throw new Error("the Render3 compiler JiT mode is not configurable !");return void 0!==config.providers&&this.compiler.setCompilerProviders(config.providers),this}configureTestingModule(moduleDef){return this.assertNotInstantiated("R3TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=moduleDef.teardown,this._instanceErrorOnUnknownElementsOption=moduleDef.errorOnUnknownElements,this._instanceErrorOnUnknownPropertiesOption=moduleDef.errorOnUnknownProperties,this._previousErrorOnUnknownElementsOption=(0,core["ɵgetUnknownElementStrictMode"])(),(0,core["ɵsetUnknownElementStrictMode"])(this.shouldThrowErrorOnUnknownElements()),this._previousErrorOnUnknownPropertiesOption=(0,core["ɵgetUnknownPropertyStrictMode"])(),(0,core["ɵsetUnknownPropertyStrictMode"])(this.shouldThrowErrorOnUnknownProperties()),this.compiler.configureTestingModule(moduleDef),this}compileComponents(){return this.compiler.compileComponents()}inject(token,notFoundValue,flags){if(token===TestBed)return this;const UNDEFINED={},result=this.testModuleRef.injector.get(token,UNDEFINED,(0,core["ɵconvertToBitFlags"])(flags));return result===UNDEFINED?this.compiler.injector.get(token,notFoundValue,flags):result}get(token,notFoundValue=core.Injector.THROW_IF_NOT_FOUND,flags=core.InjectFlags.Default){return this.inject(token,notFoundValue,flags)}runInInjectionContext(fn){return this.inject(core.EnvironmentInjector).runInContext(fn)}execute(tokens,fn,context){const params=tokens.map((t=>this.inject(t)));return fn.apply(context,params)}overrideModule(ngModule,override){return this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(ngModule,override),this}overrideComponent(component,override){return this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(component,override),this}overrideTemplateUsingTestingModule(component,template){return this.assertNotInstantiated("R3TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(component,template),this}overrideDirective(directive,override){return this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(directive,override),this}overridePipe(pipe,override){return this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(pipe,override),this}overrideProvider(token,provider){return this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(token,provider),this}overrideTemplate(component,template){return this.overrideComponent(component,{set:{template,templateUrl:null}})}createComponent(type){const testComponentRenderer=this.inject(TestComponentRenderer),rootElId="root"+_nextRootElementId++;testComponentRenderer.insertRootElement(rootElId);const componentDef=type.ɵcmp;if(!componentDef)throw new Error(`It looks like '${(0,core["ɵstringify"])(type)}' has not been compiled.`);const noNgZone=this.inject(ComponentFixtureNoNgZone,!1),autoDetect=this.inject(ComponentFixtureAutoDetect,!1),ngZone=noNgZone?null:this.inject(core.NgZone,null),componentFactory=new core["ɵRender3ComponentFactory"](componentDef),initComponent=()=>{const componentRef=componentFactory.create(core.Injector.NULL,[],`#${rootElId}`,this.testModuleRef);return new ComponentFixture(componentRef,ngZone,autoDetect)},fixture=ngZone?ngZone.run(initComponent):initComponent();return this._activeFixtures.push(fixture),fixture}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(methodName,methodDescription){if(null!==this._testModuleRef)throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${methodName}\`.`)}checkGlobalCompilationFinished(){this.globalCompilationChecked||null!==this._testModuleRef||(0,core["ɵflushModuleScopingQueueAsMuchAsPossible"])(),this.globalCompilationChecked=!0}destroyActiveFixtures(){let errorCount=0;if(this._activeFixtures.forEach((fixture=>{try{fixture.destroy()}catch(e){errorCount++,console.error("Error during cleanup of component",{component:fixture.componentInstance,stacktrace:e})}})),this._activeFixtures=[],errorCount>0&&this.shouldRethrowTeardownErrors())throw Error(`${errorCount} ${1===errorCount?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const instanceOptions=this._instanceTeardownOptions,environmentOptions=TestBedImpl._environmentTeardownOptions;return!instanceOptions&&!environmentOptions||(instanceOptions?.rethrowErrors??environmentOptions?.rethrowErrors??this.shouldTearDownTestingModule())}shouldThrowErrorOnUnknownElements(){return this._instanceErrorOnUnknownElementsOption??TestBedImpl._environmentErrorOnUnknownElementsOption??false}shouldThrowErrorOnUnknownProperties(){return this._instanceErrorOnUnknownPropertiesOption??TestBedImpl._environmentErrorOnUnknownPropertiesOption??false}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??TestBedImpl._environmentTeardownOptions?.destroyAfterEach??true}tearDownTestingModule(){if(null===this._testModuleRef)return;const testRenderer=this.inject(TestComponentRenderer);try{this._testModuleRef.destroy()}catch(e){if(this.shouldRethrowTeardownErrors())throw e;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:e})}finally{testRenderer.removeAllRootElements?.()}}}const TestBed=TestBedImpl;const _global="undefined"==typeof window?__webpack_require__.g:window;function getCleanupHook(expectedTeardownValue){return()=>{const testBed=TestBedImpl.INSTANCE;testBed.shouldTearDownTestingModule()===expectedTeardownValue&&(testBed.resetTestingModule(),function resetFakeAsyncZone(){if(fakeAsyncTestModule)return fakeAsyncTestModule.resetFakeAsyncZone();throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage)}())}}_global.beforeEach&&_global.beforeEach(getCleanupHook(!1)),_global.afterEach&&_global.afterEach(getCleanupHook(!0));class RouterTestingModule{static withRoutes(routes,config){return{ngModule:RouterTestingModule,providers:[{provide:fesm2022_router.Z6,multi:!0,useValue:routes},{provide:fesm2022_router.cx,useValue:config||{}}]}}static#_=this.ɵfac=function RouterTestingModule_Factory(t){return new(t||RouterTestingModule)};static#_2=this.ɵmod=core["ɵɵdefineNgModule"]({type:RouterTestingModule,exports:[fesm2022_router.Bz]});static#_3=this.ɵinj=core["ɵɵdefineInjector"]({providers:[fesm2022_router.Kx,provideLocationMocks(),(0,fesm2022_router.HJ)(fesm2022_router.GZ).ɵproviders,{provide:fesm2022_router.Z6,multi:!0,useValue:[]}],imports:[fesm2022_router.Bz]})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RouterTestingModule,[{type:core.NgModule,args:[{exports:[fesm2022_router.Bz],providers:[fesm2022_router.Kx,provideLocationMocks(),(0,fesm2022_router.HJ)(fesm2022_router.GZ).ɵproviders,{provide:fesm2022_router.Z6,multi:!0,useValue:[]}]}]}],null,null);class RootFixtureService{createHarness(){if(this.harness)throw new Error("Only one harness should be created per test.");return this.harness=new RouterTestingHarness(this.getRootFixture()),this.harness}getRootFixture(){return void 0!==this.fixture||(this.fixture=TestBed.createComponent(RootCmp),this.fixture.detectChanges()),this.fixture}static#_=this.ɵfac=function RootFixtureService_Factory(t){return new(t||RootFixtureService)};static#_2=this.ɵprov=core["ɵɵdefineInjectable"]({token:RootFixtureService,factory:RootFixtureService.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootFixtureService,[{type:core.Injectable,args:[{providedIn:"root"}]}],null,null);class RootCmp{static#_=this.ɵfac=function RootCmp_Factory(t){return new(t||RootCmp)};static#_2=this.ɵcmp=core["ɵɵdefineComponent"]({type:RootCmp,selectors:[["ng-component"]],viewQuery:function RootCmp_Query(rf,ctx){if(1&rf&&core["ɵɵviewQuery"](fesm2022_router.lC,5),2&rf){let _t;core["ɵɵqueryRefresh"](_t=core["ɵɵloadQuery"]())&&(ctx.outlet=_t.first)}},standalone:!0,features:[core["ɵɵStandaloneFeature"]],decls:1,vars:0,template:function RootCmp_Template(rf,ctx){1&rf&&core["ɵɵelement"](0,"router-outlet")},dependencies:[fesm2022_router.lC],encapsulation:2})}("undefined"==typeof ngDevMode||ngDevMode)&&core["ɵsetClassMetadata"](RootCmp,[{type:core.Component,args:[{standalone:!0,template:"<router-outlet></router-outlet>",imports:[fesm2022_router.lC]}]}],null,{outlet:[{type:core.ViewChild,args:[fesm2022_router.lC]}]});class RouterTestingHarness{static create(initialUrl){return(0,asyncToGenerator.Z)((function*(){const harness=TestBed.inject(RootFixtureService).createHarness();return void 0!==initialUrl&&(yield harness.navigateByUrl(initialUrl)),harness}))()}constructor(fixture){this.fixture=fixture}detectChanges(){this.fixture.detectChanges()}get routeDebugElement(){const outlet=this.fixture.componentInstance.outlet;return outlet&&outlet.isActivated?this.fixture.debugElement.query((v=>v.componentInstance===outlet.component)):null}get routeNativeElement(){return this.routeDebugElement?.nativeElement??null}navigateByUrl(url,requiredRoutedComponentType){var _this=this;return(0,asyncToGenerator.Z)((function*(){const router=TestBed.inject(fesm2022_router.F0);let resolveFn;const redirectTrackingPromise=new Promise((resolve=>{resolveFn=resolve}));(0,fesm2022_router.X0)(TestBed.inject(fesm2022_router.F0),resolveFn),yield router.navigateByUrl(url),yield redirectTrackingPromise,_this.fixture.detectChanges();const outlet=_this.fixture.componentInstance.outlet;if(outlet&&outlet.isActivated&&outlet.activatedRoute.component){const activatedComponent=outlet.component;if(void 0!==requiredRoutedComponentType&&!(activatedComponent instanceof requiredRoutedComponentType))throw new Error(`Unexpected routed component type. Expected ${requiredRoutedComponentType.name} but got ${activatedComponent.constructor.name}`);return activatedComponent}return null}))()}}},"./node_modules/rxjs/dist/esm5/internal/observable/defer.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{P:()=>defer});var _Observable__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/Observable.js"),_innerFrom__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js");function defer(observableFactory){return new _Observable__WEBPACK_IMPORTED_MODULE_0__.y((function(subscriber){(0,_innerFrom__WEBPACK_IMPORTED_MODULE_1__.Xf)(observableFactory()).subscribe(subscriber)}))}},"./node_modules/rxjs/dist/esm5/internal/operators/mapTo.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{h:()=>mapTo});var _map__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/rxjs/dist/esm5/internal/operators/map.js");function mapTo(value){return(0,_map__WEBPACK_IMPORTED_MODULE_0__.U)((function(){return value}))}}}]);